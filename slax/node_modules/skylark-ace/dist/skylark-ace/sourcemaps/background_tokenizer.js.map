{"version":3,"sources":["background_tokenizer.js"],"names":["define","require","exports","module","oop","EventEmitter","BackgroundTokenizer","tokenizer","editor","this","running","lines","states","currentLine","self","$worker","workerStart","Date","endLine","doc","startLine","len","getLength","processedLines","$tokenizeRow","setTimeout","fireUpdateEvent","implement","setTokenizer","start","setDocument","stop","firstRow","lastRow","data","first","last","_signal","startRow","Math","min","splice","length","scheduleStart","$updateOnChange","delta","row","end","action","args","Array","unshift","apply","clearTimeout","getTokens","getState","line","getLine","state","getLineTokens","tokens","call","prototype"],"mappings":"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","file":"../background_tokenizer.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n * \r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar oop = require(\"./lib/oop\");\r\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\r\n\r\n\r\n/**\r\n * Tokenizes the current [[Document `Document`]] in the background, and caches the tokenized rows for future use. \r\n * \r\n * If a certain row is changed, everything below that row is re-tokenized.\r\n *\r\n * @class BackgroundTokenizer\r\n **/\r\n\r\n/**\r\n * Creates a new `BackgroundTokenizer` object.\r\n * @param {Tokenizer} tokenizer The tokenizer to use\r\n * @param {Editor} editor The editor to associate with\r\n *\r\n * @constructor\r\n **/\r\n\r\nvar BackgroundTokenizer = function(tokenizer, editor) {\r\n    this.running = false;\r\n    this.lines = [];\r\n    this.states = [];\r\n    this.currentLine = 0;\r\n    this.tokenizer = tokenizer;\r\n\r\n    var self = this;\r\n\r\n    this.$worker = function() {\r\n        if (!self.running) { return; }\r\n\r\n        var workerStart = new Date();\r\n        var currentLine = self.currentLine;\r\n        var endLine = -1;\r\n        var doc = self.doc;\r\n\r\n        var startLine = currentLine;\r\n        while (self.lines[currentLine])\r\n            currentLine++;\r\n        \r\n        var len = doc.getLength();\r\n        var processedLines = 0;\r\n        self.running = false;\r\n        while (currentLine < len) {\r\n            self.$tokenizeRow(currentLine);\r\n            endLine = currentLine;\r\n            do {\r\n                currentLine++;\r\n            } while (self.lines[currentLine]);\r\n\r\n            // only check every 5 lines\r\n            processedLines ++;\r\n            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {\r\n                self.running = setTimeout(self.$worker, 20);\r\n                break;\r\n            }\r\n        }\r\n        self.currentLine = currentLine;\r\n        \r\n        if (endLine == -1)\r\n            endLine = currentLine;\r\n        \r\n        if (startLine <= endLine)\r\n            self.fireUpdateEvent(startLine, endLine);\r\n    };\r\n};\r\n\r\n(function(){\r\n\r\n    oop.implement(this, EventEmitter);\r\n\r\n    /**\r\n     * Sets a new tokenizer for this object.\r\n     *\r\n     * @param {Tokenizer} tokenizer The new tokenizer to use\r\n     *\r\n     **/\r\n    this.setTokenizer = function(tokenizer) {\r\n        this.tokenizer = tokenizer;\r\n        this.lines = [];\r\n        this.states = [];\r\n\r\n        this.start(0);\r\n    };\r\n\r\n    /**\r\n     * Sets a new document to associate with this object.\r\n     * @param {Document} doc The new document to associate with\r\n     **/\r\n    this.setDocument = function(doc) {\r\n        this.doc = doc;\r\n        this.lines = [];\r\n        this.states = [];\r\n\r\n        this.stop();\r\n    };\r\n\r\n     /**\r\n     * Fires whenever the background tokeniziers between a range of rows are going to be updated.\r\n     * \r\n     * @event update\r\n     * @param {Object} e An object containing two properties, `first` and `last`, which indicate the rows of the region being updated.\r\n     *\r\n     **/\r\n    /**\r\n     * Emits the `'update'` event. `firstRow` and `lastRow` are used to define the boundaries of the region to be updated.\r\n     * @param {Number} firstRow The starting row region\r\n     * @param {Number} lastRow The final row region\r\n     *\r\n     **/\r\n    this.fireUpdateEvent = function(firstRow, lastRow) {\r\n        var data = {\r\n            first: firstRow,\r\n            last: lastRow\r\n        };\r\n        this._signal(\"update\", {data: data});\r\n    };\r\n\r\n    /**\r\n     * Starts tokenizing at the row indicated.\r\n     *\r\n     * @param {Number} startRow The row to start at\r\n     *\r\n     **/\r\n    this.start = function(startRow) {\r\n        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());\r\n\r\n        // remove all cached items below this line\r\n        this.lines.splice(this.currentLine, this.lines.length);\r\n        this.states.splice(this.currentLine, this.states.length);\r\n\r\n        this.stop();\r\n        // pretty long delay to prevent the tokenizer from interfering with the user\r\n        this.running = setTimeout(this.$worker, 700);\r\n    };\r\n    \r\n    this.scheduleStart = function() {\r\n        if (!this.running)\r\n            this.running = setTimeout(this.$worker, 700);\r\n    };\r\n\r\n    this.$updateOnChange = function(delta) {\r\n        var startRow = delta.start.row;\r\n        var len = delta.end.row - startRow;\r\n\r\n        if (len === 0) {\r\n            this.lines[startRow] = null;\r\n        } else if (delta.action == \"remove\") {\r\n            this.lines.splice(startRow, len + 1, null);\r\n            this.states.splice(startRow, len + 1, null);\r\n        } else {\r\n            var args = Array(len + 1);\r\n            args.unshift(startRow, 1);\r\n            this.lines.splice.apply(this.lines, args);\r\n            this.states.splice.apply(this.states, args);\r\n        }\r\n\r\n        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());\r\n\r\n        this.stop();\r\n    };\r\n\r\n    /**\r\n     * Stops tokenizing.\r\n     *\r\n     **/\r\n    this.stop = function() {\r\n        if (this.running)\r\n            clearTimeout(this.running);\r\n        this.running = false;\r\n    };\r\n\r\n    /**\r\n     * Gives list of tokens of the row. (tokens are cached)\r\n     * \r\n     * @param {Number} row The row to get tokens at\r\n     *\r\n     * \r\n     *\r\n     **/\r\n    this.getTokens = function(row) {\r\n        return this.lines[row] || this.$tokenizeRow(row);\r\n    };\r\n\r\n    /**\r\n     * [Returns the state of tokenization at the end of a row.]{: #BackgroundTokenizer.getState}\r\n     *\r\n     * @param {Number} row The row to get state at\r\n     **/\r\n    this.getState = function(row) {\r\n        if (this.currentLine == row)\r\n            this.$tokenizeRow(row);\r\n        return this.states[row] || \"start\";\r\n    };\r\n\r\n    this.$tokenizeRow = function(row) {\r\n        var line = this.doc.getLine(row);\r\n        var state = this.states[row - 1];\r\n\r\n        var data = this.tokenizer.getLineTokens(line, state, row);\r\n\r\n        if (this.states[row] + \"\" !== data.state + \"\") {\r\n            this.states[row] = data.state;\r\n            this.lines[row + 1] = null;\r\n            if (this.currentLine > row + 1)\r\n                this.currentLine = row + 1;\r\n        } else if (this.currentLine == row) {\r\n            this.currentLine = row + 1;\r\n        }\r\n\r\n        return this.lines[row] = data.tokens;\r\n    };\r\n\r\n}).call(BackgroundTokenizer.prototype);\r\n\r\nexports.BackgroundTokenizer = BackgroundTokenizer;\r\n});\r\n"]}