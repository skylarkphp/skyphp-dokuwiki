{"version":3,"sources":["edit_session.js"],"names":["define","require","exports","module","oop","lang","BidiHandler","config","EventEmitter","Selection","TextMode","Mode","Range","Document","BackgroundTokenizer","SearchHighlight","EditSession","text","mode","this","$breakpoints","$decorations","$frontMarkers","$backMarkers","$markerId","$undoSelect","$foldData","id","$uid","toString","join","on","onChangeFold","bind","$onChange","onChange","getLine","setDocument","selection","$bidiHandler","resetOptions","setMode","_signal","implement","doc","removeListener","bgTokenizer","getDocument","resetCaches","$resetRowCache","docRow","$docRowCache","$screenRowCache","l","length","i","$getRowCacheIndex","splice","cacheArray","val","low","hi","mid","c","$modified","$wrapData","$rowLengthCache","start","e","fold","data","row","delta","removedFolds","$updateInternalDataOnChange","$fromUndo","$undoManager","add","action","folds","mergeUndoDeltas","$informUndoManager","schedule","$updateOnChange","setValue","moveTo","setUndoManager","getUndoManager","reset","getValue","getSelection","getState","getTokens","getTokenAt","column","token","tokens","value","index","undoManager","cancel","self","addSession","$syncInformUndoManager","delayedCall","markUndoGroup","$defaultUndoManager","undo","redo","addSelection","startNewGroup","getTabString","getUseSoftTabs","stringRepeat","getTabSize","setUseSoftTabs","setOption","$useSoftTabs","$mode","$indentWithTabs","setTabSize","tabSize","$tabSize","isTabStop","position","setNavigateWithinSoftTabs","navigateWithinSoftTabs","getNavigateWithinSoftTabs","$navigateWithinSoftTabs","$overwrite","setOverwrite","overwrite","getOverwrite","toggleOverwrite","addGutterDecoration","className","removeGutterDecoration","replace","getBreakpoints","setBreakpoints","rows","clearBreakpoints","setBreakpoint","undefined","clearBreakpoint","addMarker","range","clazz","type","inFront","marker","renderer","addDynamicMarker","update","removeMarker","markerId","getMarkers","highlight","re","$searchHighlight","setRegexp","highlightLines","startRow","endRow","Infinity","setAnnotations","annotations","$annotations","getAnnotations","clearAnnotations","$detectNewLine","match","$autoNewLine","getWordRange","line","inToken","charAt","tokenRe","test","slice","nonTokenRe","end","getAWordRange","wordRange","setNewLineMode","newLineMode","getNewLineMode","setUseWorker","useWorker","getUseWorker","$useWorker","onReloadTokenizer","first","$modes","$modeId","cb","getTokenizer","$onChangeMode","options","path","loadModule","m","$id","$isPlaceholder","$stopWorker","$startWorker","tokenizer","addEventListener","setTokenizer","_self","attachToSession","$options","wrapMethod","set","call","$wrapMethod","$setFolding","foldingRules","_emit","$worker","terminate","createWorker","warn","getMode","$scrollTop","setScrollTop","scrollTop","isNaN","getScrollTop","$scrollLeft","setScrollLeft","scrollLeft","getScrollLeft","getScreenWidth","$computeWidth","lineWidgets","Math","max","getLineWidgetMaxWidth","screenWidth","lineWidgetsWidth","width","forEach","w","lineWidgetWidth","force","$useWrapMode","$wrapLimit","lines","getAllLines","cache","longestScreenLine","foldIndex","foldLine","foldStart","len","$getStringScreenWidth","getLines","firstRow","lastRow","getLength","getTextRange","getRange","insert","remove","removeFullLines","undoChanges","deltas","dontSelect","revertDelta","addFolds","selectionBefore","fromJSON","setRange","$getUndoSelection","redoChanges","applyDelta","selectionAfter","setUndoSelect","enable","isUndo","isInsert","point","compare","setStart","setEnd","fromPoints","moveText","fromRange","toPosition","copy","getFoldsInRange","toRange","rowDiff","collDiff","oldStart","newStart","map","x","clone","indentRows","indentString","insertInLine","outdentRows","rowRange","collapseRows","deleteRange","size","j","$moveLines","dir","getRowFoldStart","getRowFoldEnd","diff","$clipRowToDocument","Number","MAX_VALUE","insertFullLines","moveLinesUp","moveLinesDown","duplicateLines","min","$clipColumnToRow","$clipPositionToDocument","$clipRangeToDocument","$wrapLimitRange","setUseWrapMode","useWrapMode","Array","$updateWrapData","getUseWrapMode","setWrapLimitRange","markAsDirty","adjustWrapLimit","desiredLimit","$printMargin","limits","wrapLimit","$constrainWrapLimit","getWrapLimit","setWrapLimit","limit","getWrapLimitRange","$updating","foldLines","removeFolds","idx","getFoldLine","addRemoveChars","shiftRow","foldLineBefore","merge","indexOf","args","unshift","arr","apply","cmp","compareInside","split","abs","console","error","$updateRowLengthCache","b","wrapData","walk","placeholder","lastColumn","walkTokens","$getDisplayTokens","PLACEHOLDER_START","PLACEHOLDER_BODY","substring","concat","$computeWrapSplits","SPACE","TAB","TAB_SPACE","isFullWidth","splits","displayLength","lastSplit","lastDocSplit","isCode","$wrapAsCode","indentedSoftWrap","$indentedSoftWrap","maxIndent","floor","addSplit","screenPos","ch","indent","indentation","getWrapIndent","push","minSplit","str","offset","charCodeAt","getScreenTabSize","n","maxScreenColumn","screenColumn","getRowLength","h","rowCount","getRowLineCount","getRowWrapIndent","screenRow","pos","screenToDocumentPosition","getScreenLastRowColumn","documentToScreenColumn","getDocumentLastRowColumn","docColumn","documentToScreenRow","getDocumentLastRowColumnPosition","getRowSplitData","screenToDocumentRow","screenToDocumentColumn","offsetX","rowLength","rowCache","doCache","maxRow","getNextFoldLine","getFoldDisplayLine","wrapIndent","splitIndex","isBidiRow","offsetToCol","idxToPosition","documentToScreenPosition","foldStartRow","getFoldAt","rowEnd","textLine","wrapRow","screenRowOffset","getScreenLength","screenRows","foldData","$getWidgetScreenLength","$setFontMetrics","fm","$enableVarChar","getCharacterWidth","destroy","prototype","Folding","BracketMatch","defineOptions","wrap","parseInt","$wrap","col","get","handlesSet","initialValue","firstLineNumber","useSoftTabs","foldStyle","setFoldStyle"],"mappings":"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","file":"../edit_session.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar oop = require(\"./lib/oop\");\r\nvar lang = require(\"./lib/lang\");\r\nvar BidiHandler = require(\"./bidihandler\").BidiHandler;\r\nvar config = require(\"./config\");\r\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\r\nvar Selection = require(\"./selection\").Selection;\r\nvar TextMode = require(\"./mode/text\").Mode;\r\nvar Range = require(\"./range\").Range;\r\nvar Document = require(\"./document\").Document;\r\nvar BackgroundTokenizer = require(\"./background_tokenizer\").BackgroundTokenizer;\r\nvar SearchHighlight = require(\"./search_highlight\").SearchHighlight;\r\n\r\n/**\r\n * Stores all the data about [[Editor `Editor`]] state providing easy way to change editors state.\r\n *\r\n * `EditSession` can be attached to only one [[Document `Document`]]. Same `Document` can be attached to several `EditSession`s.\r\n * @class EditSession\r\n **/\r\n\r\n//{ events\r\n/**\r\n *\r\n * Emitted when the document changes.\r\n * @event change\r\n * @param {Object} e An object containing a `delta` of information about the change.\r\n **/\r\n/**\r\n * Emitted when the tab size changes, via [[EditSession.setTabSize]].\r\n *\r\n * @event changeTabSize\r\n **/\r\n/**\r\n * Emitted when the ability to overwrite text changes, via [[EditSession.setOverwrite]].\r\n *\r\n * @event changeOverwrite\r\n **/\r\n/**\r\n * Emitted when the gutter changes, either by setting or removing breakpoints, or when the gutter decorations change.\r\n *\r\n * @event changeBreakpoint\r\n **/\r\n/**\r\n * Emitted when a front marker changes.\r\n *\r\n * @event changeFrontMarker\r\n **/\r\n/**\r\n * Emitted when a back marker changes.\r\n *\r\n * @event changeBackMarker\r\n **/\r\n/**\r\n * Emitted when an annotation changes, like through [[EditSession.setAnnotations]].\r\n *\r\n * @event changeAnnotation\r\n **/\r\n/**\r\n * Emitted when a background tokenizer asynchronously processes new rows.\r\n * @event tokenizerUpdate\r\n *\r\n * @param {Object} e An object containing one property, `\"data\"`, that contains information about the changing rows\r\n *\r\n **/\r\n/**\r\n * Emitted when the current mode changes.\r\n *\r\n * @event changeMode\r\n *\r\n **/\r\n/**\r\n * Emitted when the wrap mode changes.\r\n *\r\n * @event changeWrapMode\r\n *\r\n **/\r\n/**\r\n * Emitted when the wrapping limit changes.\r\n *\r\n * @event changeWrapLimit\r\n *\r\n **/\r\n/**\r\n * Emitted when a code fold is added or removed.\r\n *\r\n * @event changeFold\r\n *\r\n **/\r\n /**\r\n * Emitted when the scroll top changes.\r\n * @event changeScrollTop\r\n *\r\n * @param {Number} scrollTop The new scroll top value\r\n **/\r\n/**\r\n * Emitted when the scroll left changes.\r\n * @event changeScrollLeft\r\n *\r\n * @param {Number} scrollLeft The new scroll left value\r\n **/\r\n//}\r\n\r\n/**\r\n * Sets up a new `EditSession` and associates it with the given `Document` and `TextMode`.\r\n * @param {Document | String} text [If `text` is a `Document`, it associates the `EditSession` with it. Otherwise, a new `Document` is created, with the initial text]{: #textParam}\r\n * @param {TextMode} mode [The initial language mode to use for the document]{: #modeParam}\r\n *\r\n * @constructor\r\n **/\r\n\r\nvar EditSession = function(text, mode) {\r\n    this.$breakpoints = [];\r\n    this.$decorations = [];\r\n    this.$frontMarkers = {};\r\n    this.$backMarkers = {};\r\n    this.$markerId = 1;\r\n    this.$undoSelect = true;\r\n\r\n    this.$foldData = [];\r\n    this.id = \"session\" + (++EditSession.$uid);\r\n    this.$foldData.toString = function() {\r\n        return this.join(\"\\n\");\r\n    };\r\n    this.on(\"changeFold\", this.onChangeFold.bind(this));\r\n    this.$onChange = this.onChange.bind(this);\r\n\r\n    if (typeof text != \"object\" || !text.getLine)\r\n        text = new Document(text);\r\n\r\n    this.setDocument(text);\r\n    this.selection = new Selection(this);\r\n    this.$bidiHandler = new BidiHandler(this);\r\n\r\n    config.resetOptions(this);\r\n    this.setMode(mode);\r\n    config._signal(\"session\", this);\r\n};\r\n\r\n\r\nEditSession.$uid = 0;\r\n\r\n(function() {\r\n\r\n    oop.implement(this, EventEmitter);\r\n\r\n    /**\r\n     * Sets the `EditSession` to point to a new `Document`. If a `BackgroundTokenizer` exists, it also points to `doc`.\r\n     *\r\n     * @param {Document} doc The new `Document` to use\r\n     *\r\n     **/\r\n    this.setDocument = function(doc) {\r\n        if (this.doc)\r\n            this.doc.removeListener(\"change\", this.$onChange);\r\n\r\n        this.doc = doc;\r\n        doc.on(\"change\", this.$onChange);\r\n\r\n        if (this.bgTokenizer)\r\n            this.bgTokenizer.setDocument(this.getDocument());\r\n\r\n        this.resetCaches();\r\n    };\r\n\r\n    /**\r\n     * Returns the `Document` associated with this session.\r\n     * @return {Document}\r\n     **/\r\n    this.getDocument = function() {\r\n        return this.doc;\r\n    };\r\n\r\n    /**\r\n     * @param {Number} row The row to work with\r\n     *\r\n     **/\r\n    this.$resetRowCache = function(docRow) {\r\n        if (!docRow) {\r\n            this.$docRowCache = [];\r\n            this.$screenRowCache = [];\r\n            return;\r\n        }\r\n        var l = this.$docRowCache.length;\r\n        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;\r\n        if (l > i) {\r\n            this.$docRowCache.splice(i, l);\r\n            this.$screenRowCache.splice(i, l);\r\n        }\r\n    };\r\n\r\n    this.$getRowCacheIndex = function(cacheArray, val) {\r\n        var low = 0;\r\n        var hi = cacheArray.length - 1;\r\n\r\n        while (low <= hi) {\r\n            var mid = (low + hi) >> 1;\r\n            var c = cacheArray[mid];\r\n\r\n            if (val > c)\r\n                low = mid + 1;\r\n            else if (val < c)\r\n                hi = mid - 1;\r\n            else\r\n                return mid;\r\n        }\r\n\r\n        return low -1;\r\n    };\r\n\r\n    this.resetCaches = function() {\r\n        this.$modified = true;\r\n        this.$wrapData = [];\r\n        this.$rowLengthCache = [];\r\n        this.$resetRowCache(0);\r\n        if (this.bgTokenizer)\r\n            this.bgTokenizer.start(0);\r\n    };\r\n\r\n    this.onChangeFold = function(e) {\r\n        var fold = e.data;\r\n        this.$resetRowCache(fold.start.row);\r\n    };\r\n\r\n    this.onChange = function(delta) {\r\n        this.$modified = true;\r\n        this.$bidiHandler.onChange(delta);\r\n        this.$resetRowCache(delta.start.row);\r\n\r\n        var removedFolds = this.$updateInternalDataOnChange(delta);\r\n        if (!this.$fromUndo && this.$undoManager) {\r\n            if (removedFolds && removedFolds.length) {\r\n                this.$undoManager.add({\r\n                    action: \"removeFolds\",\r\n                    folds:  removedFolds\r\n                }, this.mergeUndoDeltas);\r\n                this.mergeUndoDeltas = true;\r\n            }\r\n            this.$undoManager.add(delta, this.mergeUndoDeltas);\r\n            this.mergeUndoDeltas = true;\r\n            \r\n            this.$informUndoManager.schedule();\r\n        }\r\n\r\n        this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);\r\n        this._signal(\"change\", delta);\r\n    };\r\n\r\n    /**\r\n     * Sets the session text.\r\n     * @param {String} text The new text to place\r\n     *\r\n     **/\r\n    this.setValue = function(text) {\r\n        this.doc.setValue(text);\r\n        this.selection.moveTo(0, 0);\r\n\r\n        this.$resetRowCache(0);\r\n        this.setUndoManager(this.$undoManager);\r\n        this.getUndoManager().reset();\r\n    };\r\n\r\n    /**\r\n     * Returns the current [[Document `Document`]] as a string.\r\n     * @method toString\r\n     * @returns {String}\r\n     * @alias EditSession.getValue\r\n     *\r\n     **/\r\n\r\n    /**\r\n     * Returns the current [[Document `Document`]] as a string.\r\n     * @method getValue\r\n     * @returns {String}\r\n     * @alias EditSession.toString\r\n     **/\r\n    this.getValue =\r\n    this.toString = function() {\r\n        return this.doc.getValue();\r\n    };\r\n\r\n    /**\r\n     * Returns selection object.\r\n     **/\r\n    this.getSelection = function() {\r\n        return this.selection;\r\n    };\r\n\r\n    /**\r\n     * {:BackgroundTokenizer.getState}\r\n     * @param {Number} row The row to start at\r\n     *\r\n     * @related BackgroundTokenizer.getState\r\n     **/\r\n    this.getState = function(row) {\r\n        return this.bgTokenizer.getState(row);\r\n    };\r\n\r\n    /**\r\n     * Starts tokenizing at the row indicated. Returns a list of objects of the tokenized rows.\r\n     * @param {Number} row The row to start at\r\n     *\r\n     *\r\n     *\r\n     **/\r\n    this.getTokens = function(row) {\r\n        return this.bgTokenizer.getTokens(row);\r\n    };\r\n\r\n    /**\r\n     * Returns an object indicating the token at the current row. The object has two properties: `index` and `start`.\r\n     * @param {Number} row The row number to retrieve from\r\n     * @param {Number} column The column number to retrieve from\r\n     *\r\n     *\r\n     **/\r\n    this.getTokenAt = function(row, column) {\r\n        var tokens = this.bgTokenizer.getTokens(row);\r\n        var token, c = 0;\r\n        if (column == null) {\r\n            var i = tokens.length - 1;\r\n            c = this.getLine(row).length;\r\n        } else {\r\n            for (var i = 0; i < tokens.length; i++) {\r\n                c += tokens[i].value.length;\r\n                if (c >= column)\r\n                    break;\r\n            }\r\n        }\r\n        token = tokens[i];\r\n        if (!token)\r\n            return null;\r\n        token.index = i;\r\n        token.start = c - token.value.length;\r\n        return token;\r\n    };\r\n\r\n    /**\r\n     * Sets the undo manager.\r\n     * @param {UndoManager} undoManager The new undo manager\r\n     *\r\n     *\r\n     **/\r\n    this.setUndoManager = function(undoManager) {\r\n        this.$undoManager = undoManager;\r\n        \r\n        if (this.$informUndoManager)\r\n            this.$informUndoManager.cancel();\r\n        \r\n        if (undoManager) {\r\n            var self = this;\r\n            undoManager.addSession(this);\r\n            this.$syncInformUndoManager = function() {\r\n                self.$informUndoManager.cancel();\r\n                self.mergeUndoDeltas = false;\r\n            };\r\n            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);\r\n        } else {\r\n            this.$syncInformUndoManager = function() {};\r\n        }\r\n    };\r\n\r\n    /**\r\n     * starts a new group in undo history\r\n     **/\r\n    this.markUndoGroup = function() {\r\n        if (this.$syncInformUndoManager)\r\n            this.$syncInformUndoManager();\r\n    };\r\n    \r\n    this.$defaultUndoManager = {\r\n        undo: function() {},\r\n        redo: function() {},\r\n        reset: function() {},\r\n        add: function() {},\r\n        addSelection: function() {},\r\n        startNewGroup: function() {},\r\n        addSession: function() {}\r\n    };\r\n\r\n    /**\r\n     * Returns the current undo manager.\r\n     **/\r\n    this.getUndoManager = function() {\r\n        return this.$undoManager || this.$defaultUndoManager;\r\n    };\r\n\r\n    /**\r\n     * Returns the current value for tabs. If the user is using soft tabs, this will be a series of spaces (defined by [[EditSession.getTabSize `getTabSize()`]]); otherwise it's simply `'\\t'`.\r\n     **/\r\n    this.getTabString = function() {\r\n        if (this.getUseSoftTabs()) {\r\n            return lang.stringRepeat(\" \", this.getTabSize());\r\n        } else {\r\n            return \"\\t\";\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Pass `true` to enable the use of soft tabs. Soft tabs means you're using spaces instead of the tab character (`'\\t'`).\r\n     * @param {Boolean} useSoftTabs Value indicating whether or not to use soft tabs\r\n     **/\r\n    this.setUseSoftTabs = function(val) {\r\n        this.setOption(\"useSoftTabs\", val);\r\n    };\r\n    /**\r\n     * Returns `true` if soft tabs are being used, `false` otherwise.\r\n     * @returns {Boolean}\r\n     **/\r\n    this.getUseSoftTabs = function() {\r\n        // todo might need more general way for changing settings from mode, but this is ok for now\r\n        return this.$useSoftTabs && !this.$mode.$indentWithTabs;\r\n    };\r\n    /**\r\n     * Set the number of spaces that define a soft tab; for example, passing in `4` transforms the soft tabs to be equivalent to four spaces. This function also emits the `changeTabSize` event.\r\n     * @param {Number} tabSize The new tab size\r\n     **/\r\n    this.setTabSize = function(tabSize) {\r\n        this.setOption(\"tabSize\", tabSize);\r\n    };\r\n    /**\r\n     * Returns the current tab size.\r\n     **/\r\n    this.getTabSize = function() {\r\n        return this.$tabSize;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if the character at the position is a soft tab.\r\n     * @param {Object} position The position to check\r\n     *\r\n     **/\r\n    this.isTabStop = function(position) {\r\n        return this.$useSoftTabs && (position.column % this.$tabSize === 0);\r\n    };\r\n\r\n    /**\r\n     * Set whether keyboard navigation of soft tabs moves the cursor within the soft tab, rather than over\r\n     * @param {Boolean} navigateWithinSoftTabs Value indicating whether or not to navigate within soft tabs\r\n     **/\r\n    this.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {\r\n        this.setOption(\"navigateWithinSoftTabs\", navigateWithinSoftTabs);\r\n    };\r\n    /**\r\n     * Returns `true` if keyboard navigation moves the cursor within soft tabs, `false` if it moves the cursor over soft tabs.\r\n     * @returns {Boolean}\r\n     **/\r\n    this.getNavigateWithinSoftTabs = function() {\r\n        return this.$navigateWithinSoftTabs;\r\n    };\r\n\r\n    this.$overwrite = false;\r\n    /**\r\n     * Pass in `true` to enable overwrites in your session, or `false` to disable.\r\n     *\r\n     * If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emits the `changeOverwrite` event.\r\n     *\r\n     * @param {Boolean} overwrite Defines whether or not to set overwrites\r\n     *\r\n     *\r\n     **/\r\n    this.setOverwrite = function(overwrite) {\r\n        this.setOption(\"overwrite\", overwrite);\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if overwrites are enabled; `false` otherwise.\r\n     **/\r\n    this.getOverwrite = function() {\r\n        return this.$overwrite;\r\n    };\r\n\r\n    /**\r\n     * Sets the value of overwrite to the opposite of whatever it currently is.\r\n     **/\r\n    this.toggleOverwrite = function() {\r\n        this.setOverwrite(!this.$overwrite);\r\n    };\r\n\r\n    /**\r\n     * Adds `className` to the `row`, to be used for CSS stylings and whatnot.\r\n     * @param {Number} row The row number\r\n     * @param {String} className The class to add\r\n     *\r\n     **/\r\n    this.addGutterDecoration = function(row, className) {\r\n        if (!this.$decorations[row])\r\n            this.$decorations[row] = \"\";\r\n        this.$decorations[row] += \" \" + className;\r\n        this._signal(\"changeBreakpoint\", {});\r\n    };\r\n\r\n    /**\r\n     * Removes `className` from the `row`.\r\n     * @param {Number} row The row number\r\n     * @param {String} className The class to add\r\n     *\r\n     **/\r\n    this.removeGutterDecoration = function(row, className) {\r\n        this.$decorations[row] = (this.$decorations[row] || \"\").replace(\" \" + className, \"\");\r\n        this._signal(\"changeBreakpoint\", {});\r\n    };\r\n\r\n    /**\r\n     * Returns an array of strings, indicating the breakpoint class (if any) applied to each row.\r\n     * @returns {[String]}\r\n     **/\r\n    this.getBreakpoints = function() {\r\n        return this.$breakpoints;\r\n    };\r\n\r\n    /**\r\n     * Sets a breakpoint on every row number given by `rows`. This function also emites the `'changeBreakpoint'` event.\r\n     * @param {Array} rows An array of row indices\r\n     *\r\n     **/\r\n    this.setBreakpoints = function(rows) {\r\n        this.$breakpoints = [];\r\n        for (var i=0; i<rows.length; i++) {\r\n            this.$breakpoints[rows[i]] = \"ace_breakpoint\";\r\n        }\r\n        this._signal(\"changeBreakpoint\", {});\r\n    };\r\n\r\n    /**\r\n     * Removes all breakpoints on the rows. This function also emits the `'changeBreakpoint'` event.\r\n     **/\r\n    this.clearBreakpoints = function() {\r\n        this.$breakpoints = [];\r\n        this._signal(\"changeBreakpoint\", {});\r\n    };\r\n\r\n    /**\r\n     * Sets a breakpoint on the row number given by `row`. This function also emits the `'changeBreakpoint'` event.\r\n     * @param {Number} row A row index\r\n     * @param {String} className Class of the breakpoint\r\n     *\r\n     **/\r\n    this.setBreakpoint = function(row, className) {\r\n        if (className === undefined)\r\n            className = \"ace_breakpoint\";\r\n        if (className)\r\n            this.$breakpoints[row] = className;\r\n        else\r\n            delete this.$breakpoints[row];\r\n        this._signal(\"changeBreakpoint\", {});\r\n    };\r\n\r\n    /**\r\n     * Removes a breakpoint on the row number given by `row`. This function also emits the `'changeBreakpoint'` event.\r\n     * @param {Number} row A row index\r\n     *\r\n     **/\r\n    this.clearBreakpoint = function(row) {\r\n        delete this.$breakpoints[row];\r\n        this._signal(\"changeBreakpoint\", {});\r\n    };\r\n\r\n    /**\r\n     * Adds a new marker to the given `Range`. If `inFront` is `true`, a front marker is defined, and the `'changeFrontMarker'` event fires; otherwise, the `'changeBackMarker'` event fires.\r\n     * @param {Range} range Define the range of the marker\r\n     * @param {String} clazz Set the CSS class for the marker\r\n     * @param {Function | String} type Identify the type of the marker\r\n     * @param {Boolean} inFront Set to `true` to establish a front marker\r\n     *\r\n     * @return {Number} The new marker id\r\n     **/\r\n    this.addMarker = function(range, clazz, type, inFront) {\r\n        var id = this.$markerId++;\r\n\r\n        var marker = {\r\n            range : range,\r\n            type : type || \"line\",\r\n            renderer: typeof type == \"function\" ? type : null,\r\n            clazz : clazz,\r\n            inFront: !!inFront,\r\n            id: id\r\n        };\r\n\r\n        if (inFront) {\r\n            this.$frontMarkers[id] = marker;\r\n            this._signal(\"changeFrontMarker\");\r\n        } else {\r\n            this.$backMarkers[id] = marker;\r\n            this._signal(\"changeBackMarker\");\r\n        }\r\n\r\n        return id;\r\n    };\r\n\r\n    /**\r\n     * Adds a dynamic marker to the session.\r\n     * @param {Object} marker object with update method\r\n     * @param {Boolean} inFront Set to `true` to establish a front marker\r\n     *\r\n     * @return {Object} The added marker\r\n     **/\r\n    this.addDynamicMarker = function(marker, inFront) {\r\n        if (!marker.update)\r\n            return;\r\n        var id = this.$markerId++;\r\n        marker.id = id;\r\n        marker.inFront = !!inFront;\r\n\r\n        if (inFront) {\r\n            this.$frontMarkers[id] = marker;\r\n            this._signal(\"changeFrontMarker\");\r\n        } else {\r\n            this.$backMarkers[id] = marker;\r\n            this._signal(\"changeBackMarker\");\r\n        }\r\n\r\n        return marker;\r\n    };\r\n\r\n    /**\r\n     * Removes the marker with the specified ID. If this marker was in front, the `'changeFrontMarker'` event is emitted. If the marker was in the back, the `'changeBackMarker'` event is emitted.\r\n     * @param {Number} markerId A number representing a marker\r\n     *\r\n     **/\r\n    this.removeMarker = function(markerId) {\r\n        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];\r\n        if (!marker)\r\n            return;\r\n\r\n        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;\r\n        delete (markers[markerId]);\r\n        this._signal(marker.inFront ? \"changeFrontMarker\" : \"changeBackMarker\");\r\n    };\r\n\r\n    /**\r\n     * Returns an object containing all of the markers, either front or back.\r\n     * @param {Boolean} inFront If `true`, indicates you only want front markers; `false` indicates only back markers\r\n     *\r\n     * @returns {Object}\r\n     **/\r\n    this.getMarkers = function(inFront) {\r\n        return inFront ? this.$frontMarkers : this.$backMarkers;\r\n    };\r\n\r\n    this.highlight = function(re) {\r\n        if (!this.$searchHighlight) {\r\n            var highlight = new SearchHighlight(null, \"ace_selected-word\", \"text\");\r\n            this.$searchHighlight = this.addDynamicMarker(highlight);\r\n        }\r\n        this.$searchHighlight.setRegexp(re);\r\n    };\r\n\r\n    // experimental\r\n    this.highlightLines = function(startRow, endRow, clazz, inFront) {\r\n        if (typeof endRow != \"number\") {\r\n            clazz = endRow;\r\n            endRow = startRow;\r\n        }\r\n        if (!clazz)\r\n            clazz = \"ace_step\";\r\n\r\n        var range = new Range(startRow, 0, endRow, Infinity);\r\n        range.id = this.addMarker(range, clazz, \"fullLine\", inFront);\r\n        return range;\r\n    };\r\n\r\n    /*\r\n     * Error:\r\n     *  {\r\n     *    row: 12,\r\n     *    column: 2, //can be undefined\r\n     *    text: \"Missing argument\",\r\n     *    type: \"error\" // or \"warning\" or \"info\"\r\n     *  }\r\n     */\r\n    /**\r\n     * Sets annotations for the `EditSession`. This functions emits the `'changeAnnotation'` event.\r\n     * @param {Array} annotations A list of annotations\r\n     *\r\n     **/\r\n    this.setAnnotations = function(annotations) {\r\n        this.$annotations = annotations;\r\n        this._signal(\"changeAnnotation\", {});\r\n    };\r\n\r\n    /**\r\n     * Returns the annotations for the `EditSession`.\r\n     * @returns {Array}\r\n     **/\r\n    this.getAnnotations = function() {\r\n        return this.$annotations || [];\r\n    };\r\n\r\n    /**\r\n     * Clears all the annotations for this session. This function also triggers the `'changeAnnotation'` event.\r\n     **/\r\n    this.clearAnnotations = function() {\r\n        this.setAnnotations([]);\r\n    };\r\n\r\n    /**\r\n     * If `text` contains either the newline (`\\n`) or carriage-return ('\\r') characters, `$autoNewLine` stores that value.\r\n     * @param {String} text A block of text\r\n     *\r\n     **/\r\n    this.$detectNewLine = function(text) {\r\n        var match = text.match(/^.*?(\\r?\\n)/m);\r\n        if (match) {\r\n            this.$autoNewLine = match[1];\r\n        } else {\r\n            this.$autoNewLine = \"\\n\";\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Given a starting row and column, this method returns the `Range` of the first word boundary it finds.\r\n     * @param {Number} row The row to start at\r\n     * @param {Number} column The column to start at\r\n     *\r\n     * @returns {Range}\r\n     **/\r\n    this.getWordRange = function(row, column) {\r\n        var line = this.getLine(row);\r\n\r\n        var inToken = false;\r\n        if (column > 0)\r\n            inToken = !!line.charAt(column - 1).match(this.tokenRe);\r\n\r\n        if (!inToken)\r\n            inToken = !!line.charAt(column).match(this.tokenRe);\r\n\r\n        if (inToken)\r\n            var re = this.tokenRe;\r\n        else if (/^\\s+$/.test(line.slice(column-1, column+1)))\r\n            var re = /\\s/;\r\n        else\r\n            var re = this.nonTokenRe;\r\n\r\n        var start = column;\r\n        if (start > 0) {\r\n            do {\r\n                start--;\r\n            }\r\n            while (start >= 0 && line.charAt(start).match(re));\r\n            start++;\r\n        }\r\n\r\n        var end = column;\r\n        while (end < line.length && line.charAt(end).match(re)) {\r\n            end++;\r\n        }\r\n\r\n        return new Range(row, start, row, end);\r\n    };\r\n\r\n    /**\r\n     * Gets the range of a word, including its right whitespace.\r\n     * @param {Number} row The row number to start from\r\n     * @param {Number} column The column number to start from\r\n     *\r\n     * @return {Range}\r\n     **/\r\n    this.getAWordRange = function(row, column) {\r\n        var wordRange = this.getWordRange(row, column);\r\n        var line = this.getLine(wordRange.end.row);\r\n\r\n        while (line.charAt(wordRange.end.column).match(/[ \\t]/)) {\r\n            wordRange.end.column += 1;\r\n        }\r\n        return wordRange;\r\n    };\r\n\r\n    /**\r\n     * {:Document.setNewLineMode.desc}\r\n     * @param {String} newLineMode {:Document.setNewLineMode.param}\r\n     *\r\n     *\r\n     * @related Document.setNewLineMode\r\n     **/\r\n    this.setNewLineMode = function(newLineMode) {\r\n        this.doc.setNewLineMode(newLineMode);\r\n    };\r\n\r\n    /**\r\n     *\r\n     * Returns the current new line mode.\r\n     * @returns {String}\r\n     * @related Document.getNewLineMode\r\n     **/\r\n    this.getNewLineMode = function() {\r\n        return this.doc.getNewLineMode();\r\n    };\r\n\r\n    /**\r\n     * Identifies if you want to use a worker for the `EditSession`.\r\n     * @param {Boolean} useWorker Set to `true` to use a worker\r\n     *\r\n     **/\r\n    this.setUseWorker = function(useWorker) { this.setOption(\"useWorker\", useWorker); };\r\n\r\n    /**\r\n     * Returns `true` if workers are being used.\r\n     **/\r\n    this.getUseWorker = function() { return this.$useWorker; };\r\n\r\n    /**\r\n     * Reloads all the tokens on the current session. This function calls [[BackgroundTokenizer.start `BackgroundTokenizer.start ()`]] to all the rows; it also emits the `'tokenizerUpdate'` event.\r\n     **/\r\n    this.onReloadTokenizer = function(e) {\r\n        var rows = e.data;\r\n        this.bgTokenizer.start(rows.first);\r\n        this._signal(\"tokenizerUpdate\", e);\r\n    };\r\n\r\n    this.$modes = config.$modes;\r\n\r\n    /**\r\n     * Sets a new text mode for the `EditSession`. This method also emits the `'changeMode'` event. If a [[BackgroundTokenizer `BackgroundTokenizer`]] is set, the `'tokenizerUpdate'` event is also emitted.\r\n     * @param {TextMode} mode Set a new text mode\r\n     * @param {cb} optional callback\r\n     *\r\n     **/\r\n    this.$mode = null;\r\n    this.$modeId = null;\r\n    this.setMode = function(mode, cb) {\r\n        if (mode && typeof mode === \"object\") {\r\n            if (mode.getTokenizer)\r\n                return this.$onChangeMode(mode);\r\n            var options = mode;\r\n            var path = options.path;\r\n        } else {\r\n            path = mode || \"ace/mode/text\";\r\n        }\r\n\r\n        // this is needed if ace isn't on require path (e.g tests in node)\r\n        if (!this.$modes[\"ace/mode/text\"])\r\n            this.$modes[\"ace/mode/text\"] = new TextMode();\r\n\r\n        if (this.$modes[path] && !options) {\r\n            this.$onChangeMode(this.$modes[path]);\r\n            cb && cb();\r\n            return;\r\n        }\r\n        // load on demand\r\n        this.$modeId = path;\r\n        config.loadModule([\"mode\", path], function(m) {\r\n            if (this.$modeId !== path)\r\n                return cb && cb();\r\n            if (this.$modes[path] && !options) {\r\n                this.$onChangeMode(this.$modes[path]);\r\n            } else if (m && m.Mode) {\r\n                m = new m.Mode(options);\r\n                if (!options) {\r\n                    this.$modes[path] = m;\r\n                    m.$id = path;\r\n                }\r\n                this.$onChangeMode(m);\r\n            }\r\n            cb && cb();\r\n        }.bind(this));\r\n\r\n        // set mode to text until loading is finished\r\n        if (!this.$mode)\r\n            this.$onChangeMode(this.$modes[\"ace/mode/text\"], true);\r\n    };\r\n\r\n    this.$onChangeMode = function(mode, $isPlaceholder) {\r\n        if (!$isPlaceholder)\r\n            this.$modeId = mode.$id;\r\n        if (this.$mode === mode) \r\n            return;\r\n\r\n        this.$mode = mode;\r\n\r\n        this.$stopWorker();\r\n\r\n        if (this.$useWorker)\r\n            this.$startWorker();\r\n\r\n        var tokenizer = mode.getTokenizer();\r\n\r\n        if(tokenizer.addEventListener !== undefined) {\r\n            var onReloadTokenizer = this.onReloadTokenizer.bind(this);\r\n            tokenizer.addEventListener(\"update\", onReloadTokenizer);\r\n        }\r\n\r\n        if (!this.bgTokenizer) {\r\n            this.bgTokenizer = new BackgroundTokenizer(tokenizer);\r\n            var _self = this;\r\n            this.bgTokenizer.addEventListener(\"update\", function(e) {\r\n                _self._signal(\"tokenizerUpdate\", e);\r\n            });\r\n        } else {\r\n            this.bgTokenizer.setTokenizer(tokenizer);\r\n        }\r\n\r\n        this.bgTokenizer.setDocument(this.getDocument());\r\n\r\n        this.tokenRe = mode.tokenRe;\r\n        this.nonTokenRe = mode.nonTokenRe;\r\n\r\n        \r\n        if (!$isPlaceholder) {\r\n            // experimental method, used by c9 findiniles\r\n            if (mode.attachToSession)\r\n                mode.attachToSession(this);\r\n            this.$options.wrapMethod.set.call(this, this.$wrapMethod);\r\n            this.$setFolding(mode.foldingRules);\r\n            this.bgTokenizer.start(0);\r\n            this._emit(\"changeMode\");\r\n        }\r\n    };\r\n\r\n    this.$stopWorker = function() {\r\n        if (this.$worker) {\r\n            this.$worker.terminate();\r\n            this.$worker = null;\r\n        }\r\n    };\r\n\r\n    this.$startWorker = function() {\r\n        try {\r\n            this.$worker = this.$mode.createWorker(this);\r\n        } catch (e) {\r\n            config.warn(\"Could not load worker\", e);\r\n            this.$worker = null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns the current text mode.\r\n     * @returns {TextMode} The current text mode\r\n     **/\r\n    this.getMode = function() {\r\n        return this.$mode;\r\n    };\r\n\r\n    this.$scrollTop = 0;\r\n    /**\r\n     * This function sets the scroll top value. It also emits the `'changeScrollTop'` event.\r\n     * @param {Number} scrollTop The new scroll top value\r\n     *\r\n     **/\r\n    this.setScrollTop = function(scrollTop) {\r\n        // TODO: should we force integer lineheight instead? scrollTop = Math.round(scrollTop); \r\n        if (this.$scrollTop === scrollTop || isNaN(scrollTop))\r\n            return;\r\n\r\n        this.$scrollTop = scrollTop;\r\n        this._signal(\"changeScrollTop\", scrollTop);\r\n    };\r\n\r\n    /**\r\n     * [Returns the value of the distance between the top of the editor and the topmost part of the visible content.]{: #EditSession.getScrollTop}\r\n     * @returns {Number}\r\n     **/\r\n    this.getScrollTop = function() {\r\n        return this.$scrollTop;\r\n    };\r\n\r\n    this.$scrollLeft = 0;\r\n    /**\r\n     * [Sets the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.setScrollLeft}\r\n     **/\r\n    this.setScrollLeft = function(scrollLeft) {\r\n        // scrollLeft = Math.round(scrollLeft);\r\n        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))\r\n            return;\r\n\r\n        this.$scrollLeft = scrollLeft;\r\n        this._signal(\"changeScrollLeft\", scrollLeft);\r\n    };\r\n\r\n    /**\r\n     * [Returns the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.getScrollLeft}\r\n     * @returns {Number}\r\n     **/\r\n    this.getScrollLeft = function() {\r\n        return this.$scrollLeft;\r\n    };\r\n\r\n    /**\r\n     * Returns the width of the screen.\r\n     * @returns {Number}\r\n     **/\r\n    this.getScreenWidth = function() {\r\n        this.$computeWidth();\r\n        if (this.lineWidgets) \r\n            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);\r\n        return this.screenWidth;\r\n    };\r\n    \r\n    this.getLineWidgetMaxWidth = function() {\r\n        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;\r\n        var width = 0;\r\n        this.lineWidgets.forEach(function(w) {\r\n            if (w && w.screenWidth > width)\r\n                width = w.screenWidth;\r\n        });\r\n        return this.lineWidgetWidth = width;\r\n    };\r\n\r\n    this.$computeWidth = function(force) {\r\n        if (this.$modified || force) {\r\n            this.$modified = false;\r\n\r\n            if (this.$useWrapMode)\r\n                return this.screenWidth = this.$wrapLimit;\r\n\r\n            var lines = this.doc.getAllLines();\r\n            var cache = this.$rowLengthCache;\r\n            var longestScreenLine = 0;\r\n            var foldIndex = 0;\r\n            var foldLine = this.$foldData[foldIndex];\r\n            var foldStart = foldLine ? foldLine.start.row : Infinity;\r\n            var len = lines.length;\r\n\r\n            for (var i = 0; i < len; i++) {\r\n                if (i > foldStart) {\r\n                    i = foldLine.end.row + 1;\r\n                    if (i >= len)\r\n                        break;\r\n                    foldLine = this.$foldData[foldIndex++];\r\n                    foldStart = foldLine ? foldLine.start.row : Infinity;\r\n                }\r\n\r\n                if (cache[i] == null)\r\n                    cache[i] = this.$getStringScreenWidth(lines[i])[0];\r\n\r\n                if (cache[i] > longestScreenLine)\r\n                    longestScreenLine = cache[i];\r\n            }\r\n            this.screenWidth = longestScreenLine;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns a verbatim copy of the given line as it is in the document\r\n     * @param {Number} row The row to retrieve from\r\n     *\r\n     * @returns {String}\r\n     **/\r\n    this.getLine = function(row) {\r\n        return this.doc.getLine(row);\r\n    };\r\n\r\n    /**\r\n     * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.\r\n     * @param {Number} firstRow The first row index to retrieve\r\n     * @param {Number} lastRow The final row index to retrieve\r\n     *\r\n     * @returns {[String]}\r\n     *\r\n     **/\r\n    this.getLines = function(firstRow, lastRow) {\r\n        return this.doc.getLines(firstRow, lastRow);\r\n    };\r\n\r\n    /**\r\n     * Returns the number of rows in the document.\r\n     * @returns {Number}\r\n     **/\r\n    this.getLength = function() {\r\n        return this.doc.getLength();\r\n    };\r\n\r\n    /**\r\n     * {:Document.getTextRange.desc}\r\n     * @param {Range} range The range to work with\r\n     *\r\n     * @returns {String}\r\n     **/\r\n    this.getTextRange = function(range) {\r\n        return this.doc.getTextRange(range || this.selection.getRange());\r\n    };\r\n\r\n    /**\r\n     * Inserts a block of `text` and the indicated `position`.\r\n     * @param {Object} position The position {row, column} to start inserting at\r\n     * @param {String} text A chunk of text to insert\r\n     * @returns {Object} The position of the last line of `text`. If the length of `text` is 0, this function simply returns `position`.\r\n     *\r\n     *\r\n     **/\r\n    this.insert = function(position, text) {\r\n        return this.doc.insert(position, text);\r\n    };\r\n\r\n    /**\r\n     * Removes the `range` from the document.\r\n     * @param {Range} range A specified Range to remove\r\n     * @returns {Object} The new `start` property of the range, which contains `startRow` and `startColumn`. If `range` is empty, this function returns the unmodified value of `range.start`.\r\n     *\r\n     * @related Document.remove\r\n     *\r\n     **/\r\n    this.remove = function(range) {\r\n        return this.doc.remove(range);\r\n    };\r\n    \r\n    /**\r\n     * Removes a range of full lines. This method also triggers the `'change'` event.\r\n     * @param {Number} firstRow The first row to be removed\r\n     * @param {Number} lastRow The last row to be removed\r\n     * @returns {[String]} Returns all the removed lines.\r\n     *\r\n     * @related Document.removeFullLines\r\n     *\r\n     **/\r\n    this.removeFullLines = function(firstRow, lastRow){\r\n        return this.doc.removeFullLines(firstRow, lastRow);\r\n    };\r\n\r\n    /**\r\n     * Reverts previous changes to your document.\r\n     * @param {Array} deltas An array of previous changes\r\n     * @param {Boolean} dontSelect [If `true`, doesn't select the range of where the change occured]{: #dontSelect}\r\n     *\r\n     * @returns {Range}\r\n     **/\r\n    this.undoChanges = function(deltas, dontSelect) {\r\n        if (!deltas.length)\r\n            return;\r\n\r\n        this.$fromUndo = true;\r\n        for (var i = deltas.length - 1; i != -1; i--) {\r\n            var delta = deltas[i];\r\n            if (delta.action == \"insert\" || delta.action == \"remove\") {\r\n                this.doc.revertDelta(delta);\r\n            } else if (delta.folds) {\r\n                this.addFolds(delta.folds);\r\n            }\r\n        }\r\n        if (!dontSelect && this.$undoSelect) {\r\n            if (deltas.selectionBefore)\r\n                this.selection.fromJSON(deltas.selectionBefore);\r\n            else\r\n                this.selection.setRange(this.$getUndoSelection(deltas, true));\r\n        }\r\n        this.$fromUndo = false;\r\n    };\r\n\r\n    /**\r\n     * Re-implements a previously undone change to your document.\r\n     * @param {Array} deltas An array of previous changes\r\n     * @param {Boolean} dontSelect {:dontSelect}\r\n     *\r\n     * @returns {Range}\r\n     **/\r\n    this.redoChanges = function(deltas, dontSelect) {\r\n        if (!deltas.length)\r\n            return;\r\n\r\n        this.$fromUndo = true;\r\n        for (var i = 0; i < deltas.length; i++) {\r\n            var delta = deltas[i];\r\n            if (delta.action == \"insert\" || delta.action == \"remove\") {\r\n                this.doc.applyDelta(delta);\r\n            }\r\n        }\r\n\r\n        if (!dontSelect && this.$undoSelect) {\r\n            if (deltas.selectionAfter)\r\n                this.selection.fromJSON(deltas.selectionAfter);\r\n            else\r\n                this.selection.setRange(this.$getUndoSelection(deltas, false));\r\n        }\r\n        this.$fromUndo = false;\r\n    };\r\n\r\n    /**\r\n     * Enables or disables highlighting of the range where an undo occurred.\r\n     * @param {Boolean} enable If `true`, selects the range of the reinserted change\r\n     *      \r\n     **/\r\n    this.setUndoSelect = function(enable) {\r\n        this.$undoSelect = enable;\r\n    };\r\n\r\n    this.$getUndoSelection = function(deltas, isUndo) {\r\n        function isInsert(delta) {\r\n            return isUndo ? delta.action !== \"insert\" : delta.action === \"insert\";\r\n        }\r\n\r\n        var range, point;\r\n        var lastDeltaIsInsert;\r\n\r\n        for (var i = 0; i < deltas.length; i++) {\r\n            var delta = deltas[i];\r\n            if (!delta.start) continue; // skip folds\r\n            if (!range) {\r\n                if (isInsert(delta)) {\r\n                    range = Range.fromPoints(delta.start, delta.end);\r\n                    lastDeltaIsInsert = true;\r\n                } else {\r\n                    range = Range.fromPoints(delta.start, delta.start);\r\n                    lastDeltaIsInsert = false;\r\n                }\r\n                continue;\r\n            }\r\n            \r\n            if (isInsert(delta)) {\r\n                point = delta.start;\r\n                if (range.compare(point.row, point.column) == -1) {\r\n                    range.setStart(point);\r\n                }\r\n                point = delta.end;\r\n                if (range.compare(point.row, point.column) == 1) {\r\n                    range.setEnd(point);\r\n                }\r\n                lastDeltaIsInsert = true;\r\n            } else {\r\n                point = delta.start;\r\n                if (range.compare(point.row, point.column) == -1) {\r\n                    range = Range.fromPoints(delta.start, delta.start);\r\n                }\r\n                lastDeltaIsInsert = false;\r\n            }\r\n        }\r\n        return range;\r\n    };\r\n\r\n    /**\r\n     * Replaces a range in the document with the new `text`.\r\n     *\r\n     * @param {Range} range A specified Range to replace\r\n     * @param {String} text The new text to use as a replacement\r\n     * @returns {Object} An object containing the final row and column, like this:\r\n     * ```\r\n     * {row: endRow, column: 0}\r\n     * ```\r\n     * If the text and range are empty, this function returns an object containing the current `range.start` value.\r\n     * If the text is the exact same as what currently exists, this function returns an object containing the current `range.end` value.\r\n     *\r\n     * @related Document.replace\r\n     **/\r\n    this.replace = function(range, text) {\r\n        return this.doc.replace(range, text);\r\n    };\r\n\r\n    /**\r\n     * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:\r\n     *  ```json\r\n     *    { row: newRowLocation, column: newColumnLocation }\r\n     *  ```\r\n     * @param {Range} fromRange The range of text you want moved within the document\r\n     * @param {Object} toPosition The location (row and column) where you want to move the text to\r\n     * @returns {Range} The new range where the text was moved to.\r\n     **/\r\n    this.moveText = function(fromRange, toPosition, copy) {\r\n        var text = this.getTextRange(fromRange);\r\n        var folds = this.getFoldsInRange(fromRange);\r\n\r\n        var toRange = Range.fromPoints(toPosition, toPosition);\r\n        if (!copy) {\r\n            this.remove(fromRange);\r\n            var rowDiff = fromRange.start.row - fromRange.end.row;\r\n            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;\r\n            if (collDiff) {\r\n                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)\r\n                    toRange.start.column += collDiff;\r\n                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)\r\n                    toRange.end.column += collDiff;\r\n            }\r\n            if (rowDiff && toRange.start.row >= fromRange.end.row) {\r\n                toRange.start.row += rowDiff;\r\n                toRange.end.row += rowDiff;\r\n            }\r\n        }\r\n\r\n        toRange.end = this.insert(toRange.start, text);\r\n        if (folds.length) {\r\n            var oldStart = fromRange.start;\r\n            var newStart = toRange.start;\r\n            var rowDiff = newStart.row - oldStart.row;\r\n            var collDiff = newStart.column - oldStart.column;\r\n            this.addFolds(folds.map(function(x) {\r\n                x = x.clone();\r\n                if (x.start.row == oldStart.row)\r\n                    x.start.column += collDiff;\r\n                if (x.end.row == oldStart.row)\r\n                    x.end.column += collDiff;\r\n                x.start.row += rowDiff;\r\n                x.end.row += rowDiff;\r\n                return x;\r\n            }));\r\n        }\r\n\r\n        return toRange;\r\n    };\r\n\r\n    /**\r\n     * Indents all the rows, from `startRow` to `endRow` (inclusive), by prefixing each row with the token in `indentString`.\r\n     *\r\n     * If `indentString` contains the `'\\t'` character, it's replaced by whatever is defined by [[EditSession.getTabString `getTabString()`]].\r\n     * @param {Number} startRow Starting row\r\n     * @param {Number} endRow Ending row\r\n     * @param {String} indentString The indent token\r\n     *\r\n     *\r\n     **/\r\n    this.indentRows = function(startRow, endRow, indentString) {\r\n        indentString = indentString.replace(/\\t/g, this.getTabString());\r\n        for (var row=startRow; row<=endRow; row++)\r\n            this.doc.insertInLine({row: row, column: 0}, indentString);\r\n    };\r\n\r\n    /**\r\n     * Outdents all the rows defined by the `start` and `end` properties of `range`.\r\n     * @param {Range} range A range of rows\r\n     *\r\n     **/\r\n    this.outdentRows = function (range) {\r\n        var rowRange = range.collapseRows();\r\n        var deleteRange = new Range(0, 0, 0, 0);\r\n        var size = this.getTabSize();\r\n\r\n        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {\r\n            var line = this.getLine(i);\r\n\r\n            deleteRange.start.row = i;\r\n            deleteRange.end.row = i;\r\n            for (var j = 0; j < size; ++j)\r\n                if (line.charAt(j) != ' ')\r\n                    break;\r\n            if (j < size && line.charAt(j) == '\\t') {\r\n                deleteRange.start.column = j;\r\n                deleteRange.end.column = j + 1;\r\n            } else {\r\n                deleteRange.start.column = 0;\r\n                deleteRange.end.column = j;\r\n            }\r\n            this.remove(deleteRange);\r\n        }\r\n    };\r\n\r\n    this.$moveLines = function(firstRow, lastRow, dir) {\r\n        firstRow = this.getRowFoldStart(firstRow);\r\n        lastRow = this.getRowFoldEnd(lastRow);\r\n        if (dir < 0) {\r\n            var row = this.getRowFoldStart(firstRow + dir);\r\n            if (row < 0) return 0;\r\n            var diff = row-firstRow;\r\n        } else if (dir > 0) {\r\n            var row = this.getRowFoldEnd(lastRow + dir);\r\n            if (row > this.doc.getLength()-1) return 0;\r\n            var diff = row-lastRow;\r\n        } else {\r\n            firstRow = this.$clipRowToDocument(firstRow);\r\n            lastRow = this.$clipRowToDocument(lastRow);\r\n            var diff = lastRow - firstRow + 1;\r\n        }\r\n\r\n        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);\r\n        var folds = this.getFoldsInRange(range).map(function(x){\r\n            x = x.clone();\r\n            x.start.row += diff;\r\n            x.end.row += diff;\r\n            return x;\r\n        });\r\n        \r\n        var lines = dir == 0\r\n            ? this.doc.getLines(firstRow, lastRow)\r\n            : this.doc.removeFullLines(firstRow, lastRow);\r\n        this.doc.insertFullLines(firstRow+diff, lines);\r\n        folds.length && this.addFolds(folds);\r\n        return diff;\r\n    };\r\n    /**\r\n     * Shifts all the lines in the document up one, starting from `firstRow` and ending at `lastRow`.\r\n     * @param {Number} firstRow The starting row to move up\r\n     * @param {Number} lastRow The final row to move up\r\n     * @returns {Number} If `firstRow` is less-than or equal to 0, this function returns 0. Otherwise, on success, it returns -1.\r\n     *\r\n     **/\r\n    this.moveLinesUp = function(firstRow, lastRow) {\r\n        return this.$moveLines(firstRow, lastRow, -1);\r\n    };\r\n\r\n    /**\r\n     * Shifts all the lines in the document down one, starting from `firstRow` and ending at `lastRow`.\r\n     * @param {Number} firstRow The starting row to move down\r\n     * @param {Number} lastRow The final row to move down\r\n     * @returns {Number} If `firstRow` is less-than or equal to 0, this function returns 0. Otherwise, on success, it returns -1.\r\n     **/\r\n    this.moveLinesDown = function(firstRow, lastRow) {\r\n        return this.$moveLines(firstRow, lastRow, 1);\r\n    };\r\n\r\n    /**\r\n     * Duplicates all the text between `firstRow` and `lastRow`.\r\n     * @param {Number} firstRow The starting row to duplicate\r\n     * @param {Number} lastRow The final row to duplicate\r\n     * @returns {Number} Returns the number of new rows added; in other words, `lastRow - firstRow + 1`.\r\n     *\r\n     *\r\n     **/\r\n    this.duplicateLines = function(firstRow, lastRow) {\r\n        return this.$moveLines(firstRow, lastRow, 0);\r\n    };\r\n\r\n\r\n    this.$clipRowToDocument = function(row) {\r\n        return Math.max(0, Math.min(row, this.doc.getLength()-1));\r\n    };\r\n\r\n    this.$clipColumnToRow = function(row, column) {\r\n        if (column < 0)\r\n            return 0;\r\n        return Math.min(this.doc.getLine(row).length, column);\r\n    };\r\n\r\n\r\n    this.$clipPositionToDocument = function(row, column) {\r\n        column = Math.max(0, column);\r\n\r\n        if (row < 0) {\r\n            row = 0;\r\n            column = 0;\r\n        } else {\r\n            var len = this.doc.getLength();\r\n            if (row >= len) {\r\n                row = len - 1;\r\n                column = this.doc.getLine(len-1).length;\r\n            } else {\r\n                column = Math.min(this.doc.getLine(row).length, column);\r\n            }\r\n        }\r\n\r\n        return {\r\n            row: row,\r\n            column: column\r\n        };\r\n    };\r\n\r\n    this.$clipRangeToDocument = function(range) {\r\n        if (range.start.row < 0) {\r\n            range.start.row = 0;\r\n            range.start.column = 0;\r\n        } else {\r\n            range.start.column = this.$clipColumnToRow(\r\n                range.start.row,\r\n                range.start.column\r\n            );\r\n        }\r\n\r\n        var len = this.doc.getLength() - 1;\r\n        if (range.end.row > len) {\r\n            range.end.row = len;\r\n            range.end.column = this.doc.getLine(len).length;\r\n        } else {\r\n            range.end.column = this.$clipColumnToRow(\r\n                range.end.row,\r\n                range.end.column\r\n            );\r\n        }\r\n        return range;\r\n    };\r\n\r\n    // WRAPMODE\r\n    this.$wrapLimit = 80;\r\n    this.$useWrapMode = false;\r\n    this.$wrapLimitRange = {\r\n        min : null,\r\n        max : null\r\n    };\r\n\r\n    /**\r\n     * Sets whether or not line wrapping is enabled. If `useWrapMode` is different than the current value, the `'changeWrapMode'` event is emitted.\r\n     * @param {Boolean} useWrapMode Enable (or disable) wrap mode\r\n     *\r\n     **/\r\n    this.setUseWrapMode = function(useWrapMode) {\r\n        if (useWrapMode != this.$useWrapMode) {\r\n            this.$useWrapMode = useWrapMode;\r\n            this.$modified = true;\r\n            this.$resetRowCache(0);\r\n\r\n            // If wrapMode is activaed, the wrapData array has to be initialized.\r\n            if (useWrapMode) {\r\n                var len = this.getLength();\r\n                this.$wrapData = Array(len);\r\n                this.$updateWrapData(0, len - 1);\r\n            }\r\n\r\n            this._signal(\"changeWrapMode\");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if wrap mode is being used; `false` otherwise.\r\n     * @returns {Boolean}\r\n     **/\r\n    this.getUseWrapMode = function() {\r\n        return this.$useWrapMode;\r\n    };\r\n\r\n    // Allow the wrap limit to move freely between min and max. Either\r\n    // parameter can be null to allow the wrap limit to be unconstrained\r\n    // in that direction. Or set both parameters to the same number to pin\r\n    // the limit to that value.\r\n    /**\r\n     * Sets the boundaries of wrap. Either value can be `null` to have an unconstrained wrap, or, they can be the same number to pin the limit. If the wrap limits for `min` or `max` are different, this method also emits the `'changeWrapMode'` event.\r\n     * @param {Number} min The minimum wrap value (the left side wrap)\r\n     * @param {Number} max The maximum wrap value (the right side wrap)\r\n     *\r\n     **/\r\n    this.setWrapLimitRange = function(min, max) {\r\n        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {\r\n            this.$wrapLimitRange = { min: min, max: max };\r\n            this.$modified = true;\r\n            this.$bidiHandler.markAsDirty();\r\n\r\n            // This will force a recalculation of the wrap limit\r\n            if (this.$useWrapMode)\r\n                this._signal(\"changeWrapMode\");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This should generally only be called by the renderer when a resize is detected.\r\n     * @param {Number} desiredLimit The new wrap limit\r\n     * @returns {Boolean}\r\n     *\r\n     * @private\r\n     **/\r\n    this.adjustWrapLimit = function(desiredLimit, $printMargin) {\r\n        var limits = this.$wrapLimitRange;\r\n        if (limits.max < 0)\r\n            limits = {min: $printMargin, max: $printMargin};\r\n        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);\r\n        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {\r\n            this.$wrapLimit = wrapLimit;\r\n            this.$modified = true;\r\n            if (this.$useWrapMode) {\r\n                this.$updateWrapData(0, this.getLength() - 1);\r\n                this.$resetRowCache(0);\r\n                this._signal(\"changeWrapLimit\");\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    this.$constrainWrapLimit = function(wrapLimit, min, max) {\r\n        if (min)\r\n            wrapLimit = Math.max(min, wrapLimit);\r\n\r\n        if (max)\r\n            wrapLimit = Math.min(max, wrapLimit);\r\n\r\n        return wrapLimit;\r\n    };\r\n\r\n    /**\r\n     * Returns the value of wrap limit.\r\n     * @returns {Number} The wrap limit.\r\n     **/\r\n    this.getWrapLimit = function() {\r\n        return this.$wrapLimit;\r\n    };\r\n    \r\n    /**\r\n     * Sets the line length for soft wrap in the editor. Lines will break\r\n     *  at a minimum of the given length minus 20 chars and at a maximum\r\n     *  of the given number of chars.\r\n     * @param {number} limit The maximum line length in chars, for soft wrapping lines.\r\n     */\r\n    this.setWrapLimit = function (limit) {\r\n        this.setWrapLimitRange(limit, limit);\r\n    };\r\n    \r\n    /**\r\n     * Returns an object that defines the minimum and maximum of the wrap limit; it looks something like this:\r\n     *\r\n     *     { min: wrapLimitRange_min, max: wrapLimitRange_max }\r\n     *\r\n     * @returns {Object}\r\n     **/\r\n    this.getWrapLimitRange = function() {\r\n        // Avoid unexpected mutation by returning a copy\r\n        return {\r\n            min : this.$wrapLimitRange.min,\r\n            max : this.$wrapLimitRange.max\r\n        };\r\n    };\r\n\r\n    this.$updateInternalDataOnChange = function(delta) {\r\n        var useWrapMode = this.$useWrapMode;\r\n        var action = delta.action;\r\n        var start = delta.start;\r\n        var end = delta.end;\r\n        var firstRow = start.row;\r\n        var lastRow = end.row;\r\n        var len = lastRow - firstRow;\r\n        var removedFolds = null;\r\n        \r\n        this.$updating = true;\r\n        if (len != 0) {\r\n            if (action === \"remove\") {\r\n                this[useWrapMode ? \"$wrapData\" : \"$rowLengthCache\"].splice(firstRow, len);\r\n\r\n                var foldLines = this.$foldData;\r\n                removedFolds = this.getFoldsInRange(delta);\r\n                this.removeFolds(removedFolds);\r\n\r\n                var foldLine = this.getFoldLine(end.row);\r\n                var idx = 0;\r\n                if (foldLine) {\r\n                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);\r\n                    foldLine.shiftRow(-len);\r\n\r\n                    var foldLineBefore = this.getFoldLine(firstRow);\r\n                    if (foldLineBefore && foldLineBefore !== foldLine) {\r\n                        foldLineBefore.merge(foldLine);\r\n                        foldLine = foldLineBefore;\r\n                    }\r\n                    idx = foldLines.indexOf(foldLine) + 1;\r\n                }\r\n\r\n                for (idx; idx < foldLines.length; idx++) {\r\n                    var foldLine = foldLines[idx];\r\n                    if (foldLine.start.row >= end.row) {\r\n                        foldLine.shiftRow(-len);\r\n                    }\r\n                }\r\n\r\n                lastRow = firstRow;\r\n            } else {\r\n                var args = Array(len);\r\n                args.unshift(firstRow, 0);\r\n                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;\r\n                arr.splice.apply(arr, args);\r\n\r\n                // If some new line is added inside of a foldLine, then split\r\n                // the fold line up.\r\n                var foldLines = this.$foldData;\r\n                var foldLine = this.getFoldLine(firstRow);\r\n                var idx = 0;\r\n                if (foldLine) {\r\n                    var cmp = foldLine.range.compareInside(start.row, start.column);\r\n                    // Inside of the foldLine range. Need to split stuff up.\r\n                    if (cmp == 0) {\r\n                        foldLine = foldLine.split(start.row, start.column);\r\n                        if (foldLine) {\r\n                            foldLine.shiftRow(len);\r\n                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);\r\n                        }\r\n                    } else\r\n                    // Infront of the foldLine but same row. Need to shift column.\r\n                    if (cmp == -1) {\r\n                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);\r\n                        foldLine.shiftRow(len);\r\n                    }\r\n                    // Nothing to do if the insert is after the foldLine.\r\n                    idx = foldLines.indexOf(foldLine) + 1;\r\n                }\r\n\r\n                for (idx; idx < foldLines.length; idx++) {\r\n                    var foldLine = foldLines[idx];\r\n                    if (foldLine.start.row >= firstRow) {\r\n                        foldLine.shiftRow(len);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            // Realign folds. E.g. if you add some new chars before a fold, the\r\n            // fold should \"move\" to the right.\r\n            len = Math.abs(delta.start.column - delta.end.column);\r\n            if (action === \"remove\") {\r\n                // Get all the folds in the change range and remove them.\r\n                removedFolds = this.getFoldsInRange(delta);\r\n                this.removeFolds(removedFolds);\r\n\r\n                len = -len;\r\n            }\r\n            var foldLine = this.getFoldLine(firstRow);\r\n            if (foldLine) {\r\n                foldLine.addRemoveChars(firstRow, start.column, len);\r\n            }\r\n        }\r\n\r\n        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {\r\n            console.error(\"doc.getLength() and $wrapData.length have to be the same!\");\r\n        }\r\n        this.$updating = false;\r\n\r\n        if (useWrapMode)\r\n            this.$updateWrapData(firstRow, lastRow);\r\n        else\r\n            this.$updateRowLengthCache(firstRow, lastRow);\r\n\r\n        return removedFolds;\r\n    };\r\n\r\n    this.$updateRowLengthCache = function(firstRow, lastRow, b) {\r\n        this.$rowLengthCache[firstRow] = null;\r\n        this.$rowLengthCache[lastRow] = null;\r\n    };\r\n\r\n    this.$updateWrapData = function(firstRow, lastRow) {\r\n        var lines = this.doc.getAllLines();\r\n        var tabSize = this.getTabSize();\r\n        var wrapData = this.$wrapData;\r\n        var wrapLimit = this.$wrapLimit;\r\n        var tokens;\r\n        var foldLine;\r\n\r\n        var row = firstRow;\r\n        lastRow = Math.min(lastRow, lines.length - 1);\r\n        while (row <= lastRow) {\r\n            foldLine = this.getFoldLine(row, foldLine);\r\n            if (!foldLine) {\r\n                tokens = this.$getDisplayTokens(lines[row]);\r\n                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);\r\n                row ++;\r\n            } else {\r\n                tokens = [];\r\n                foldLine.walk(function(placeholder, row, column, lastColumn) {\r\n                        var walkTokens;\r\n                        if (placeholder != null) {\r\n                            walkTokens = this.$getDisplayTokens(\r\n                                            placeholder, tokens.length);\r\n                            walkTokens[0] = PLACEHOLDER_START;\r\n                            for (var i = 1; i < walkTokens.length; i++) {\r\n                                walkTokens[i] = PLACEHOLDER_BODY;\r\n                            }\r\n                        } else {\r\n                            walkTokens = this.$getDisplayTokens(\r\n                                lines[row].substring(lastColumn, column),\r\n                                tokens.length);\r\n                        }\r\n                        tokens = tokens.concat(walkTokens);\r\n                    }.bind(this),\r\n                    foldLine.end.row,\r\n                    lines[foldLine.end.row].length + 1\r\n                );\r\n\r\n                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);\r\n                row = foldLine.end.row + 1;\r\n            }\r\n        }\r\n    };\r\n\r\n    // \"Tokens\"\r\n    var CHAR = 1,\r\n        CHAR_EXT = 2,\r\n        PLACEHOLDER_START = 3,\r\n        PLACEHOLDER_BODY =  4,\r\n        PUNCTUATION = 9,\r\n        SPACE = 10,\r\n        TAB = 11,\r\n        TAB_SPACE = 12;\r\n\r\n\r\n    this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {\r\n        if (tokens.length == 0) {\r\n            return [];\r\n        }\r\n\r\n        var splits = [];\r\n        var displayLength = tokens.length;\r\n        var lastSplit = 0, lastDocSplit = 0;\r\n\r\n        var isCode = this.$wrapAsCode;\r\n\r\n        var indentedSoftWrap = this.$indentedSoftWrap;\r\n        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)\r\n            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);\r\n\r\n        function getWrapIndent() {\r\n            var indentation = 0;\r\n            if (maxIndent === 0)\r\n                return indentation;\r\n            if (indentedSoftWrap) {\r\n                for (var i = 0; i < tokens.length; i++) {\r\n                    var token = tokens[i];\r\n                    if (token == SPACE)\r\n                        indentation += 1;\r\n                    else if (token == TAB)\r\n                        indentation += tabSize;\r\n                    else if (token == TAB_SPACE)\r\n                        continue;\r\n                    else\r\n                        break;\r\n                }\r\n            }\r\n            if (isCode && indentedSoftWrap !== false)\r\n                indentation += tabSize;\r\n            return Math.min(indentation, maxIndent);\r\n        }\r\n        function addSplit(screenPos) {\r\n            // The document size is the current size - the extra width for tabs\r\n            // and multipleWidth characters.\r\n            var len = screenPos - lastSplit;\r\n            for (var i = lastSplit; i < screenPos; i++) {\r\n                var ch = tokens[i];\r\n                if (ch === 12 || ch === 2) len -= 1;\r\n            }\r\n\r\n            if (!splits.length) {\r\n                indent = getWrapIndent();\r\n                splits.indent = indent;\r\n            }\r\n            lastDocSplit += len;\r\n            splits.push(lastDocSplit);\r\n            lastSplit = screenPos;\r\n        }\r\n        var indent = 0;\r\n        while (displayLength - lastSplit > wrapLimit - indent) {\r\n            // This is, where the split should be.\r\n            var split = lastSplit + wrapLimit - indent;\r\n\r\n            // If there is a space or tab at this split position, then making\r\n            // a split is simple.\r\n            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {\r\n                /* disabled see https://github.com/ajaxorg/ace/issues/1186\r\n                // Include all following spaces + tabs in this split as well.\r\n                while (tokens[split] >= SPACE) {\r\n                    split ++;\r\n                } */\r\n                addSplit(split);\r\n                continue;\r\n            }\r\n\r\n            // === ELSE ===\r\n            // Check if split is inside of a placeholder. Placeholder are\r\n            // not splitable. Therefore, seek the beginning of the placeholder\r\n            // and try to place the split before the placeholder's start.\r\n            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {\r\n                // Seek the start of the placeholder and do the split\r\n                // before the placeholder. By definition there always\r\n                // a PLACEHOLDER_START between split and lastSplit.\r\n                for (split; split != lastSplit - 1; split--) {\r\n                    if (tokens[split] == PLACEHOLDER_START) {\r\n                        // split++; << No incremental here as we want to\r\n                        //  have the position before the Placeholder.\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // If the PLACEHOLDER_START is not the index of the\r\n                // last split, then we can do the split\r\n                if (split > lastSplit) {\r\n                    addSplit(split);\r\n                    continue;\r\n                }\r\n\r\n                // If the PLACEHOLDER_START IS the index of the last\r\n                // split, then we have to place the split after the\r\n                // placeholder. So, let's seek for the end of the placeholder.\r\n                split = lastSplit + wrapLimit;\r\n                for (split; split < tokens.length; split++) {\r\n                    if (tokens[split] != PLACEHOLDER_BODY) {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // If spilt == tokens.length, then the placeholder is the last\r\n                // thing in the line and adding a new split doesn't make sense.\r\n                if (split == tokens.length) {\r\n                    break;  // Breaks the while-loop.\r\n                }\r\n\r\n                // Finally, add the split...\r\n                addSplit(split);\r\n                continue;\r\n            }\r\n\r\n            // === ELSE ===\r\n            // Search for the first non space/tab/placeholder/punctuation token backwards.\r\n            var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);\r\n            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {\r\n                split --;\r\n            }\r\n            if (isCode) {\r\n                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {\r\n                    split --;\r\n                }\r\n                while (split > minSplit && tokens[split] == PUNCTUATION) {\r\n                    split --;\r\n                }\r\n            } else {\r\n                while (split > minSplit && tokens[split] < SPACE) {\r\n                    split --;\r\n                }\r\n            }\r\n            // If we found one, then add the split.\r\n            if (split > minSplit) {\r\n                addSplit(++split);\r\n                continue;\r\n            }\r\n\r\n            // === ELSE ===\r\n            split = lastSplit + wrapLimit;\r\n            // The split is inside of a CHAR or CHAR_EXT token and no space\r\n            // around -> force a split.\r\n            if (tokens[split] == CHAR_EXT)\r\n                split--;\r\n            addSplit(split - indent);\r\n        }\r\n        return splits;\r\n    };\r\n\r\n    /**\r\n     * Given a string, returns an array of the display characters, including tabs and spaces.\r\n     * @param {String} str The string to check\r\n     * @param {Number} offset The value to start at\r\n     *\r\n     **/\r\n    this.$getDisplayTokens = function(str, offset) {\r\n        var arr = [];\r\n        var tabSize;\r\n        offset = offset || 0;\r\n\r\n        for (var i = 0; i < str.length; i++) {\r\n            var c = str.charCodeAt(i);\r\n            // Tab\r\n            if (c == 9) {\r\n                tabSize = this.getScreenTabSize(arr.length + offset);\r\n                arr.push(TAB);\r\n                for (var n = 1; n < tabSize; n++) {\r\n                    arr.push(TAB_SPACE);\r\n                }\r\n            }\r\n            // Space\r\n            else if (c == 32) {\r\n                arr.push(SPACE);\r\n            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {\r\n                arr.push(PUNCTUATION);\r\n            }\r\n            // full width characters\r\n            else if (c >= 0x1100 && isFullWidth(c)) {\r\n                arr.push(CHAR, CHAR_EXT);\r\n            } else {\r\n                arr.push(CHAR);\r\n            }\r\n        }\r\n        return arr;\r\n    };\r\n\r\n    /**\r\n     * Calculates the width of the string `str` on the screen while assuming that the string starts at the first column on the screen.\r\n     * @param {String} str The string to calculate the screen width of\r\n     * @param {Number} maxScreenColumn\r\n     * @param {Number} screenColumn\r\n     * @returns {[Number]} Returns an `int[]` array with two elements:<br/>\r\n     * The first position indicates the number of columns for `str` on screen.<br/>\r\n     * The second value contains the position of the document column that this function read until.\r\n     *\r\n     **/\r\n    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {\r\n        if (maxScreenColumn == 0)\r\n            return [0, 0];\r\n        if (maxScreenColumn == null)\r\n            maxScreenColumn = Infinity;\r\n        screenColumn = screenColumn || 0;\r\n\r\n        var c, column;\r\n        for (column = 0; column < str.length; column++) {\r\n            c = str.charCodeAt(column);\r\n            // tab\r\n            if (c == 9) {\r\n                screenColumn += this.getScreenTabSize(screenColumn);\r\n            }\r\n            // full width characters\r\n            else if (c >= 0x1100 && isFullWidth(c)) {\r\n                screenColumn += 2;\r\n            } else {\r\n                screenColumn += 1;\r\n            }\r\n            if (screenColumn > maxScreenColumn) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return [screenColumn, column];\r\n    };\r\n\r\n    this.lineWidgets = null;\r\n    /**\r\n     * Returns number of screenrows in a wrapped line.\r\n     * @param {Number} row The row number to check\r\n     *\r\n     * @returns {Number}\r\n     **/\r\n    this.getRowLength = function(row) {\r\n        if (this.lineWidgets)\r\n            var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;\r\n        else \r\n            h = 0;\r\n        if (!this.$useWrapMode || !this.$wrapData[row]) {\r\n            return 1 + h;\r\n        } else {\r\n            return this.$wrapData[row].length + 1 + h;\r\n        }\r\n    };\r\n    this.getRowLineCount = function(row) {\r\n        if (!this.$useWrapMode || !this.$wrapData[row]) {\r\n            return 1;\r\n        } else {\r\n            return this.$wrapData[row].length + 1;\r\n        }\r\n    };\r\n\r\n    this.getRowWrapIndent = function(screenRow) {\r\n        if (this.$useWrapMode) {\r\n            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);\r\n            var splits = this.$wrapData[pos.row];\r\n            return splits.length && splits[0] < pos.column ? splits.indent : 0;\r\n        } else {\r\n            return 0;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns the position (on screen) for the last character in the provided screen row.\r\n     * @param {Number} screenRow The screen row to check\r\n     * @returns {Number}\r\n     *\r\n     * @related EditSession.documentToScreenColumn\r\n     **/\r\n    this.getScreenLastRowColumn = function(screenRow) {\r\n        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);\r\n        return this.documentToScreenColumn(pos.row, pos.column);\r\n    };\r\n\r\n    /**\r\n     * For the given document row and column, this returns the column position of the last screen row.\r\n     * @param {Number} docRow\r\n     *\r\n     * @param {Number} docColumn\r\n     **/\r\n    this.getDocumentLastRowColumn = function(docRow, docColumn) {\r\n        var screenRow = this.documentToScreenRow(docRow, docColumn);\r\n        return this.getScreenLastRowColumn(screenRow);\r\n    };\r\n\r\n    /**\r\n     * For the given document row and column, this returns the document position of the last row.\r\n     * @param {Number} docRow\r\n     * @param {Number} docColumn\r\n     *\r\n     **/\r\n    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {\r\n        var screenRow = this.documentToScreenRow(docRow, docColumn);\r\n        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);\r\n    };\r\n\r\n    /**\r\n     * For the given row, this returns the split data.\r\n     * @returns {String}\r\n     **/\r\n    this.getRowSplitData = function(row) {\r\n        if (!this.$useWrapMode) {\r\n            return undefined;\r\n        } else {\r\n            return this.$wrapData[row];\r\n        }\r\n    };\r\n\r\n    /**\r\n     * The distance to the next tab stop at the specified screen column.\r\n     * @param {Number} screenColumn The screen column to check\r\n     *\r\n     * @returns {Number}\r\n     **/\r\n    this.getScreenTabSize = function(screenColumn) {\r\n        return this.$tabSize - screenColumn % this.$tabSize;\r\n    };\r\n\r\n\r\n    this.screenToDocumentRow = function(screenRow, screenColumn) {\r\n        return this.screenToDocumentPosition(screenRow, screenColumn).row;\r\n    };\r\n\r\n\r\n    this.screenToDocumentColumn = function(screenRow, screenColumn) {\r\n        return this.screenToDocumentPosition(screenRow, screenColumn).column;\r\n    };\r\n\r\n    /**\r\n     * Converts characters coordinates on the screen to characters coordinates within the document. [This takes into account code folding, word wrap, tab size, and any other visual modifications.]{: #conversionConsiderations}\r\n     * @param {Number} screenRow The screen row to check\r\n     * @param {Number} screenColumn The screen column to check\r\n     * @param {int} screen character x-offset [optional]\r\n     *\r\n     * @returns {Object} The object returned has two properties: `row` and `column`.\r\n     *\r\n     * @related EditSession.documentToScreenPosition\r\n     **/\r\n    this.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {\r\n        if (screenRow < 0)\r\n            return {row: 0, column: 0};\r\n\r\n        var line;\r\n        var docRow = 0;\r\n        var docColumn = 0;\r\n        var column;\r\n        var row = 0;\r\n        var rowLength = 0;\r\n\r\n        var rowCache = this.$screenRowCache;\r\n        var i = this.$getRowCacheIndex(rowCache, screenRow);\r\n        var l = rowCache.length;\r\n        if (l && i >= 0) {\r\n            var row = rowCache[i];\r\n            var docRow = this.$docRowCache[i];\r\n            var doCache = screenRow > rowCache[l - 1];\r\n        } else {\r\n            var doCache = !l;\r\n        }\r\n\r\n        var maxRow = this.getLength() - 1;\r\n        var foldLine = this.getNextFoldLine(docRow);\r\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\r\n\r\n        while (row <= screenRow) {\r\n            rowLength = this.getRowLength(docRow);\r\n            if (row + rowLength > screenRow || docRow >= maxRow) {\r\n                break;\r\n            } else {\r\n                row += rowLength;\r\n                docRow++;\r\n                if (docRow > foldStart) {\r\n                    docRow = foldLine.end.row+1;\r\n                    foldLine = this.getNextFoldLine(docRow, foldLine);\r\n                    foldStart = foldLine ? foldLine.start.row : Infinity;\r\n                }\r\n            }\r\n\r\n            if (doCache) {\r\n                this.$docRowCache.push(docRow);\r\n                this.$screenRowCache.push(row);\r\n            }\r\n        }\r\n\r\n        if (foldLine && foldLine.start.row <= docRow) {\r\n            line = this.getFoldDisplayLine(foldLine);\r\n            docRow = foldLine.start.row;\r\n        } else if (row + rowLength <= screenRow || docRow > maxRow) {\r\n            // clip at the end of the document\r\n            return {\r\n                row: maxRow,\r\n                column: this.getLine(maxRow).length\r\n            };\r\n        } else {\r\n            line = this.getLine(docRow);\r\n            foldLine = null;\r\n        }\r\n        var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);\r\n        if (this.$useWrapMode) {\r\n            var splits = this.$wrapData[docRow];\r\n            if (splits) {\r\n                column = splits[splitIndex];\r\n                if(splitIndex > 0 && splits.length) {\r\n                    wrapIndent = splits.indent;\r\n                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];\r\n                    line = line.substring(docColumn);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))\r\n            screenColumn = this.$bidiHandler.offsetToCol(offsetX);\r\n\r\n        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];\r\n\r\n        // We remove one character at the end so that the docColumn\r\n        // position returned is not associated to the next row on the screen.\r\n        if (this.$useWrapMode && docColumn >= column)\r\n            docColumn = column - 1;\r\n\r\n        if (foldLine)\r\n            return foldLine.idxToPosition(docColumn);\r\n\r\n        return {row: docRow, column: docColumn};\r\n    };\r\n\r\n    /**\r\n     * Converts document coordinates to screen coordinates. {:conversionConsiderations}\r\n     * @param {Number} docRow The document row to check\r\n     * @param {Number} docColumn The document column to check\r\n     * @returns {Object} The object returned by this method has two properties: `row` and `column`.\r\n     *\r\n     * @related EditSession.screenToDocumentPosition\r\n     **/\r\n    this.documentToScreenPosition = function(docRow, docColumn) {\r\n        // Normalize the passed in arguments.\r\n        if (typeof docColumn === \"undefined\")\r\n            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);\r\n        else\r\n            pos = this.$clipPositionToDocument(docRow, docColumn);\r\n\r\n        docRow = pos.row;\r\n        docColumn = pos.column;\r\n\r\n        var screenRow = 0;\r\n        var foldStartRow = null;\r\n        var fold = null;\r\n\r\n        // Clamp the docRow position in case it's inside of a folded block.\r\n        fold = this.getFoldAt(docRow, docColumn, 1);\r\n        if (fold) {\r\n            docRow = fold.start.row;\r\n            docColumn = fold.start.column;\r\n        }\r\n\r\n        var rowEnd, row = 0;\r\n\r\n\r\n        var rowCache = this.$docRowCache;\r\n        var i = this.$getRowCacheIndex(rowCache, docRow);\r\n        var l = rowCache.length;\r\n        if (l && i >= 0) {\r\n            var row = rowCache[i];\r\n            var screenRow = this.$screenRowCache[i];\r\n            var doCache = docRow > rowCache[l - 1];\r\n        } else {\r\n            var doCache = !l;\r\n        }\r\n\r\n        var foldLine = this.getNextFoldLine(row);\r\n        var foldStart = foldLine ?foldLine.start.row :Infinity;\r\n\r\n        while (row < docRow) {\r\n            if (row >= foldStart) {\r\n                rowEnd = foldLine.end.row + 1;\r\n                if (rowEnd > docRow)\r\n                    break;\r\n                foldLine = this.getNextFoldLine(rowEnd, foldLine);\r\n                foldStart = foldLine ?foldLine.start.row :Infinity;\r\n            }\r\n            else {\r\n                rowEnd = row + 1;\r\n            }\r\n\r\n            screenRow += this.getRowLength(row);\r\n            row = rowEnd;\r\n\r\n            if (doCache) {\r\n                this.$docRowCache.push(row);\r\n                this.$screenRowCache.push(screenRow);\r\n            }\r\n        }\r\n\r\n        // Calculate the text line that is displayed in docRow on the screen.\r\n        var textLine = \"\";\r\n        // Check if the final row we want to reach is inside of a fold.\r\n        if (foldLine && row >= foldStart) {\r\n            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);\r\n            foldStartRow = foldLine.start.row;\r\n        } else {\r\n            textLine = this.getLine(docRow).substring(0, docColumn);\r\n            foldStartRow = docRow;\r\n        }\r\n        var wrapIndent = 0;\r\n        // Clamp textLine if in wrapMode.\r\n        if (this.$useWrapMode) {\r\n            var wrapRow = this.$wrapData[foldStartRow];\r\n            if (wrapRow) {\r\n                var screenRowOffset = 0;\r\n                while (textLine.length >= wrapRow[screenRowOffset]) {\r\n                    screenRow ++;\r\n                    screenRowOffset++;\r\n                }\r\n                textLine = textLine.substring(\r\n                    wrapRow[screenRowOffset - 1] || 0, textLine.length\r\n                );\r\n                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;\r\n            }\r\n        }\r\n\r\n        return {\r\n            row: screenRow,\r\n            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]\r\n        };\r\n    };\r\n\r\n    /**\r\n     * For the given document row and column, returns the screen column.\r\n     * @param {Number} row\r\n     * @param {Number} docColumn\r\n     * @returns {Number}\r\n     *\r\n     **/\r\n    this.documentToScreenColumn = function(row, docColumn) {\r\n        return this.documentToScreenPosition(row, docColumn).column;\r\n    };\r\n\r\n    /**\r\n     * For the given document row and column, returns the screen row.\r\n     * @param {Number} docRow\r\n     * @param {Number} docColumn\r\n     *\r\n     **/\r\n    this.documentToScreenRow = function(docRow, docColumn) {\r\n        return this.documentToScreenPosition(docRow, docColumn).row;\r\n    };\r\n\r\n    /**\r\n     * Returns the length of the screen.\r\n     * @returns {Number}\r\n     **/\r\n    this.getScreenLength = function() {\r\n        var screenRows = 0;\r\n        var fold = null;\r\n        if (!this.$useWrapMode) {\r\n            screenRows = this.getLength();\r\n\r\n            // Remove the folded lines again.\r\n            var foldData = this.$foldData;\r\n            for (var i = 0; i < foldData.length; i++) {\r\n                fold = foldData[i];\r\n                screenRows -= fold.end.row - fold.start.row;\r\n            }\r\n        } else {\r\n            var lastRow = this.$wrapData.length;\r\n            var row = 0, i = 0;\r\n            var fold = this.$foldData[i++];\r\n            var foldStart = fold ? fold.start.row :Infinity;\r\n\r\n            while (row < lastRow) {\r\n                var splits = this.$wrapData[row];\r\n                screenRows += splits ? splits.length + 1 : 1;\r\n                row ++;\r\n                if (row > foldStart) {\r\n                    row = fold.end.row+1;\r\n                    fold = this.$foldData[i++];\r\n                    foldStart = fold ?fold.start.row :Infinity;\r\n                }\r\n            }\r\n        }\r\n\r\n        // todo\r\n        if (this.lineWidgets)\r\n            screenRows += this.$getWidgetScreenLength();\r\n\r\n        return screenRows;\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     *\r\n     */\r\n    this.$setFontMetrics = function(fm) {\r\n        if (!this.$enableVarChar) return;\r\n        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {\r\n            if (maxScreenColumn === 0)\r\n                return [0, 0];\r\n            if (!maxScreenColumn)\r\n                maxScreenColumn = Infinity;\r\n            screenColumn = screenColumn || 0;\r\n            \r\n            var c, column;\r\n            for (column = 0; column < str.length; column++) {\r\n                c = str.charAt(column);\r\n                // tab\r\n                if (c === \"\\t\") {\r\n                    screenColumn += this.getScreenTabSize(screenColumn);\r\n                } else {\r\n                    screenColumn += fm.getCharacterWidth(c);\r\n                }\r\n                if (screenColumn > maxScreenColumn) {\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            return [screenColumn, column];\r\n        };\r\n    };\r\n    \r\n    this.destroy = function() {\r\n        if (this.bgTokenizer) {\r\n            this.bgTokenizer.setDocument(null);\r\n            this.bgTokenizer = null;\r\n        }\r\n        this.$stopWorker();\r\n    };\r\n\r\n    this.isFullWidth = isFullWidth;\r\n\r\n    // For every keystroke this gets called once per char in the whole doc!!\r\n    // Wouldn't hurt to make it a bit faster for c >= 0x1100\r\n    function isFullWidth(c) {\r\n        if (c < 0x1100)\r\n            return false;\r\n        return c >= 0x1100 && c <= 0x115F ||\r\n               c >= 0x11A3 && c <= 0x11A7 ||\r\n               c >= 0x11FA && c <= 0x11FF ||\r\n               c >= 0x2329 && c <= 0x232A ||\r\n               c >= 0x2E80 && c <= 0x2E99 ||\r\n               c >= 0x2E9B && c <= 0x2EF3 ||\r\n               c >= 0x2F00 && c <= 0x2FD5 ||\r\n               c >= 0x2FF0 && c <= 0x2FFB ||\r\n               c >= 0x3000 && c <= 0x303E ||\r\n               c >= 0x3041 && c <= 0x3096 ||\r\n               c >= 0x3099 && c <= 0x30FF ||\r\n               c >= 0x3105 && c <= 0x312D ||\r\n               c >= 0x3131 && c <= 0x318E ||\r\n               c >= 0x3190 && c <= 0x31BA ||\r\n               c >= 0x31C0 && c <= 0x31E3 ||\r\n               c >= 0x31F0 && c <= 0x321E ||\r\n               c >= 0x3220 && c <= 0x3247 ||\r\n               c >= 0x3250 && c <= 0x32FE ||\r\n               c >= 0x3300 && c <= 0x4DBF ||\r\n               c >= 0x4E00 && c <= 0xA48C ||\r\n               c >= 0xA490 && c <= 0xA4C6 ||\r\n               c >= 0xA960 && c <= 0xA97C ||\r\n               c >= 0xAC00 && c <= 0xD7A3 ||\r\n               c >= 0xD7B0 && c <= 0xD7C6 ||\r\n               c >= 0xD7CB && c <= 0xD7FB ||\r\n               c >= 0xF900 && c <= 0xFAFF ||\r\n               c >= 0xFE10 && c <= 0xFE19 ||\r\n               c >= 0xFE30 && c <= 0xFE52 ||\r\n               c >= 0xFE54 && c <= 0xFE66 ||\r\n               c >= 0xFE68 && c <= 0xFE6B ||\r\n               c >= 0xFF01 && c <= 0xFF60 ||\r\n               c >= 0xFFE0 && c <= 0xFFE6;\r\n    }\r\n\r\n}).call(EditSession.prototype);\r\n\r\nrequire(\"./edit_session/folding\").Folding.call(EditSession.prototype);\r\nrequire(\"./edit_session/bracket_match\").BracketMatch.call(EditSession.prototype);\r\n\r\n\r\nconfig.defineOptions(EditSession.prototype, \"session\", {\r\n    wrap: {\r\n        set: function(value) {\r\n            if (!value || value == \"off\")\r\n                value = false;\r\n            else if (value == \"free\")\r\n                value = true;\r\n            else if (value == \"printMargin\")\r\n                value = -1;\r\n            else if (typeof value == \"string\")\r\n                value = parseInt(value, 10) || false;\r\n\r\n            if (this.$wrap == value)\r\n                return;\r\n            this.$wrap = value;\r\n            if (!value) {\r\n                this.setUseWrapMode(false);\r\n            } else {\r\n                var col = typeof value == \"number\" ? value : null;\r\n                this.setWrapLimitRange(col, col);\r\n                this.setUseWrapMode(true);\r\n            }\r\n        },\r\n        get: function() {\r\n            if (this.getUseWrapMode()) {\r\n                if (this.$wrap == -1)\r\n                    return \"printMargin\";\r\n                if (!this.getWrapLimitRange().min)\r\n                    return \"free\";\r\n                return this.$wrap;\r\n            }\r\n            return \"off\";\r\n        },\r\n        handlesSet: true\r\n    },    \r\n    wrapMethod: {\r\n        // code|text|auto\r\n        set: function(val) {\r\n            val = val == \"auto\"\r\n                ? this.$mode.type != \"text\"\r\n                : val != \"text\";\r\n            if (val != this.$wrapAsCode) {\r\n                this.$wrapAsCode = val;\r\n                if (this.$useWrapMode) {\r\n                    this.$useWrapMode = false;\r\n                    this.setUseWrapMode(true);\r\n                }\r\n            }\r\n        },\r\n        initialValue: \"auto\"\r\n    },\r\n    indentedSoftWrap: {\r\n        set: function() {\r\n            if (this.$useWrapMode) {\r\n                this.$useWrapMode = false;\r\n                this.setUseWrapMode(true);\r\n            }\r\n        },\r\n        initialValue: true \r\n    },\r\n    firstLineNumber: {\r\n        set: function() {this._signal(\"changeBreakpoint\");},\r\n        initialValue: 1\r\n    },\r\n    useWorker: {\r\n        set: function(useWorker) {\r\n            this.$useWorker = useWorker;\r\n\r\n            this.$stopWorker();\r\n            if (useWorker)\r\n                this.$startWorker();\r\n        },\r\n        initialValue: true\r\n    },\r\n    useSoftTabs: {initialValue: true},\r\n    tabSize: {\r\n        set: function(tabSize) {\r\n            tabSize = parseInt(tabSize);\r\n            if (isNaN(tabSize) || this.$tabSize === tabSize) return;\r\n\r\n            this.$modified = true;\r\n            this.$rowLengthCache = [];\r\n            this.$tabSize = tabSize;\r\n            this._signal(\"changeTabSize\");\r\n        },\r\n        initialValue: 4,\r\n        handlesSet: true\r\n    },\r\n    navigateWithinSoftTabs: {initialValue: false},\r\n    foldStyle: {\r\n        set: function(val) {this.setFoldStyle(val);},\r\n        handlesSet: true\r\n    },\r\n    overwrite: {\r\n        set: function(val) {this._signal(\"changeOverwrite\");},\r\n        initialValue: false\r\n    },\r\n    newLineMode: {\r\n        set: function(val) {this.doc.setNewLineMode(val);},\r\n        get: function() {return this.doc.getNewLineMode();},\r\n        handlesSet: true\r\n    },\r\n    mode: {\r\n        set: function(val) { this.setMode(val); },\r\n        get: function() { return this.$modeId; },\r\n        handlesSet: true\r\n    }\r\n});\r\n\r\nexports.EditSession = EditSession;\r\n});\r\n"]}