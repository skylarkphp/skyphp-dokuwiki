{"version":3,"sources":["edit_session/fold_line.js"],"names":["define","require","exports","module","Range","FoldLine","foldData","folds","this","Array","isArray","last","length","range","start","row","column","end","forEach","fold","setFoldLine","shiftRow","shift","addFold","sameRow","startRow","endRow","Error","push","sort","a","b","compareEnd","compareStart","unshift","foldLine","containsRow","walk","callback","endColumn","cmp","lastEnd","isNewRow","i","placeholder","getNextFoldTo","kind","addRemoveChars","len","ret","window","console","log","indexOf","split","pos","foldBefore","newFoldLine","splice","merge","foldLineNext","toString","join","idxToPosition","idx","lastFoldEndColumn","call","prototype"],"mappings":"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","file":"../../edit_session/fold_line.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n * \r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar Range = require(\"../range\").Range;\r\n\r\n/*\r\n * If an array is passed in, the folds are expected to be sorted already.\r\n */\r\nfunction FoldLine(foldData, folds) {\r\n    this.foldData = foldData;\r\n    if (Array.isArray(folds)) {\r\n        this.folds = folds;\r\n    } else {\r\n        folds = this.folds = [ folds ];\r\n    }\r\n\r\n    var last = folds[folds.length - 1];\r\n    this.range = new Range(folds[0].start.row, folds[0].start.column,\r\n                           last.end.row, last.end.column);\r\n    this.start = this.range.start;\r\n    this.end   = this.range.end;\r\n\r\n    this.folds.forEach(function(fold) {\r\n        fold.setFoldLine(this);\r\n    }, this);\r\n}\r\n\r\n(function() {\r\n    /*\r\n     * Note: This doesn't update wrapData!\r\n     */\r\n    this.shiftRow = function(shift) {\r\n        this.start.row += shift;\r\n        this.end.row += shift;\r\n        this.folds.forEach(function(fold) {\r\n            fold.start.row += shift;\r\n            fold.end.row += shift;\r\n        });\r\n    };\r\n\r\n    this.addFold = function(fold) {\r\n        if (fold.sameRow) {\r\n            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {\r\n                throw new Error(\"Can't add a fold to this FoldLine as it has no connection\");\r\n            }\r\n            this.folds.push(fold);\r\n            this.folds.sort(function(a, b) {\r\n                return -a.range.compareEnd(b.start.row, b.start.column);\r\n            });\r\n            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {\r\n                this.end.row = fold.end.row;\r\n                this.end.column =  fold.end.column;\r\n            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {\r\n                this.start.row = fold.start.row;\r\n                this.start.column = fold.start.column;\r\n            }\r\n        } else if (fold.start.row == this.end.row) {\r\n            this.folds.push(fold);\r\n            this.end.row = fold.end.row;\r\n            this.end.column = fold.end.column;\r\n        } else if (fold.end.row == this.start.row) {\r\n            this.folds.unshift(fold);\r\n            this.start.row = fold.start.row;\r\n            this.start.column = fold.start.column;\r\n        } else {\r\n            throw new Error(\"Trying to add fold to FoldRow that doesn't have a matching row\");\r\n        }\r\n        fold.foldLine = this;\r\n    };\r\n\r\n    this.containsRow = function(row) {\r\n        return row >= this.start.row && row <= this.end.row;\r\n    };\r\n\r\n    this.walk = function(callback, endRow, endColumn) {\r\n        var lastEnd = 0,\r\n            folds = this.folds,\r\n            fold,\r\n            cmp, stop, isNewRow = true;\r\n\r\n        if (endRow == null) {\r\n            endRow = this.end.row;\r\n            endColumn = this.end.column;\r\n        }\r\n\r\n        for (var i = 0; i < folds.length; i++) {\r\n            fold = folds[i];\r\n\r\n            cmp = fold.range.compareStart(endRow, endColumn);\r\n            // This fold is after the endRow/Column.\r\n            if (cmp == -1) {\r\n                callback(null, endRow, endColumn, lastEnd, isNewRow);\r\n                return;\r\n            }\r\n\r\n            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);\r\n            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);\r\n\r\n            // If the user requested to stop the walk or endRow/endColumn is\r\n            // inside of this fold (cmp == 0), then end here.\r\n            if (stop || cmp === 0) {\r\n                return;\r\n            }\r\n\r\n            // Note the new lastEnd might not be on the same line. However,\r\n            // it's the callback's job to recognize this.\r\n            isNewRow = !fold.sameRow;\r\n            lastEnd = fold.end.column;\r\n        }\r\n        callback(null, endRow, endColumn, lastEnd, isNewRow);\r\n    };\r\n\r\n    this.getNextFoldTo = function(row, column) {\r\n        var fold, cmp;\r\n        for (var i = 0; i < this.folds.length; i++) {\r\n            fold = this.folds[i];\r\n            cmp = fold.range.compareEnd(row, column);\r\n            if (cmp == -1) {\r\n                return {\r\n                    fold: fold,\r\n                    kind: \"after\"\r\n                };\r\n            } else if (cmp === 0) {\r\n                return {\r\n                    fold: fold,\r\n                    kind: \"inside\"\r\n                };\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n\r\n    this.addRemoveChars = function(row, column, len) {\r\n        var ret = this.getNextFoldTo(row, column),\r\n            fold, folds;\r\n        if (ret) {\r\n            fold = ret.fold;\r\n            if (ret.kind == \"inside\"\r\n                && fold.start.column != column\r\n                && fold.start.row != row)\r\n            {\r\n                //throwing here breaks whole editor\r\n                //TODO: properly handle this\r\n                window.console && window.console.log(row, column, fold);\r\n            } else if (fold.start.row == row) {\r\n                folds = this.folds;\r\n                var i = folds.indexOf(fold);\r\n                if (i === 0) {\r\n                    this.start.column += len;\r\n                }\r\n                for (i; i < folds.length; i++) {\r\n                    fold = folds[i];\r\n                    fold.start.column += len;\r\n                    if (!fold.sameRow) {\r\n                        return;\r\n                    }\r\n                    fold.end.column += len;\r\n                }\r\n                this.end.column += len;\r\n            }\r\n        }\r\n    };\r\n\r\n    this.split = function(row, column) {\r\n        var pos = this.getNextFoldTo(row, column);\r\n        \r\n        if (!pos || pos.kind == \"inside\")\r\n            return null;\r\n            \r\n        var fold = pos.fold;\r\n        var folds = this.folds;\r\n        var foldData = this.foldData;\r\n        \r\n        var i = folds.indexOf(fold);\r\n        var foldBefore = folds[i - 1];\r\n        this.end.row = foldBefore.end.row;\r\n        this.end.column = foldBefore.end.column;\r\n\r\n        // Remove the folds after row/column and create a new FoldLine\r\n        // containing these removed folds.\r\n        folds = folds.splice(i, folds.length - i);\r\n\r\n        var newFoldLine = new FoldLine(foldData, folds);\r\n        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);\r\n        return newFoldLine;\r\n    };\r\n\r\n    this.merge = function(foldLineNext) {\r\n        var folds = foldLineNext.folds;\r\n        for (var i = 0; i < folds.length; i++) {\r\n            this.addFold(folds[i]);\r\n        }\r\n        // Remove the foldLineNext - no longer needed, as\r\n        // it's merged now with foldLineNext.\r\n        var foldData = this.foldData;\r\n        foldData.splice(foldData.indexOf(foldLineNext), 1);\r\n    };\r\n\r\n    this.toString = function() {\r\n        var ret = [this.range.toString() + \": [\" ];\r\n\r\n        this.folds.forEach(function(fold) {\r\n            ret.push(\"  \" + fold.toString());\r\n        });\r\n        ret.push(\"]\");\r\n        return ret.join(\"\\n\");\r\n    };\r\n\r\n    this.idxToPosition = function(idx) {\r\n        var lastFoldEndColumn = 0;\r\n\r\n        for (var i = 0; i < this.folds.length; i++) {\r\n            var fold = this.folds[i];\r\n\r\n            idx -= fold.start.column - lastFoldEndColumn;\r\n            if (idx < 0) {\r\n                return {\r\n                    row: fold.start.row,\r\n                    column: fold.start.column + idx\r\n                };\r\n            }\r\n\r\n            idx -= fold.placeholder.length;\r\n            if (idx < 0) {\r\n                return fold.start;\r\n            }\r\n\r\n            lastFoldEndColumn = fold.end.column;\r\n        }\r\n\r\n        return {\r\n            row: this.end.row,\r\n            column: this.end.column + idx\r\n        };\r\n    };\r\n}).call(FoldLine.prototype);\r\n\r\nexports.FoldLine = FoldLine;\r\n});\r\n"]}