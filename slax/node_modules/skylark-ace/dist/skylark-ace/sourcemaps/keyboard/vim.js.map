{"version":3,"sources":["keyboard/vim.js"],"names":["define","require","exports","module","Range","EventEmitter","dom","oop","KEYS","event","Search","useragent","SearchHighlight","multiSelectCommands","TextModeTokenRe","Mode","prototype","tokenRe","CodeMirror","ace","this","state","marks","$uid","onChange","bind","onSelectionChange","onBeforeEndOperation","on","toAcePos","cmPos","row","line","column","ch","toCmPos","acePos","Pos","defineOption","name","val","setter","commands","redo","cm","undo","newlineAndIndent","insert","keyMap","addClass","rmClass","e_stop","e_preventDefault","stopEvent","keyName","e","key","keyCode","length","toUpperCase","getModifierString","replace","m","cmd","commandKeyBinding","toLowerCase","execCommand","lookupKey","map","handle","found","fallthrough","Array","isArray","i","result","signal","o","_signal","addListener","off","removeListener","isWordChar","test","lastIndex","implement","destroy","removeOverlay","virtualSelectionMode","inVirtualSelectionMode","selection","index","delta","change","text","action","lines","curOp","changeHandlers","_eventRegistry","slice","lastChange","next","$updateMarkers","cursorActivityHandlers","cursorActivity","inMultiSelectMode","keyBinding","removeKeyboardHandler","keyboardHandler","operation","fn","force","prevOp","startOperation","command","scrollIntoView","dialog","endOperation","op","eventName","handlers","listeners","firstLine","lastLine","session","getLength","lineCount","setCursor","exitMultiSelectMode","unfold","moveTo","getCursor","p","sel","isEmpty","lead","anchor","getRange","listSelections","ranges","multiSelect","rangeList","head","r","clipPos","cursor","end","start","setSelections","primIndex","x","comparePoints","fromPoints","fromOrientedRange","push","splice","reverse","toSingleRange","clone","range","$clipRangeToDocument","addRange","setSelection","a","h","options","selectTo","origin","somethingSelected","$clipPositionToDocument","markText","clear","find","isInsert","rowShift","colShift","point","cmp","bias","cmp2","Marker","id","setBookmark","bm","insertLeft","$insertRight","moveH","increment","unit","clearSelection","moveCursorBy","findPosV","amount","goalColumn","config","renderer","layerConfig","Math","floor","height","lineHeight","screenPos","documentToScreenPosition","min","max","getScreenLength","screenToDocumentPosition","charCoords","pos","mode","left","sc","top","lh","cw","characterWidth","bottom","coordsChar","col","getSearchCursor","query","caseFold","caseSensitive","isRegexp","RegExp","global","ignoreCase","source","search","undefined","Number","MAX_VALUE","last","findNext","findPrevious","back","setOptions","needle","wrap","backwards","regExp","getLine","$options","from","to","doc","scrollTo","y","maxHeight","$size","scrollerHeight","$scrollPastEnd","setScrollTop","setScrollLeft","width","scrollInfo","margin","viewMargin","scrollCursorIntoView","s","getTextRange","replaceRange","replaceSelections","getSelection","getSelectedText","getSelections","getInputField","textInput","getElement","getWrapperElement","container","optMap","indentWithTabs","indentUnit","tabSize","firstLineNumber","readOnly","setOption","getOption","aceOpt","toggleOverwrite","overwrite","setOverwrite","addOverlay","$searchHighlight","highlight","marker","addDynamicMarker","updateOnChange","removeMarker","cache","re","setRegexp","updateBackMarkers","getScrollInfo","scrollLeft","scrollTop","clientHeight","clientWidth","getValue","setValue","v","getTokenTypeAt","token","getTokenAt","type","findMatchingBracket","indentLine","method","indentRows","outdentRows","indexFromPos","positionToIndex","posFromIndex","indexToPosition","focus","blur","defaultTextHeight","scanForBracket","dir","_","bracketRegex","$findClosingBracket","$findOpeningBracket","refresh","resize","getMode","call","StringStream","string","lastColumnPos","lastColumnValue","lineStart","eol","sol","peek","charAt","eat","match","ok","eatWhile","eatSpace","skipToEnd","skipTo","indexOf","backUp","n","indentation","pattern","consume","caseInsensitive","cased","str","substr","current","hideFirstChars","inner","defineExtension","importCssString","dialogDiv","template","appendChild","document","createElement","className","innerHTML","closeNotification","newVal","currentNotificationClose","callback","closed","me","button","inp","getElementsByTagName","value","selectValueOnOpen","select","onInput","close","onKeyUp","onKeyDown","closeOnEnter","closeOnBlur","activeElement","parentNode","removeChild","onClose","doneTimer","duration","setTimeout","clearTimeout","defaultKeymap","keys","toKeys","context","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultExCommandMap","shortName","possiblyAsync","excludeFromCommandHistory","Vim","vimApi","detachVimMap","vim","attach","attachVimMap","onCursorActivity","getOnPasteFn","leaveVimMode","prev","maybeInitVimState","enterVimMode","cmKey","vimKey","pieces","split","lastPiece","hasCharacter","piece","modifiers","specialKeys","isUpperCase","join","cmKeyToVimKey","findKey","Init","Shift","Ctrl","Alt","Cmd","Mod","Enter","Backspace","Delete","Insert","onPasteFn","insertMode","offsetCursor","actions","enterInsertMode","numberRegex","wordCharTest","bigWordCharTest","makeKeyRange","size","String","fromCharCode","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","isLine","isLowerCase","k","isWhiteSpaceString","inArray","arr","defaultValue","aliases","Error","cfg","option","scope","local","vimGlobalState","lastInsertModeKeyTimer","createCircularJumpList","pointer","tail","buffer","cachedCursor","add","oldCur","newCur","curMark","useNextSlot","trashMark","markPos","cursorEqual","move","offset","mark","inc","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","fakeCursor","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","resetVimGlobalState","optionName","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","macroModeState","lastCharacterSearch","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","exitMacroRecordMode","enterMacroRecordMode","registerName","register","getRegister","openDialog","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","lhs","rhs","ctx","exCommandDispatcher","unmap","defineEx","prefix","func","exCommands","commandMap_","handleKey","handleMacroRecording","clearInputState","pushText","logKey","handleEsc","exitVisualMode","exitInsertMode","keyBuffer","keysAreChars","commandDispatcher","matchCommand","thisMatch","window","selections","here","pop","handleKeyInsertMode","keysMatcher","exec","pushRepeatDigit","handleKeyNonInsertMode","isVimOp","substring","doKeyToKey","processCommand","console","handleEx","input","defineMotion","motions","defineAction","defineOperator","operators","mapCommand","args","extra","_mapCommand","defineRegister","registers","prefixRepeat","motionRepeat","reason","Register","insertModeChanges","searchQueries","unnamedRegister","historyBuffer","iterator","initialPrefix","getRepeat","repeat","parseInt","setText","pushInsertModeChanges","pushSearchQuery","toString","isValidRegister","shiftNumericRegisters_","nextMatch","up","element","j","pushInput","reset","bestMatch","matches","partial","full","commandMatch","commandMatches","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","repeatIsExplicit","recordLastEdit","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","handleQuery","shift","showPrompt","logSearchQuery","desc","searchPromptDesc","parsedQuery","target","selectionEnd","selectionStart","updateSearchQuery","clearSearchHighlight","word","expandWordUnderCursor","isKeyword","smartCase","showConfirm","onPromptClose","onPromptKeyDown","exArgs","newHead","newAnchor","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","noRepeat","motionResult","recordJumpPosition","Infinity","updateCmSelection","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","lineLength","tmp","_cm","expandSelectionToLine","clipToLine","primary","operatorMoveTo","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","moveToBottomLine","expandToLine","isReversed","highlightSearchMatches","goToMark","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","equal","between","cursorIsBetween","moveByCharacters","cur","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","moveToStartOfLine","fold","getFoldLine","res","hitSide","goalCoords","resCoords","moveByPage","moveByParagraph","findParagraph","scrollbox","orig","dest","moveByWords","words","emptyLineIsWord","findWord","eodCh","shortCircuit","firstWord","lastWord","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","symb","endLine","curCh","lineText","nextCh","lastCh","reverseSymb",")","}","(","{","depth","curMoveThrough","symbolToMode","init","findSymbolModes","isComplete","lineLen","findSymbol","retval","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","symbol","style","moveToLineOrEdgeOfDocument","lineNum","textObjectManipulation","[","]","<",">","bracketRegexp","openSym","selectCompanionObject","'","\"","`","len","chars","firstIndex","findBeginningAndEnd","expandSelection","repeatLastCharacterSearch","lastSearch","fillArray","times","finalHead","inVisualBlock","replacement","lastState","prevLineEnd","wasLastLine","delete","indent","startLine","changeCase","swapped","toSwap","yank","endPos","jumpListWalk","scroll","newPos","cursorCoords","ceil","newBottom","scrollToCursor","replayMacro","executeMacroRegister","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","subMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineAndIndentContinueComment","paste","whitespaceLength","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","block","getLastSelectedAreaRange","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","extendLineToColumn","repeatFn","setRegister","setMark","replaceTo","replaceWith","replaceWithStr","incrementNumberToken","numberStr","lineStr","baseStr","digits","base","0b","0","","0x","zeroPadding","repeatLastEdit","includeLineBreak","maxCh","ret","prop","hasOwnProperty","offsetLine","offsetCh","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","cur3","cur1before2","cur2before3","trim","isClipped","atAnchor","atHead","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","updateFakeCursor","exclusive","headOffset","anchorOffset","right","moveHead","firstNonWS","_forward","noSymbol","getHead","wordStart","*","/","M","#","bracket","section","comment","preprocess","charTests","stop","foundWord","charIdxInLine","markName","includeChar","lastIndexOf","isBoundary","any","skipFold","foldLine","startState","SearchState","searchState_","shortText","status","$loop","schedule","CHANGE_CURSOR","prompt","splitBySeparator","argString","separator","slashes","findUnescapedSeparators","tokens","escapeNextChar","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","charUnescapes","\\n","\\r","\\t","unescapes","\\/","\\\\","parseQuery","regexPart","forceIgnoreCase","out","specialComesNext","translateRegex","openNotification","alert","raw","rawQuery","r1","r2","props","regexEqual","searchState","matchSol","stream","showMatchesOnScrollbar","getFirstFullyVisibleRow","getLastFullyVisibleRow","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","commandName","params","parseInput_","matchCommand_","parseCommandArgs_","toInput","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","mapping","unshift","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","number","err","opts","decimal","hex","octal","parseArgs","radix","numPart","textPart","matchPart","b","compareFn","textOld","anum","bnum","splitBySlash","matchedLines","content","nextCommand","substitute","trailing","flagsPart","count","replacePart","confirm","output","matched","matcher","unescapeRegexReplace","translateRegexReplace","startPos","searchCursor","exMode","done","lastPos","replaceAll","newText","_value","savedCallback","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","insertModeChangeRegister","logInsertModeChange","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","getOffset","detach","Ctrl-N","Ctrl-P","specialKey","return","backspace","esc","down","space","home","pageup","pagedown","enter","cloneVimState","constructor","Object","forEach","getVim","delayedExecAceCommand","vimCmd","handler","$id","drawCursor","pixelPos","w","isBackwards","translate","setStyle","handleKeyboard","data","hashId","editor","inputKey","inputHash","inputChar","isMac","getCopyText","once","passEvent","ctrlKey","altKey","shiftKey","isHandled","wasInVisualBlock","old","forEachSelection","$desiredColumn","multiSelectHandleKey","updateInputMode","isIntsert","setCommandMode","$keepTextAreaAtCursor","$blockCursor","$vimModeHandler","markUndoGroup","updateCursor","$cursorLayer","getStatusText","log","open","all","toggle","aceCommand"],"mappings":"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","file":"../../keyboard/vim.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n/**\r\n * Supported keybindings:\r\n *   Too many to list. Refer to defaultKeyMap below.\r\n *\r\n * Supported Ex commands:\r\n *   Refer to defaultExCommandMap below.\r\n *\r\n * Registers: unnamed, -, a-z, A-Z, 0-9\r\n *   (Does not respect the special case for number registers when delete\r\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\r\n *   TODO: Implement the remaining registers.\r\n *\r\n * Marks: a-z, A-Z, and 0-9\r\n *   TODO: Implement the remaining special marks. They have more complex\r\n *       behavior.\r\n *\r\n * Events:\r\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\r\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\r\n *\r\n * Code structure:\r\n *  1. Default keymap\r\n *  2. Variable declarations and short basic helpers\r\n *  3. Instance (External API) implementation\r\n *  4. Internal state tracking objects (input state, counter) implementation\r\n *     and instantiation\r\n *  5. Key handler (the main command dispatcher) implementation\r\n *  6. Motion, operator, and action implementations\r\n *  7. Helper functions for the key handler, motions, operators, and actions\r\n *  8. Set up Vim to work as a keymap for CodeMirror.\r\n *  9. Ex command implementations.\r\n */\r\n\r\ndefine(function(require, exports, module) {\r\n  'use strict';\r\n\r\n  function log() {\r\n    var d = \"\";\r\n    function format(p) {\r\n      if (typeof p != \"object\")\r\n        return p + \"\";\r\n      if (\"line\" in p) {\r\n        return p.line + \":\" + p.ch;\r\n      }\r\n      if (\"anchor\" in p) {\r\n        return format(p.anchor) + \"->\" + format(p.head);\r\n      }\r\n      if (Array.isArray(p))\r\n        return \"[\" + p.map(function(x) {\r\n          return format(x);\r\n        }) + \"]\";\r\n      return JSON.stringify(p);\r\n    }\r\n    for (var i = 0; i < arguments.length; i++) {\r\n      var p = arguments[i];\r\n      var f = format(p);\r\n      d += f + \"  \";\r\n    }\r\n    console.log(d);\r\n  }\r\n  var Range = require(\"../range\").Range;\r\n  var EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\r\n  var dom = require(\"../lib/dom\");\r\n  var oop = require(\"../lib/oop\");\r\n  var KEYS = require(\"../lib/keys\");\r\n  var event = require(\"../lib/event\");\r\n  var Search = require(\"../search\").Search;\r\n  var useragent = require(\"../lib/useragent\");\r\n  var SearchHighlight = require(\"../search_highlight\").SearchHighlight;\r\n  var multiSelectCommands = require(\"../commands/multi_select_commands\");\r\n  var TextModeTokenRe = require(\"../mode/text\").Mode.prototype.tokenRe;\r\n  require(\"../multi_select\");\r\n\r\n  var CodeMirror = function(ace) {\r\n    this.ace = ace;\r\n    this.state = {};\r\n    this.marks = {};\r\n    this.$uid = 0;\r\n    this.onChange = this.onChange.bind(this);\r\n    this.onSelectionChange = this.onSelectionChange.bind(this);\r\n    this.onBeforeEndOperation = this.onBeforeEndOperation.bind(this);\r\n    this.ace.on('change', this.onChange);\r\n    this.ace.on('changeSelection', this.onSelectionChange);\r\n    this.ace.on('beforeEndOperation', this.onBeforeEndOperation);\r\n  };\r\n  CodeMirror.Pos = function(line, ch) {\r\n    if (!(this instanceof Pos)) return new Pos(line, ch);\r\n    this.line = line; this.ch = ch;\r\n  };\r\n  CodeMirror.defineOption = function(name, val, setter) {};\r\n  CodeMirror.commands = {\r\n    redo: function(cm) { cm.ace.redo(); },\r\n    undo: function(cm) { cm.ace.undo(); },\r\n    newlineAndIndent: function(cm) { cm.ace.insert(\"\\n\"); }\r\n  };\r\n  CodeMirror.keyMap = {};\r\n  CodeMirror.addClass = CodeMirror.rmClass = function() {};\r\n  CodeMirror.e_stop = CodeMirror.e_preventDefault = event.stopEvent;\r\n  CodeMirror.keyName = function(e) {\r\n    var key = (KEYS[e.keyCode] || e.key || \"\");\r\n    if (key.length == 1) key = key.toUpperCase();\r\n    key = event.getModifierString(e).replace(/(^|-)\\w/g, function(m) {\r\n      return m.toUpperCase();\r\n    }) + key;\r\n    return key;\r\n  };\r\n  CodeMirror.keyMap['default'] = function(key) {\r\n    return function(cm) {\r\n      var cmd = cm.ace.commands.commandKeyBinding[key.toLowerCase()];\r\n      return cmd && cm.ace.execCommand(cmd) !== false;\r\n    };\r\n  };\r\n  CodeMirror.lookupKey = function lookupKey(key, map, handle) {\r\n    if (typeof map == \"string\")\r\n      map = CodeMirror.keyMap[map];\r\n    var found = typeof map == \"function\" ? map(key) : map[key];\r\n    if (found === false) return \"nothing\";\r\n    if (found === \"...\") return \"multi\";\r\n    if (found != null && handle(found)) return \"handled\";\r\n\r\n    if (map.fallthrough) {\r\n      if (!Array.isArray(map.fallthrough))\r\n        return lookupKey(key, map.fallthrough, handle);\r\n      for (var i = 0; i < map.fallthrough.length; i++) {\r\n        var result = lookupKey(key, map.fallthrough[i], handle);\r\n        if (result) return result;\r\n      }\r\n    }\r\n  };\r\n\r\n  CodeMirror.signal = function(o, name, e) { return o._signal(name, e) };\r\n  CodeMirror.on = event.addListener;\r\n  CodeMirror.off = event.removeListener;\r\n  CodeMirror.isWordChar = function(ch) {\r\n    if (ch < \"\\x7f\") return /^\\w$/.test(ch);\r\n    TextModeTokenRe.lastIndex = 0;\r\n    return TextModeTokenRe.test(ch);\r\n  };\r\n  \r\n(function() {\r\n  oop.implement(CodeMirror.prototype, EventEmitter);\r\n  \r\n  this.destroy = function() {\r\n    this.ace.off('change', this.onChange);\r\n    this.ace.off('changeSelection', this.onSelectionChange);\r\n    this.ace.off('beforeEndOperation', this.onBeforeEndOperation);\r\n    this.removeOverlay();\r\n  };\r\n  this.virtualSelectionMode = function() {\r\n    return this.ace.inVirtualSelectionMode && this.ace.selection.index;\r\n  };\r\n  this.onChange = function(delta) {\r\n    var change = { text: delta.action[0] == 'i' ? delta.lines : [] };\r\n    var curOp = this.curOp = this.curOp || {};\r\n    if (!curOp.changeHandlers)\r\n      curOp.changeHandlers = this._eventRegistry[\"change\"] && this._eventRegistry[\"change\"].slice();\r\n    if (!curOp.lastChange) {\r\n      curOp.lastChange = curOp.change = change;\r\n    } else {\r\n      curOp.lastChange.next = curOp.lastChange = change;\r\n    }\r\n    this.$updateMarkers(delta);\r\n  };\r\n  this.onSelectionChange = function() {\r\n    var curOp = this.curOp = this.curOp || {};\r\n    if (!curOp.cursorActivityHandlers)\r\n      curOp.cursorActivityHandlers = this._eventRegistry[\"cursorActivity\"] && this._eventRegistry[\"cursorActivity\"].slice();\r\n    this.curOp.cursorActivity = true;\r\n    if (this.ace.inMultiSelectMode) {\r\n      this.ace.keyBinding.removeKeyboardHandler(multiSelectCommands.keyboardHandler);\r\n    }\r\n  };\r\n  this.operation = function(fn, force) {\r\n    if (!force && this.curOp || force && this.curOp && this.curOp.force) {\r\n      return fn();\r\n    }\r\n    if (force || !this.ace.curOp) {\r\n      if (this.curOp)\r\n        this.onBeforeEndOperation();\r\n    }\r\n    if (!this.ace.curOp) {\r\n      var prevOp = this.ace.prevOp;\r\n      this.ace.startOperation({\r\n        command: { name: \"vim\",  scrollIntoView: \"cursor\" }\r\n      });\r\n    }\r\n    var curOp = this.curOp = this.curOp || {};\r\n    this.curOp.force = force;\r\n    var result = fn();\r\n    if (this.ace.curOp && this.ace.curOp.command.name == \"vim\") {\r\n      if (this.state.dialog)\r\n        this.ace.curOp.command.scrollIntoView = false;\r\n      this.ace.endOperation();\r\n      if (!curOp.cursorActivity && !curOp.lastChange && prevOp)\r\n        this.ace.prevOp = prevOp;\r\n    }\r\n    if (force || !this.ace.curOp) {\r\n      if (this.curOp)\r\n        this.onBeforeEndOperation();\r\n    }\r\n    return result;\r\n  };\r\n  this.onBeforeEndOperation = function() {\r\n    var op = this.curOp;\r\n    if (op) {\r\n      if (op.change) { this.signal(\"change\", op.change, op); }\r\n      if (op && op.cursorActivity) { this.signal(\"cursorActivity\", null, op); }\r\n      this.curOp = null;\r\n    }\r\n  };\r\n\r\n  this.signal = function(eventName, e, handlers) {\r\n    var listeners = handlers ? handlers[eventName + \"Handlers\"]\r\n        : (this._eventRegistry || {})[eventName];\r\n    if (!listeners)\r\n        return;\r\n    listeners = listeners.slice();\r\n    for (var i=0; i<listeners.length; i++)\r\n        listeners[i](this, e);\r\n  };\r\n  this.firstLine = function() { return 0; };\r\n  this.lastLine = function() { return this.ace.session.getLength() - 1; };\r\n  this.lineCount = function() { return this.ace.session.getLength(); };\r\n  this.setCursor = function(line, ch) {\r\n    if (typeof line === 'object') {\r\n      ch = line.ch;\r\n      line = line.line;\r\n    }\r\n    if (!this.ace.inVirtualSelectionMode)\r\n      this.ace.exitMultiSelectMode();\r\n    this.ace.session.unfold({row: line, column: ch});\r\n    this.ace.selection.moveTo(line, ch);\r\n  };\r\n  this.getCursor = function(p) {\r\n    var sel = this.ace.selection;\r\n    var pos = p == 'anchor' ? (sel.isEmpty() ? sel.lead : sel.anchor) :\r\n        p == 'head' || !p ? sel.lead : sel.getRange()[p];\r\n    return toCmPos(pos);\r\n  };\r\n  this.listSelections = function(p) {\r\n    var ranges = this.ace.multiSelect.rangeList.ranges;\r\n    if (!ranges.length || this.ace.inVirtualSelectionMode)\r\n      return [{anchor: this.getCursor('anchor'), head: this.getCursor('head')}];\r\n    return ranges.map(function(r) {\r\n      return {\r\n        anchor: this.clipPos(toCmPos(r.cursor == r.end ? r.start : r.end)),\r\n        head: this.clipPos(toCmPos(r.cursor))\r\n      };\r\n    }, this);\r\n  };\r\n  this.setSelections = function(p, primIndex) {\r\n    var sel = this.ace.multiSelect;\r\n    var ranges = p.map(function(x) {\r\n      var anchor = toAcePos(x.anchor);\r\n      var head = toAcePos(x.head);\r\n      var r = Range.comparePoints(anchor, head) < 0\r\n        ? new Range.fromPoints(anchor, head)\r\n        : new Range.fromPoints(head, anchor);\r\n      r.cursor = Range.comparePoints(r.start, head) ? r.end : r.start;\r\n      return r;\r\n    });\r\n    \r\n    if (this.ace.inVirtualSelectionMode) {\r\n      this.ace.selection.fromOrientedRange(ranges[0]);\r\n      return;\r\n    }\r\n    if (!primIndex) {\r\n        ranges = ranges.reverse();\r\n    } else if (ranges[primIndex]) {\r\n       ranges.push(ranges.splice(primIndex, 1)[0]);\r\n    }\r\n    sel.toSingleRange(ranges[0].clone());\r\n    var session = this.ace.session;\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var range = session.$clipRangeToDocument(ranges[i]); // todo why ace doesn't do this?\r\n      sel.addRange(range);\r\n    }\r\n  };\r\n  this.setSelection = function(a, h, options) {\r\n    var sel = this.ace.selection;\r\n    sel.moveTo(a.line, a.ch);\r\n    sel.selectTo(h.line, h.ch);\r\n    if (options && options.origin == '*mouse') {\r\n      this.onBeforeEndOperation();\r\n    }\r\n  };\r\n  this.somethingSelected = function(p) {\r\n    return !this.ace.selection.isEmpty();\r\n  };\r\n  this.clipPos = function(p) {\r\n    var pos = this.ace.session.$clipPositionToDocument(p.line, p.ch);\r\n    return toCmPos(pos);\r\n  };\r\n  this.markText = function(cursor) {\r\n    // only used for fat-cursor, not needed\r\n    return {clear: function() {}, find: function() {}};\r\n  };\r\n  this.$updateMarkers = function(delta) {\r\n    var isInsert = delta.action == \"insert\";\r\n    var start = delta.start;\r\n    var end = delta.end;\r\n    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\r\n    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\r\n    if (isInsert) end = start;\r\n    \r\n    for (var i in this.marks) {\r\n      var point = this.marks[i];\r\n      var cmp = Range.comparePoints(point, start);\r\n      if (cmp < 0) {\r\n        continue; // delta starts after the range\r\n      }\r\n      if (cmp === 0) {\r\n        if (isInsert) {\r\n          if (point.bias == 1) {\r\n            cmp = 1;\r\n          } else {\r\n            point.bias = -1;\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n      var cmp2 = isInsert ? cmp : Range.comparePoints(point, end);\r\n      if (cmp2 > 0) {\r\n        point.row += rowShift;\r\n        point.column += point.row == end.row ? colShift : 0;\r\n        continue;\r\n      }\r\n      if (!isInsert && cmp2 <= 0) {\r\n        point.row = start.row;\r\n        point.column = start.column;\r\n        if (cmp2 === 0)\r\n          point.bias = 1;\r\n      }\r\n    }\r\n  };\r\n  var Marker = function(cm, id, row, column) {\r\n    this.cm = cm;\r\n    this.id = id;\r\n    this.row = row;\r\n    this.column = column;\r\n    cm.marks[this.id] = this;\r\n  };\r\n  Marker.prototype.clear = function() { delete this.cm.marks[this.id] };\r\n  Marker.prototype.find = function() { return toCmPos(this) };\r\n  this.setBookmark = function(cursor, options) {\r\n    var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);\r\n    if (!options || !options.insertLeft)\r\n      bm.$insertRight = true;\r\n    this.marks[bm.id] = bm;\r\n    return bm;\r\n  };\r\n  this.moveH = function(increment, unit) {\r\n    if (unit == 'char') {\r\n      var sel = this.ace.selection;\r\n      sel.clearSelection();\r\n      sel.moveCursorBy(0, increment);\r\n    }\r\n  };\r\n  this.findPosV = function(start, amount, unit, goalColumn) {\r\n    if (unit == 'page') {\r\n      var renderer = this.ace.renderer;\r\n      var config = renderer.layerConfig;\r\n      amount = amount * Math.floor(config.height / config.lineHeight);\r\n      unit = 'line';\r\n    }\r\n    if (unit == 'line') {\r\n      var screenPos = this.ace.session.documentToScreenPosition(start.line, start.ch);\r\n      if (goalColumn != null)\r\n        screenPos.column = goalColumn;\r\n      screenPos.row += amount;\r\n      // not what codemirror does but vim mode needs only this\r\n      screenPos.row = Math.min(Math.max(0, screenPos.row), this.ace.session.getScreenLength() - 1);\r\n      var pos = this.ace.session.screenToDocumentPosition(screenPos.row, screenPos.column);\r\n      return toCmPos(pos);\r\n    } else {\r\n      debugger;\r\n    }\r\n  };\r\n  this.charCoords = function(pos, mode) {\r\n    if (mode == 'div' || !mode) {\r\n      var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\r\n      return {left: sc.column, top: sc.row};\r\n    }if (mode == 'local') {\r\n      var renderer = this.ace.renderer;\r\n      var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\r\n      var lh = renderer.layerConfig.lineHeight;\r\n      var cw = renderer.layerConfig.characterWidth;\r\n      var top = lh * sc.row;\r\n      return {left: sc.column * cw, top: top, bottom: top + lh};\r\n    }\r\n  };\r\n  this.coordsChar = function(pos, mode) {\r\n    var renderer = this.ace.renderer;\r\n    if (mode == 'local') {\r\n      var row = Math.max(0, Math.floor(pos.top / renderer.lineHeight));\r\n      var col = Math.max(0, Math.floor(pos.left / renderer.characterWidth));\r\n      var ch = renderer.session.screenToDocumentPosition(row, col);\r\n      return toCmPos(ch);\r\n    } else if (mode == 'div') {\r\n      throw \"not implemented\";\r\n    }\r\n  };\r\n  this.getSearchCursor = function(query, pos, caseFold) {\r\n    var caseSensitive = false;\r\n    var isRegexp = false;\r\n    if (query instanceof RegExp && !query.global) {\r\n      caseSensitive = !query.ignoreCase;\r\n      query = query.source;\r\n      isRegexp = true;\r\n    }\r\n    var search = new Search();\r\n    if (pos.ch == undefined) pos.ch = Number.MAX_VALUE;\r\n    var acePos = {row: pos.line, column: pos.ch};\r\n    var cm = this;\r\n    var last = null;\r\n    return {\r\n      findNext: function() { return this.find(false) },\r\n      findPrevious: function() {return this.find(true) },\r\n      find: function(back) {\r\n        search.setOptions({\r\n          needle: query,\r\n          caseSensitive: caseSensitive,\r\n          wrap: false,\r\n          backwards: back,\r\n          regExp: isRegexp,\r\n          start: last || acePos\r\n        });\r\n        var range = search.find(cm.ace.session);\r\n        if (range && range.isEmpty()) {\r\n          if (cm.getLine(range.start.row).length == range.start.column) {\r\n            search.$options.start = range;\r\n            range = search.find(cm.ace.session);\r\n          }\r\n        }\r\n        last = range;\r\n        return last;\r\n      },\r\n      from: function() { return last && toCmPos(last.start) },\r\n      to: function() { return last && toCmPos(last.end) },\r\n      replace: function(text) {\r\n        if (last) {\r\n          last.end = cm.ace.session.doc.replace(last, text);\r\n        }\r\n      }\r\n    };\r\n  };\r\n  this.scrollTo = function(x, y) {\r\n    var renderer = this.ace.renderer;\r\n    var config = renderer.layerConfig;\r\n    var maxHeight = config.maxHeight;\r\n    maxHeight -= (renderer.$size.scrollerHeight - renderer.lineHeight) * renderer.$scrollPastEnd;\r\n    if (y != null) this.ace.session.setScrollTop(Math.max(0, Math.min(y, maxHeight)));\r\n    if (x != null) this.ace.session.setScrollLeft(Math.max(0, Math.min(x, config.width)));\r\n  };\r\n  this.scrollInfo = function() { return 0; };\r\n  this.scrollIntoView = function(pos, margin) {\r\n    if (pos) {\r\n      var renderer = this.ace.renderer;\r\n      var viewMargin = { \"top\": 0, \"bottom\": margin };\r\n      renderer.scrollCursorIntoView(toAcePos(pos),\r\n        (renderer.lineHeight * 2) / renderer.$size.scrollerHeight, viewMargin);\r\n    }\r\n  };\r\n  this.getLine = function(row) { return this.ace.session.getLine(row) };\r\n  this.getRange = function(s, e) {\r\n    return this.ace.session.getTextRange(new Range(s.line, s.ch, e.line, e.ch));\r\n  };\r\n  this.replaceRange = function(text, s, e) {\r\n    if (!e) e = s;\r\n    return this.ace.session.replace(new Range(s.line, s.ch, e.line, e.ch), text);\r\n  };\r\n  this.replaceSelections = function(p) {\r\n    var sel = this.ace.selection;\r\n    if (this.ace.inVirtualSelectionMode) {\r\n      this.ace.session.replace(sel.getRange(), p[0] || \"\");\r\n      return;\r\n    }\r\n    sel.inVirtualSelectionMode = true;\r\n    var ranges = sel.rangeList.ranges;\r\n    if (!ranges.length) ranges = [this.ace.multiSelect.getRange()];\r\n    for (var i = ranges.length; i--;)\r\n       this.ace.session.replace(ranges[i], p[i] || \"\");\r\n    sel.inVirtualSelectionMode = false;\r\n  };\r\n  this.getSelection = function() {\r\n    return this.ace.getSelectedText();\r\n  };\r\n  this.getSelections = function() {\r\n    return this.listSelections().map(function(x) {\r\n      return this.getRange(x.anchor, x.head);\r\n    }, this);\r\n  };\r\n  this.getInputField = function() {\r\n    return this.ace.textInput.getElement();\r\n  };\r\n  this.getWrapperElement = function() {\r\n    return this.ace.container;\r\n  };\r\n  var optMap = {\r\n    indentWithTabs: \"useSoftTabs\",\r\n    indentUnit: \"tabSize\",\r\n    tabSize: \"tabSize\",\r\n    firstLineNumber: \"firstLineNumber\",\r\n    readOnly: \"readOnly\"\r\n  };\r\n  this.setOption = function(name, val) {\r\n    this.state[name] = val;\r\n    switch (name) {\r\n      case 'indentWithTabs':\r\n        name = optMap[name];\r\n        val = !val;\r\n      break;\r\n      default:\r\n        name = optMap[name];\r\n    }\r\n    if (name)\r\n      this.ace.setOption(name, val);\r\n  };\r\n  this.getOption = function(name, val) {\r\n    var aceOpt = optMap[name];\r\n    if (aceOpt)\r\n      val = this.ace.getOption(aceOpt);\r\n    switch (name) {\r\n      case 'indentWithTabs':\r\n        name = optMap[name];\r\n        return !val;\r\n    }\r\n    return aceOpt ? val : this.state[name];\r\n  };\r\n  this.toggleOverwrite = function(on) {\r\n    this.state.overwrite = on;\r\n    return this.ace.setOverwrite(on);\r\n  };\r\n  this.addOverlay = function(o) {\r\n    if (!this.$searchHighlight || !this.$searchHighlight.session) {\r\n      var highlight = new SearchHighlight(null, \"ace_highlight-marker\", \"text\");\r\n      var marker = this.ace.session.addDynamicMarker(highlight);\r\n      highlight.id = marker.id;\r\n      highlight.session = this.ace.session;\r\n      highlight.destroy = function(o) {\r\n        highlight.session.off(\"change\", highlight.updateOnChange);\r\n        highlight.session.off(\"changeEditor\", highlight.destroy);\r\n        highlight.session.removeMarker(highlight.id);\r\n        highlight.session = null;\r\n      };\r\n      highlight.updateOnChange = function(delta) {\r\n        var row = delta.start.row;\r\n        if (row == delta.end.row) highlight.cache[row] = undefined;\r\n        else highlight.cache.splice(row, highlight.cache.length);\r\n      };\r\n      highlight.session.on(\"changeEditor\", highlight.destroy);\r\n      highlight.session.on(\"change\", highlight.updateOnChange);\r\n    }\r\n    var re = new RegExp(o.query.source, \"gmi\");\r\n    this.$searchHighlight = o.highlight = highlight;\r\n    this.$searchHighlight.setRegexp(re);\r\n    this.ace.renderer.updateBackMarkers();\r\n  };\r\n  this.removeOverlay = function(o) {\r\n    if (this.$searchHighlight && this.$searchHighlight.session) {\r\n      this.$searchHighlight.destroy();\r\n    }\r\n  };\r\n  this.getScrollInfo = function() {\r\n    var renderer = this.ace.renderer;\r\n    var config = renderer.layerConfig;\r\n    return {\r\n      left: renderer.scrollLeft,\r\n      top: renderer.scrollTop,\r\n      height: config.maxHeight,\r\n      width: config.width,\r\n      clientHeight: config.height,\r\n      clientWidth: config.width\r\n    };\r\n  };\r\n  this.getValue = function() {\r\n    return this.ace.getValue();\r\n  };\r\n  this.setValue = function(v) {\r\n    return this.ace.setValue(v);\r\n  };\r\n  this.getTokenTypeAt = function(pos) {\r\n    var token = this.ace.session.getTokenAt(pos.line, pos.ch);\r\n    return token && /comment|string/.test(token.type) ? \"string\" : \"\";\r\n  };\r\n  this.findMatchingBracket = function(pos) {\r\n    var m = this.ace.session.findMatchingBracket(toAcePos(pos));\r\n    return {to: m && toCmPos(m)};\r\n  };\r\n  this.indentLine = function(line, method) {\r\n    if (method === true)\r\n        this.ace.session.indentRows(line, line, \"\\t\");\r\n    else if (method === false)\r\n        this.ace.session.outdentRows(new Range(line, 0, line, 0));\r\n  };\r\n  this.indexFromPos = function(pos) {\r\n    return this.ace.session.doc.positionToIndex(toAcePos(pos));\r\n  };\r\n  this.posFromIndex = function(index) {\r\n    return toCmPos(this.ace.session.doc.indexToPosition(index));\r\n  };\r\n  this.focus = function(index) {\r\n    return this.ace.textInput.focus();\r\n  };\r\n  this.blur = function(index) {\r\n    return this.ace.blur();\r\n  };\r\n  this.defaultTextHeight = function(index) {\r\n    return this.ace.renderer.layerConfig.lineHeight;\r\n  };\r\n  this.scanForBracket = function(pos, dir, _, options) {\r\n    var re = options.bracketRegex.source;\r\n    var tokenRe = /paren|text|operator|tag/;\r\n    if (dir == 1) {\r\n      var m = this.ace.session.$findClosingBracket(re.slice(1, 2), toAcePos(pos), tokenRe);\r\n    } else {\r\n      var m = this.ace.session.$findOpeningBracket(re.slice(-2, -1), {row: pos.line, column: pos.ch + 1}, tokenRe);\r\n    }\r\n    return m && {pos: toCmPos(m)};\r\n  };\r\n  this.refresh = function() {\r\n    return this.ace.resize(true);\r\n  };\r\n  this.getMode = function() {\r\n    return { name : this.getOption(\"mode\") };\r\n  }\r\n}).call(CodeMirror.prototype);\r\n  function toAcePos(cmPos) {\r\n    return {row: cmPos.line, column: cmPos.ch};\r\n  }\r\n  function toCmPos(acePos) {\r\n    return new Pos(acePos.row, acePos.column);\r\n  }\r\n\r\n  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\r\n    this.pos = this.start = 0;\r\n    this.string = string;\r\n    this.tabSize = tabSize || 8;\r\n    this.lastColumnPos = this.lastColumnValue = 0;\r\n    this.lineStart = 0;\r\n  };\r\n\r\n  StringStream.prototype = {\r\n    eol: function() {return this.pos >= this.string.length;},\r\n    sol: function() {return this.pos == this.lineStart;},\r\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\r\n    next: function() {\r\n      if (this.pos < this.string.length)\r\n        return this.string.charAt(this.pos++);\r\n    },\r\n    eat: function(match) {\r\n      var ch = this.string.charAt(this.pos);\r\n      if (typeof match == \"string\") var ok = ch == match;\r\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\r\n      if (ok) {++this.pos; return ch;}\r\n    },\r\n    eatWhile: function(match) {\r\n      var start = this.pos;\r\n      while (this.eat(match)){}\r\n      return this.pos > start;\r\n    },\r\n    eatSpace: function() {\r\n      var start = this.pos;\r\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\r\n      return this.pos > start;\r\n    },\r\n    skipToEnd: function() {this.pos = this.string.length;},\r\n    skipTo: function(ch) {\r\n      var found = this.string.indexOf(ch, this.pos);\r\n      if (found > -1) {this.pos = found; return true;}\r\n    },\r\n    backUp: function(n) {this.pos -= n;},\r\n    column: function() {\r\n      throw \"not implemented\";\r\n    },\r\n    indentation: function() {\r\n      throw \"not implemented\";\r\n    },\r\n    match: function(pattern, consume, caseInsensitive) {\r\n      if (typeof pattern == \"string\") {\r\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\r\n        var substr = this.string.substr(this.pos, pattern.length);\r\n        if (cased(substr) == cased(pattern)) {\r\n          if (consume !== false) this.pos += pattern.length;\r\n          return true;\r\n        }\r\n      } else {\r\n        var match = this.string.slice(this.pos).match(pattern);\r\n        if (match && match.index > 0) return null;\r\n        if (match && consume !== false) this.pos += match[0].length;\r\n        return match;\r\n      }\r\n    },\r\n    current: function(){return this.string.slice(this.start, this.pos);},\r\n    hideFirstChars: function(n, inner) {\r\n      this.lineStart += n;\r\n      try { return inner(); }\r\n      finally { this.lineStart -= n; }\r\n    }\r\n  };\r\n\r\n// todo replace with showCommandLine\r\nCodeMirror.defineExtension = function(name, fn) {\r\n  CodeMirror.prototype[name] = fn;\r\n};\r\ndom.importCssString(\".normal-mode .ace_cursor{\\\r\n    border: none;\\\r\n    background-color: rgba(255,0,0,0.5);\\\r\n}\\\r\n.normal-mode .ace_hidden-cursors .ace_cursor{\\\r\n  background-color: transparent;\\\r\n  border: 1px solid red;\\\r\n  opacity: 0.7\\\r\n}\\\r\n.ace_dialog {\\\r\n  position: absolute;\\\r\n  left: 0; right: 0;\\\r\n  background: inherit;\\\r\n  z-index: 15;\\\r\n  padding: .1em .8em;\\\r\n  overflow: hidden;\\\r\n  color: inherit;\\\r\n}\\\r\n.ace_dialog-top {\\\r\n  border-bottom: 1px solid #444;\\\r\n  top: 0;\\\r\n}\\\r\n.ace_dialog-bottom {\\\r\n  border-top: 1px solid #444;\\\r\n  bottom: 0;\\\r\n}\\\r\n.ace_dialog input {\\\r\n  border: none;\\\r\n  outline: none;\\\r\n  background: transparent;\\\r\n  width: 20em;\\\r\n  color: inherit;\\\r\n  font-family: monospace;\\\r\n}\", \"vimMode\");\r\n(function() {\r\n  function dialogDiv(cm, template, bottom) {\r\n    var wrap = cm.ace.container;\r\n    var dialog;\r\n    dialog = wrap.appendChild(document.createElement(\"div\"));\r\n    if (bottom)\r\n      dialog.className = \"ace_dialog ace_dialog-bottom\";\r\n    else\r\n      dialog.className = \"ace_dialog ace_dialog-top\";\r\n\r\n    if (typeof template == \"string\") {\r\n      dialog.innerHTML = template;\r\n    } else { // Assuming it's a detached DOM element.\r\n      dialog.appendChild(template);\r\n    }\r\n    return dialog;\r\n  }\r\n\r\n  function closeNotification(cm, newVal) {\r\n    if (cm.state.currentNotificationClose)\r\n      cm.state.currentNotificationClose();\r\n    cm.state.currentNotificationClose = newVal;\r\n  }\r\n\r\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\r\n    if (this.virtualSelectionMode()) return;\r\n    if (!options) options = {};\r\n\r\n    closeNotification(this, null);\r\n\r\n    var dialog = dialogDiv(this, template, options.bottom);\r\n    var closed = false, me = this;\r\n    this.state.dialog = dialog;\r\n    function close(newVal) {\r\n      if (typeof newVal == 'string') {\r\n        inp.value = newVal;\r\n      } else {\r\n        if (closed) return;\r\n        \r\n        if (newVal && newVal.type == \"blur\") {\r\n          if (document.activeElement === inp)\r\n            return;\r\n        }\r\n        \r\n        me.state.dialog = null;\r\n        closed = true;\r\n        dialog.parentNode.removeChild(dialog);\r\n        me.focus();\r\n\r\n        if (options.onClose) options.onClose(dialog);\r\n      }\r\n    }\r\n\r\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\r\n    if (inp) {\r\n      if (options.value) {\r\n        inp.value = options.value;\r\n        if (options.selectValueOnOpen !== false) inp.select();\r\n      }\r\n\r\n      if (options.onInput)\r\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\r\n      if (options.onKeyUp)\r\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\r\n\r\n      CodeMirror.on(inp, \"keydown\", function(e) {\r\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }\r\n        if (e.keyCode == 13) callback(inp.value);\r\n        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\r\n          inp.blur();\r\n          CodeMirror.e_stop(e);\r\n          close();\r\n        }\r\n      });\r\n\r\n      if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\r\n\r\n      inp.focus();\r\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\r\n      CodeMirror.on(button, \"click\", function() {\r\n        close();\r\n        me.focus();\r\n      });\r\n\r\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\r\n\r\n      button.focus();\r\n    }\r\n    return close;\r\n  });\r\n\r\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\r\n    if (this.virtualSelectionMode()) return;\r\n    closeNotification(this, close);\r\n    var dialog = dialogDiv(this, template, options && options.bottom);\r\n    var closed = false, doneTimer;\r\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\r\n\r\n    function close() {\r\n      if (closed) return;\r\n      closed = true;\r\n      clearTimeout(doneTimer);\r\n      dialog.parentNode.removeChild(dialog);\r\n    }\r\n\r\n    CodeMirror.on(dialog, 'click', function(e) {\r\n      CodeMirror.e_preventDefault(e);\r\n      close();\r\n    });\r\n\r\n    if (duration)\r\n      doneTimer = setTimeout(close, duration);\r\n\r\n    return close;\r\n  });\r\n})();\r\n\r\n  \r\n  var defaultKeymap = [\r\n    // Key to key mapping. This goes first to make it possible to override\r\n    // existing mappings.\r\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\r\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\r\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\r\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\r\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\r\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\r\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\r\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\r\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\r\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\r\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\r\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\r\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\r\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\r\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\r\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\r\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\r\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\r\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\r\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\r\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\r\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\r\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\r\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\r\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\r\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\r\n    // Motions\r\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\r\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\r\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\r\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\r\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\r\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\r\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\r\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\r\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\r\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\r\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\r\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\r\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\r\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\r\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\r\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\r\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\r\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\r\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\r\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\r\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\r\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\r\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\r\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\r\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\r\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\r\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\r\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\r\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\r\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\r\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\r\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\r\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\r\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\r\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\r\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\r\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\r\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\r\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\r\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\r\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\r\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\r\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\r\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\r\n    // the next two aren't motions but must come before more general motion declarations\r\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\r\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\r\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\r\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\r\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\r\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\r\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\r\n    // Operators\r\n    { keys: 'd', type: 'operator', operator: 'delete' },\r\n    { keys: 'y', type: 'operator', operator: 'yank' },\r\n    { keys: 'c', type: 'operator', operator: 'change' },\r\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\r\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\r\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\r\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\r\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\r\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\r\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\r\n    // Operator-Motion dual commands\r\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\r\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\r\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\r\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\r\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\r\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\r\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\r\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\r\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\r\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\r\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\r\n    // Actions\r\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\r\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\r\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\r\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\r\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\r\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\r\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\r\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\r\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\r\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\r\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\r\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\r\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\r\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\r\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\r\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\r\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\r\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\r\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\r\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\r\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\r\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\r\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\r\n    // Handle Replace-mode as a special case of insert mode.\r\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }},\r\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\r\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\r\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\r\n    { keys: '<C-r>', type: 'action', action: 'redo' },\r\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\r\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\r\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\r\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\r\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\r\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\r\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\r\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\r\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\r\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\r\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\r\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\r\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\r\n    // Text object motions\r\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\r\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\r\n    // Search\r\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\r\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\r\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\r\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\r\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\r\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\r\n    // Ex command\r\n    { keys: ':', type: 'ex' }\r\n  ];\r\n\r\n  /**\r\n   * Ex commands\r\n   * Care must be taken when adding to the default Ex command map. For any\r\n   * pair of commands that have a shared prefix, at least one of their\r\n   * shortNames must not match the prefix of the other command.\r\n   */\r\n  var defaultExCommandMap = [\r\n    { name: 'colorscheme', shortName: 'colo' },\r\n    { name: 'map' },\r\n    { name: 'imap', shortName: 'im' },\r\n    { name: 'nmap', shortName: 'nm' },\r\n    { name: 'vmap', shortName: 'vm' },\r\n    { name: 'unmap' },\r\n    { name: 'write', shortName: 'w' },\r\n    { name: 'undo', shortName: 'u' },\r\n    { name: 'redo', shortName: 'red' },\r\n    { name: 'set', shortName: 'se' },\r\n    { name: 'set', shortName: 'se' },\r\n    { name: 'setlocal', shortName: 'setl' },\r\n    { name: 'setglobal', shortName: 'setg' },\r\n    { name: 'sort', shortName: 'sor' },\r\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\r\n    { name: 'nohlsearch', shortName: 'noh' },\r\n    { name: 'yank', shortName: 'y' },\r\n    { name: 'delmarks', shortName: 'delm' },\r\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\r\n    { name: 'global', shortName: 'g' }\r\n  ];\r\n\r\n  var Pos = CodeMirror.Pos;\r\n\r\n  var Vim = function() { return vimApi; } //{\r\n    function enterVimMode(cm) {\r\n      cm.setOption('disableInput', true);\r\n      cm.setOption('showCursorWhenSelecting', false);\r\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\r\n      cm.on('cursorActivity', onCursorActivity);\r\n      maybeInitVimState(cm);\r\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\r\n    }\r\n\r\n    function leaveVimMode(cm) {\r\n      cm.setOption('disableInput', false);\r\n      cm.off('cursorActivity', onCursorActivity);\r\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\r\n      cm.state.vim = null;\r\n    }\r\n\r\n    function detachVimMap(cm, next) {\r\n      if (this == CodeMirror.keyMap.vim)\r\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\r\n\r\n      if (!next || next.attach != attachVimMap)\r\n        leaveVimMode(cm);\r\n    }\r\n    function attachVimMap(cm, prev) {\r\n      if (this == CodeMirror.keyMap.vim)\r\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\r\n\r\n      if (!prev || prev.attach != attachVimMap)\r\n        enterVimMode(cm);\r\n    }\r\n\r\n    // Deprecated, simply setting the keymap works again.\r\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\r\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\r\n        cm.setOption(\"keyMap\", \"vim\");\r\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\r\n        cm.setOption(\"keyMap\", \"default\");\r\n    });\r\n\r\n    function cmKey(key, cm) {\r\n      if (!cm) { return undefined; }\r\n      if (this[key]) { return this[key]; }\r\n      var vimKey = cmKeyToVimKey(key);\r\n      if (!vimKey) {\r\n        return false;\r\n      }\r\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\r\n      if (typeof cmd == 'function') {\r\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\r\n      }\r\n      return cmd;\r\n    }\r\n\r\n    var modifiers = {'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A'};\r\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\r\n    function cmKeyToVimKey(key) {\r\n      if (key.charAt(0) == '\\'') {\r\n        // Keypress character binding of format \"'a'\"\r\n        return key.charAt(1);\r\n      }\r\n      var pieces = key.split(/-(?!$)/);\r\n      var lastPiece = pieces[pieces.length - 1];\r\n      if (pieces.length == 1 && pieces[0].length == 1) {\r\n        // No-modifier bindings use literal character bindings above. Skip.\r\n        return false;\r\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\r\n        // Ignore Shift+char bindings as they should be handled by literal character.\r\n        return false;\r\n      }\r\n      var hasCharacter = false;\r\n      for (var i = 0; i < pieces.length; i++) {\r\n        var piece = pieces[i];\r\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\r\n        else { hasCharacter = true; }\r\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\r\n      }\r\n      if (!hasCharacter) {\r\n        // Vim does not support modifier only keys.\r\n        return false;\r\n      }\r\n      // TODO: Current bindings expect the character to be lower case, but\r\n      // it looks like vim key notation uses upper case.\r\n      if (isUpperCase(lastPiece)) {\r\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\r\n      }\r\n      return '<' + pieces.join('-') + '>';\r\n    }\r\n\r\n    function getOnPasteFn(cm) {\r\n      var vim = cm.state.vim;\r\n      if (!vim.onPasteFn) {\r\n        vim.onPasteFn = function() {\r\n          if (!vim.insertMode) {\r\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\r\n            actions.enterInsertMode(cm, {}, vim);\r\n          }\r\n        };\r\n      }\r\n      return vim.onPasteFn;\r\n    }\r\n\r\n    var numberRegex = /[\\d]/;\r\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\r\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\r\n    }], bigWordCharTest = [function(ch) {\r\n      return /\\S/.test(ch);\r\n    }];\r\n    function makeKeyRange(start, size) {\r\n      var keys = [];\r\n      for (var i = start; i < start + size; i++) {\r\n        keys.push(String.fromCharCode(i));\r\n      }\r\n      return keys;\r\n    }\r\n    var upperCaseAlphabet = makeKeyRange(65, 26);\r\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\r\n    var numbers = makeKeyRange(48, 10);\r\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\r\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\r\n\r\n    function isLine(cm, line) {\r\n      return line >= cm.firstLine() && line <= cm.lastLine();\r\n    }\r\n    function isLowerCase(k) {\r\n      return (/^[a-z]$/).test(k);\r\n    }\r\n    function isMatchableSymbol(k) {\r\n      return '()[]{}'.indexOf(k) != -1;\r\n    }\r\n    function isNumber(k) {\r\n      return numberRegex.test(k);\r\n    }\r\n    function isUpperCase(k) {\r\n      return (/^[A-Z]$/).test(k);\r\n    }\r\n    function isWhiteSpaceString(k) {\r\n      return (/^\\s*$/).test(k);\r\n    }\r\n    function inArray(val, arr) {\r\n      for (var i = 0; i < arr.length; i++) {\r\n        if (arr[i] == val) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    var options = {};\r\n    function defineOption(name, defaultValue, type, aliases, callback) {\r\n      if (defaultValue === undefined && !callback) {\r\n        throw Error('defaultValue is required unless callback is provided');\r\n      }\r\n      if (!type) { type = 'string'; }\r\n      options[name] = {\r\n        type: type,\r\n        defaultValue: defaultValue,\r\n        callback: callback\r\n      };\r\n      if (aliases) {\r\n        for (var i = 0; i < aliases.length; i++) {\r\n          options[aliases[i]] = options[name];\r\n        }\r\n      }\r\n      if (defaultValue) {\r\n        setOption(name, defaultValue);\r\n      }\r\n    }\r\n\r\n    function setOption(name, value, cm, cfg) {\r\n      var option = options[name];\r\n      cfg = cfg || {};\r\n      var scope = cfg.scope;\r\n      if (!option) {\r\n        return new Error('Unknown option: ' + name);\r\n      }\r\n      if (option.type == 'boolean') {\r\n        if (value && value !== true) {\r\n          return new Error('Invalid argument: ' + name + '=' + value);\r\n        } else if (value !== false) {\r\n          // Boolean options are set to true if value is not defined.\r\n          value = true;\r\n        }\r\n      }\r\n      if (option.callback) {\r\n        if (scope !== 'local') {\r\n          option.callback(value, undefined);\r\n        }\r\n        if (scope !== 'global' && cm) {\r\n          option.callback(value, cm);\r\n        }\r\n      } else {\r\n        if (scope !== 'local') {\r\n          option.value = option.type == 'boolean' ? !!value : value;\r\n        }\r\n        if (scope !== 'global' && cm) {\r\n          cm.state.vim.options[name] = {value: value};\r\n        }\r\n      }\r\n    }\r\n\r\n    function getOption(name, cm, cfg) {\r\n      var option = options[name];\r\n      cfg = cfg || {};\r\n      var scope = cfg.scope;\r\n      if (!option) {\r\n        return new Error('Unknown option: ' + name);\r\n      }\r\n      if (option.callback) {\r\n        var local = cm && option.callback(undefined, cm);\r\n        if (scope !== 'global' && local !== undefined) {\r\n          return local;\r\n        }\r\n        if (scope !== 'local') {\r\n          return option.callback();\r\n        }\r\n        return;\r\n      } else {\r\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\r\n        return (local || (scope !== 'local') && option || {}).value;\r\n      }\r\n    }\r\n\r\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\r\n      // Option is local. Do nothing for global.\r\n      if (cm === undefined) {\r\n        return;\r\n      }\r\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\r\n      if (name === undefined) {\r\n        var mode = cm.getOption('mode');\r\n        return mode == 'null' ? '' : mode;\r\n      } else {\r\n        var mode = name == '' ? 'null' : name;\r\n        cm.setOption('mode', mode);\r\n      }\r\n    });\r\n\r\n    var createCircularJumpList = function() {\r\n      var size = 100;\r\n      var pointer = -1;\r\n      var head = 0;\r\n      var tail = 0;\r\n      var buffer = new Array(size);\r\n      function add(cm, oldCur, newCur) {\r\n        var current = pointer % size;\r\n        var curMark = buffer[current];\r\n        function useNextSlot(cursor) {\r\n          var next = ++pointer % size;\r\n          var trashMark = buffer[next];\r\n          if (trashMark) {\r\n            trashMark.clear();\r\n          }\r\n          buffer[next] = cm.setBookmark(cursor);\r\n        }\r\n        if (curMark) {\r\n          var markPos = curMark.find();\r\n          // avoid recording redundant cursor position\r\n          if (markPos && !cursorEqual(markPos, oldCur)) {\r\n            useNextSlot(oldCur);\r\n          }\r\n        } else {\r\n          useNextSlot(oldCur);\r\n        }\r\n        useNextSlot(newCur);\r\n        head = pointer;\r\n        tail = pointer - size + 1;\r\n        if (tail < 0) {\r\n          tail = 0;\r\n        }\r\n      }\r\n      function move(cm, offset) {\r\n        pointer += offset;\r\n        if (pointer > head) {\r\n          pointer = head;\r\n        } else if (pointer < tail) {\r\n          pointer = tail;\r\n        }\r\n        var mark = buffer[(size + pointer) % size];\r\n        // skip marks that are temporarily removed from text buffer\r\n        if (mark && !mark.find()) {\r\n          var inc = offset > 0 ? 1 : -1;\r\n          var newCur;\r\n          var oldCur = cm.getCursor();\r\n          do {\r\n            pointer += inc;\r\n            mark = buffer[(size + pointer) % size];\r\n            // skip marks that are the same as current position\r\n            if (mark &&\r\n                (newCur = mark.find()) &&\r\n                !cursorEqual(oldCur, newCur)) {\r\n              break;\r\n            }\r\n          } while (pointer < head && pointer > tail);\r\n        }\r\n        return mark;\r\n      }\r\n      return {\r\n        cachedCursor: undefined, //used for # and * jumps\r\n        add: add,\r\n        move: move\r\n      };\r\n    };\r\n\r\n    // Returns an object to track the changes associated insert mode.  It\r\n    // clones the object that is passed in, or creates an empty object one if\r\n    // none is provided.\r\n    var createInsertModeChanges = function(c) {\r\n      if (c) {\r\n        // Copy construction\r\n        return {\r\n          changes: c.changes,\r\n          expectCursorActivityForChange: c.expectCursorActivityForChange\r\n        };\r\n      }\r\n      return {\r\n        // Change list\r\n        changes: [],\r\n        // Set to true on change, false on cursorActivity.\r\n        expectCursorActivityForChange: false\r\n      };\r\n    };\r\n\r\n    function MacroModeState() {\r\n      this.latestRegister = undefined;\r\n      this.isPlaying = false;\r\n      this.isRecording = false;\r\n      this.replaySearchQueries = [];\r\n      this.onRecordingDone = undefined;\r\n      this.lastInsertModeChanges = createInsertModeChanges();\r\n    }\r\n    MacroModeState.prototype = {\r\n      exitMacroRecordMode: function() {\r\n        var macroModeState = vimGlobalState.macroModeState;\r\n        if (macroModeState.onRecordingDone) {\r\n          macroModeState.onRecordingDone(); // close dialog\r\n        }\r\n        macroModeState.onRecordingDone = undefined;\r\n        macroModeState.isRecording = false;\r\n      },\r\n      enterMacroRecordMode: function(cm, registerName) {\r\n        var register =\r\n            vimGlobalState.registerController.getRegister(registerName);\r\n        if (register) {\r\n          register.clear();\r\n          this.latestRegister = registerName;\r\n          if (cm.openDialog) {\r\n            this.onRecordingDone = cm.openDialog(\r\n                '(recording)['+registerName+']', null, {bottom:true});\r\n          }\r\n          this.isRecording = true;\r\n        }\r\n      }\r\n    };\r\n\r\n    function maybeInitVimState(cm) {\r\n      if (!cm.state.vim) {\r\n        // Store instance state in the CodeMirror object.\r\n        cm.state.vim = {\r\n          inputState: new InputState(),\r\n          // Vim's input state that triggered the last edit, used to repeat\r\n          // motions and operators with '.'.\r\n          lastEditInputState: undefined,\r\n          // Vim's action command before the last edit, used to repeat actions\r\n          // with '.' and insert mode repeat.\r\n          lastEditActionCommand: undefined,\r\n          // When using jk for navigation, if you move from a longer line to a\r\n          // shorter line, the cursor may clip to the end of the shorter line.\r\n          // If j is pressed again and cursor goes to the next line, the\r\n          // cursor should go back to its horizontal position on the longer\r\n          // line if it can. This is to keep track of the horizontal position.\r\n          lastHPos: -1,\r\n          // Doing the same with screen-position for gj/gk\r\n          lastHSPos: -1,\r\n          // The last motion command run. Cleared if a non-motion command gets\r\n          // executed in between.\r\n          lastMotion: null,\r\n          marks: {},\r\n          // Mark for rendering fake cursor for visual mode.\r\n          fakeCursor: null,\r\n          insertMode: false,\r\n          // Repeat count for changes made in insert mode, triggered by key\r\n          // sequences like 3,i. Only exists when insertMode is true.\r\n          insertModeRepeat: undefined,\r\n          visualMode: false,\r\n          // If we are in visual line mode. No effect if visualMode is false.\r\n          visualLine: false,\r\n          visualBlock: false,\r\n          lastSelection: null,\r\n          lastPastedText: null,\r\n          sel: {},\r\n          // Buffer-local/window-local values of vim options.\r\n          options: {}\r\n        };\r\n      }\r\n      return cm.state.vim;\r\n    }\r\n    var vimGlobalState;\r\n    function resetVimGlobalState() {\r\n      vimGlobalState = {\r\n        // The current search query.\r\n        searchQuery: null,\r\n        // Whether we are searching backwards.\r\n        searchIsReversed: false,\r\n        // Replace part of the last substituted pattern\r\n        lastSubstituteReplacePart: undefined,\r\n        jumpList: createCircularJumpList(),\r\n        macroModeState: new MacroModeState,\r\n        // Recording latest f, t, F or T motion command.\r\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\r\n        registerController: new RegisterController({}),\r\n        // search history buffer\r\n        searchHistoryController: new HistoryController(),\r\n        // ex Command history buffer\r\n        exCommandHistoryController : new HistoryController()\r\n      };\r\n      for (var optionName in options) {\r\n        var option = options[optionName];\r\n        option.value = option.defaultValue;\r\n      }\r\n    }\r\n\r\n    var lastInsertModeKeyTimer;\r\n    var vimApi= {\r\n      buildKeyMap: function() {\r\n        // TODO: Convert keymap into dictionary format for fast lookup.\r\n      },\r\n      // Testing hook, though it might be useful to expose the register\r\n      // controller anyways.\r\n      getRegisterController: function() {\r\n        return vimGlobalState.registerController;\r\n      },\r\n      // Testing hook.\r\n      resetVimGlobalState_: resetVimGlobalState,\r\n\r\n      // Testing hook.\r\n      getVimGlobalState_: function() {\r\n        return vimGlobalState;\r\n      },\r\n\r\n      // Testing hook.\r\n      maybeInitVimState_: maybeInitVimState,\r\n\r\n      suppressErrorLogging: false,\r\n\r\n      InsertModeKey: InsertModeKey,\r\n      map: function(lhs, rhs, ctx) {\r\n        // Add user defined key bindings.\r\n        exCommandDispatcher.map(lhs, rhs, ctx);\r\n      },\r\n      unmap: function(lhs, ctx) {\r\n        exCommandDispatcher.unmap(lhs, ctx);\r\n      },\r\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\r\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\r\n      setOption: setOption,\r\n      getOption: getOption,\r\n      defineOption: defineOption,\r\n      defineEx: function(name, prefix, func){\r\n        if (!prefix) {\r\n          prefix = name;\r\n        } else if (name.indexOf(prefix) !== 0) {\r\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\r\n        }\r\n        exCommands[name]=func;\r\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\r\n      },\r\n      handleKey: function (cm, key, origin) {\r\n        var command = this.findKey(cm, key, origin);\r\n        if (typeof command === 'function') {\r\n          return command();\r\n        }\r\n      },\r\n      /**\r\n       * This is the outermost function called by CodeMirror, after keys have\r\n       * been mapped to their Vim equivalents.\r\n       *\r\n       * Finds a command based on the key (and cached keys if there is a\r\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\r\n       * function if a partial match is found (multi-key), and a function to\r\n       * execute the bound command if a a key is matched. The function always\r\n       * returns true.\r\n       */\r\n      findKey: function(cm, key, origin) {\r\n        var vim = maybeInitVimState(cm);\r\n        function handleMacroRecording() {\r\n          var macroModeState = vimGlobalState.macroModeState;\r\n          if (macroModeState.isRecording) {\r\n            if (key == 'q') {\r\n              macroModeState.exitMacroRecordMode();\r\n              clearInputState(cm);\r\n              return true;\r\n            }\r\n            if (origin != 'mapping') {\r\n              logKey(macroModeState, key);\r\n            }\r\n          }\r\n        }\r\n        function handleEsc() {\r\n          if (key == '<Esc>') {\r\n            // Clear input state and get back to normal mode.\r\n            clearInputState(cm);\r\n            if (vim.visualMode) {\r\n              exitVisualMode(cm);\r\n            } else if (vim.insertMode) {\r\n              exitInsertMode(cm);\r\n            }\r\n            return true;\r\n          }\r\n        }\r\n        function doKeyToKey(keys) {\r\n          // TODO: prevent infinite recursion.\r\n          var match;\r\n          while (keys) {\r\n            // Pull off one command key, which is either a single character\r\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\r\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\r\n            key = match[0];\r\n            keys = keys.substring(match.index + key.length);\r\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\r\n          }\r\n        }\r\n\r\n        function handleKeyInsertMode() {\r\n          if (handleEsc()) { return true; }\r\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\r\n          var keysAreChars = key.length == 1;\r\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\r\n          // Need to check all key substrings in insert mode.\r\n          while (keys.length > 1 && match.type != 'full') {\r\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\r\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\r\n            if (thisMatch.type != 'none') { match = thisMatch; }\r\n          }\r\n          if (match.type == 'none') { clearInputState(cm); return false; }\r\n          else if (match.type == 'partial') {\r\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\r\n            lastInsertModeKeyTimer = window.setTimeout(\r\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\r\n              getOption('insertModeEscKeysTimeout'));\r\n            return !keysAreChars;\r\n          }\r\n\r\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\r\n          if (keysAreChars) {\r\n            var selections = cm.listSelections();\r\n            for (var i = 0; i < selections.length; i++) {\r\n              var here = selections[i].head;\r\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\r\n            }\r\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\r\n          }\r\n          clearInputState(cm);\r\n          return match.command;\r\n        }\r\n\r\n        function handleKeyNonInsertMode() {\r\n          if (handleMacroRecording() || handleEsc()) { return true; }\r\n\r\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\r\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\r\n\r\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\r\n          if (!keysMatcher) { clearInputState(cm); return false; }\r\n          var context = vim.visualMode ? 'visual' :\r\n                                         'normal';\r\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\r\n          if (match.type == 'none') { clearInputState(cm); return false; }\r\n          else if (match.type == 'partial') { return true; }\r\n\r\n          vim.inputState.keyBuffer = '';\r\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\r\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\r\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\r\n          }\r\n          return match.command;\r\n        }\r\n\r\n        var command;\r\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\r\n        else { command = handleKeyNonInsertMode(); }\r\n        if (command === false) {\r\n          return undefined;\r\n        } else if (command === true) {\r\n          // TODO: Look into using CodeMirror's multi-key handling.\r\n          // Return no-op since we are caching the key. Counts as handled, but\r\n          // don't want act on it just yet.\r\n          return function() { return true; };\r\n        } else {\r\n          return function() {\r\n            if ((command.operator || command.isEdit) && cm.getOption('readOnly'))\r\n              return; // ace_patch\r\n            return cm.operation(function() {\r\n              cm.curOp.isVimOp = true;\r\n              try {\r\n                if (command.type == 'keyToKey') {\r\n                  doKeyToKey(command.toKeys);\r\n                } else {\r\n                  commandDispatcher.processCommand(cm, vim, command);\r\n                }\r\n              } catch (e) {\r\n                // clear VIM state in case it's in a bad state.\r\n                cm.state.vim = undefined;\r\n                maybeInitVimState(cm);\r\n                if (!CodeMirror.Vim.suppressErrorLogging) {\r\n                  console['log'](e);\r\n                }\r\n                throw e;\r\n              }\r\n              return true;\r\n            });\r\n          };\r\n        }\r\n      },\r\n      handleEx: function(cm, input) {\r\n        exCommandDispatcher.processCommand(cm, input);\r\n      },\r\n\r\n      defineMotion: defineMotion,\r\n      defineAction: defineAction,\r\n      defineOperator: defineOperator,\r\n      mapCommand: mapCommand,\r\n      _mapCommand: _mapCommand,\r\n\r\n      defineRegister: defineRegister,\r\n\r\n      exitVisualMode: exitVisualMode,\r\n      exitInsertMode: exitInsertMode\r\n    };\r\n\r\n    // Represents the current input state.\r\n    function InputState() {\r\n      this.prefixRepeat = [];\r\n      this.motionRepeat = [];\r\n\r\n      this.operator = null;\r\n      this.operatorArgs = null;\r\n      this.motion = null;\r\n      this.motionArgs = null;\r\n      this.keyBuffer = []; // For matching multi-key commands.\r\n      this.registerName = null; // Defaults to the unnamed register.\r\n    }\r\n    InputState.prototype.pushRepeatDigit = function(n) {\r\n      if (!this.operator) {\r\n        this.prefixRepeat = this.prefixRepeat.concat(n);\r\n      } else {\r\n        this.motionRepeat = this.motionRepeat.concat(n);\r\n      }\r\n    };\r\n    InputState.prototype.getRepeat = function() {\r\n      var repeat = 0;\r\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\r\n        repeat = 1;\r\n        if (this.prefixRepeat.length > 0) {\r\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\r\n        }\r\n        if (this.motionRepeat.length > 0) {\r\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\r\n        }\r\n      }\r\n      return repeat;\r\n    };\r\n\r\n    function clearInputState(cm, reason) {\r\n      cm.state.vim.inputState = new InputState();\r\n      CodeMirror.signal(cm, 'vim-command-done', reason);\r\n    }\r\n\r\n    /*\r\n     * Register stores information about copy and paste registers.  Besides\r\n     * text, a register must store whether it is linewise (i.e., when it is\r\n     * pasted, should it insert itself into a new line, or should the text be\r\n     * inserted at the cursor position.)\r\n     */\r\n    function Register(text, linewise, blockwise) {\r\n      this.clear();\r\n      this.keyBuffer = [text || ''];\r\n      this.insertModeChanges = [];\r\n      this.searchQueries = [];\r\n      this.linewise = !!linewise;\r\n      this.blockwise = !!blockwise;\r\n    }\r\n    Register.prototype = {\r\n      setText: function(text, linewise, blockwise) {\r\n        this.keyBuffer = [text || ''];\r\n        this.linewise = !!linewise;\r\n        this.blockwise = !!blockwise;\r\n      },\r\n      pushText: function(text, linewise) {\r\n        // if this register has ever been set to linewise, use linewise.\r\n        if (linewise) {\r\n          if (!this.linewise) {\r\n            this.keyBuffer.push('\\n');\r\n          }\r\n          this.linewise = true;\r\n        }\r\n        this.keyBuffer.push(text);\r\n      },\r\n      pushInsertModeChanges: function(changes) {\r\n        this.insertModeChanges.push(createInsertModeChanges(changes));\r\n      },\r\n      pushSearchQuery: function(query) {\r\n        this.searchQueries.push(query);\r\n      },\r\n      clear: function() {\r\n        this.keyBuffer = [];\r\n        this.insertModeChanges = [];\r\n        this.searchQueries = [];\r\n        this.linewise = false;\r\n      },\r\n      toString: function() {\r\n        return this.keyBuffer.join('');\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Defines an external register.\r\n     *\r\n     * The name should be a single character that will be used to reference the register.\r\n     * The register should support setText, pushText, clear, and toString(). See Register\r\n     * for a reference implementation.\r\n     */\r\n    function defineRegister(name, register) {\r\n      var registers = vimGlobalState.registerController.registers;\r\n      if (!name || name.length != 1) {\r\n        throw Error('Register name must be 1 character');\r\n      }\r\n      // ace_patch\r\n      registers[name] = register;\r\n      validRegisters.push(name);\r\n    }\r\n\r\n    /*\r\n     * vim registers allow you to keep many independent copy and paste buffers.\r\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\r\n     *\r\n     * RegisterController keeps the state of all the registers.  An initial\r\n     * state may be passed in.  The unnamed register '\"' will always be\r\n     * overridden.\r\n     */\r\n    function RegisterController(registers) {\r\n      this.registers = registers;\r\n      this.unnamedRegister = registers['\"'] = new Register();\r\n      registers['.'] = new Register();\r\n      registers[':'] = new Register();\r\n      registers['/'] = new Register();\r\n    }\r\n    RegisterController.prototype = {\r\n      pushText: function(registerName, operator, text, linewise, blockwise) {\r\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\r\n          text += '\\n';\r\n        }\r\n        // Lowercase and uppercase registers refer to the same register.\r\n        // Uppercase just means append.\r\n        var register = this.isValidRegister(registerName) ?\r\n            this.getRegister(registerName) : null;\r\n        // if no register/an invalid register was specified, things go to the\r\n        // default registers\r\n        if (!register) {\r\n          switch (operator) {\r\n            case 'yank':\r\n              // The 0 register contains the text from the most recent yank.\r\n              this.registers['0'] = new Register(text, linewise, blockwise);\r\n              break;\r\n            case 'delete':\r\n            case 'change':\r\n              if (text.indexOf('\\n') == -1) {\r\n                // Delete less than 1 line. Update the small delete register.\r\n                this.registers['-'] = new Register(text, linewise);\r\n              } else {\r\n                // Shift down the contents of the numbered registers and put the\r\n                // deleted text into register 1.\r\n                this.shiftNumericRegisters_();\r\n                this.registers['1'] = new Register(text, linewise);\r\n              }\r\n              break;\r\n          }\r\n          // Make sure the unnamed register is set to what just happened\r\n          this.unnamedRegister.setText(text, linewise, blockwise);\r\n          return;\r\n        }\r\n\r\n        // If we've gotten to this point, we've actually specified a register\r\n        var append = isUpperCase(registerName);\r\n        if (append) {\r\n          register.pushText(text, linewise);\r\n        } else {\r\n          register.setText(text, linewise, blockwise);\r\n        }\r\n        // The unnamed register always has the same value as the last used\r\n        // register.\r\n        this.unnamedRegister.setText(register.toString(), linewise);\r\n      },\r\n      // Gets the register named @name.  If one of @name doesn't already exist,\r\n      // create it.  If @name is invalid, return the unnamedRegister.\r\n      getRegister: function(name) {\r\n        if (!this.isValidRegister(name)) {\r\n          return this.unnamedRegister;\r\n        }\r\n        name = name.toLowerCase();\r\n        if (!this.registers[name]) {\r\n          this.registers[name] = new Register();\r\n        }\r\n        return this.registers[name];\r\n      },\r\n      isValidRegister: function(name) {\r\n        return name && inArray(name, validRegisters);\r\n      },\r\n      shiftNumericRegisters_: function() {\r\n        for (var i = 9; i >= 2; i--) {\r\n          this.registers[i] = this.getRegister('' + (i - 1));\r\n        }\r\n      }\r\n    };\r\n    function HistoryController() {\r\n        this.historyBuffer = [];\r\n        this.iterator = 0;\r\n        this.initialPrefix = null;\r\n    }\r\n    HistoryController.prototype = {\r\n      // the input argument here acts a user entered prefix for a small time\r\n      // until we start autocompletion in which case it is the autocompleted.\r\n      nextMatch: function (input, up) {\r\n        var historyBuffer = this.historyBuffer;\r\n        var dir = up ? -1 : 1;\r\n        if (this.initialPrefix === null) this.initialPrefix = input;\r\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\r\n          var element = historyBuffer[i];\r\n          for (var j = 0; j <= element.length; j++) {\r\n            if (this.initialPrefix == element.substring(0, j)) {\r\n              this.iterator = i;\r\n              return element;\r\n            }\r\n          }\r\n        }\r\n        // should return the user input in case we reach the end of buffer.\r\n        if (i >= historyBuffer.length) {\r\n          this.iterator = historyBuffer.length;\r\n          return this.initialPrefix;\r\n        }\r\n        // return the last autocompleted query or exCommand as it is.\r\n        if (i < 0 ) return input;\r\n      },\r\n      pushInput: function(input) {\r\n        var index = this.historyBuffer.indexOf(input);\r\n        if (index > -1) this.historyBuffer.splice(index, 1);\r\n        if (input.length) this.historyBuffer.push(input);\r\n      },\r\n      reset: function() {\r\n        this.initialPrefix = null;\r\n        this.iterator = this.historyBuffer.length;\r\n      }\r\n    };\r\n    var commandDispatcher = {\r\n      matchCommand: function(keys, keyMap, inputState, context) {\r\n        var matches = commandMatches(keys, keyMap, context, inputState);\r\n        if (!matches.full && !matches.partial) {\r\n          return {type: 'none'};\r\n        } else if (!matches.full && matches.partial) {\r\n          return {type: 'partial'};\r\n        }\r\n\r\n        var bestMatch;\r\n        for (var i = 0; i < matches.full.length; i++) {\r\n          var match = matches.full[i];\r\n          if (!bestMatch) {\r\n            bestMatch = match;\r\n          }\r\n        }\r\n        if (bestMatch.keys.slice(-11) == '<character>') {\r\n          var character = lastChar(keys);\r\n          if (/<C-.>/.test(character)) return {type: 'none'};\r\n          inputState.selectedCharacter = character;\r\n        }\r\n        return {type: 'full', command: bestMatch};\r\n      },\r\n      processCommand: function(cm, vim, command) {\r\n        vim.inputState.repeatOverride = command.repeatOverride;\r\n        switch (command.type) {\r\n          case 'motion':\r\n            this.processMotion(cm, vim, command);\r\n            break;\r\n          case 'operator':\r\n            this.processOperator(cm, vim, command);\r\n            break;\r\n          case 'operatorMotion':\r\n            this.processOperatorMotion(cm, vim, command);\r\n            break;\r\n          case 'action':\r\n            this.processAction(cm, vim, command);\r\n            break;\r\n          case 'search':\r\n            this.processSearch(cm, vim, command);\r\n            break;\r\n          case 'ex':\r\n          case 'keyToEx':\r\n            this.processEx(cm, vim, command);\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n      },\r\n      processMotion: function(cm, vim, command) {\r\n        vim.inputState.motion = command.motion;\r\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\r\n        this.evalInput(cm, vim);\r\n      },\r\n      processOperator: function(cm, vim, command) {\r\n        var inputState = vim.inputState;\r\n        if (inputState.operator) {\r\n          if (inputState.operator == command.operator) {\r\n            // Typing an operator twice like 'dd' makes the operator operate\r\n            // linewise\r\n            inputState.motion = 'expandToLine';\r\n            inputState.motionArgs = { linewise: true };\r\n            this.evalInput(cm, vim);\r\n            return;\r\n          } else {\r\n            // 2 different operators in a row doesn't make sense.\r\n            clearInputState(cm);\r\n          }\r\n        }\r\n        inputState.operator = command.operator;\r\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\r\n        if (vim.visualMode) {\r\n          // Operating on a selection in visual mode. We don't need a motion.\r\n          this.evalInput(cm, vim);\r\n        }\r\n      },\r\n      processOperatorMotion: function(cm, vim, command) {\r\n        var visualMode = vim.visualMode;\r\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\r\n        if (operatorMotionArgs) {\r\n          // Operator motions may have special behavior in visual mode.\r\n          if (visualMode && operatorMotionArgs.visualLine) {\r\n            vim.visualLine = true;\r\n          }\r\n        }\r\n        this.processOperator(cm, vim, command);\r\n        if (!visualMode) {\r\n          this.processMotion(cm, vim, command);\r\n        }\r\n      },\r\n      processAction: function(cm, vim, command) {\r\n        var inputState = vim.inputState;\r\n        var repeat = inputState.getRepeat();\r\n        var repeatIsExplicit = !!repeat;\r\n        var actionArgs = copyArgs(command.actionArgs) || {};\r\n        if (inputState.selectedCharacter) {\r\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\r\n        }\r\n        // Actions may or may not have motions and operators. Do these first.\r\n        if (command.operator) {\r\n          this.processOperator(cm, vim, command);\r\n        }\r\n        if (command.motion) {\r\n          this.processMotion(cm, vim, command);\r\n        }\r\n        if (command.motion || command.operator) {\r\n          this.evalInput(cm, vim);\r\n        }\r\n        actionArgs.repeat = repeat || 1;\r\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\r\n        actionArgs.registerName = inputState.registerName;\r\n        clearInputState(cm);\r\n        vim.lastMotion = null;\r\n        if (command.isEdit) {\r\n          this.recordLastEdit(vim, inputState, command);\r\n        }\r\n        actions[command.action](cm, actionArgs, vim);\r\n      },\r\n      processSearch: function(cm, vim, command) {\r\n        if (!cm.getSearchCursor) {\r\n          // Search depends on SearchCursor.\r\n          return;\r\n        }\r\n        var forward = command.searchArgs.forward;\r\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\r\n        getSearchState(cm).setReversed(!forward);\r\n        var promptPrefix = (forward) ? '/' : '?';\r\n        var originalQuery = getSearchState(cm).getQuery();\r\n        var originalScrollPos = cm.getScrollInfo();\r\n        function handleQuery(query, ignoreCase, smartCase) {\r\n          vimGlobalState.searchHistoryController.pushInput(query);\r\n          vimGlobalState.searchHistoryController.reset();\r\n          try {\r\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\r\n          } catch (e) {\r\n            showConfirm(cm, 'Invalid regex: ' + query);\r\n            clearInputState(cm);\r\n            return;\r\n          }\r\n          commandDispatcher.processMotion(cm, vim, {\r\n            type: 'motion',\r\n            motion: 'findNext',\r\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\r\n          });\r\n        }\r\n        function onPromptClose(query) {\r\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\r\n          var macroModeState = vimGlobalState.macroModeState;\r\n          if (macroModeState.isRecording) {\r\n            logSearchQuery(macroModeState, query);\r\n          }\r\n        }\r\n        function onPromptKeyUp(e, query, close) {\r\n          var keyName = CodeMirror.keyName(e), up, offset;\r\n          if (keyName == 'Up' || keyName == 'Down') {\r\n            up = keyName == 'Up' ? true : false;\r\n            offset = e.target ? e.target.selectionEnd : 0;\r\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\r\n            close(query);\r\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\r\n          } else {\r\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\r\n              vimGlobalState.searchHistoryController.reset();\r\n          }\r\n          var parsedQuery;\r\n          try {\r\n            parsedQuery = updateSearchQuery(cm, query,\r\n                true /** ignoreCase */, true /** smartCase */);\r\n          } catch (e) {\r\n            // Swallow bad regexes for incremental search.\r\n          }\r\n          if (parsedQuery) {\r\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\r\n          } else {\r\n            clearSearchHighlight(cm);\r\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\r\n          }\r\n        }\r\n        function onPromptKeyDown(e, query, close) {\r\n          var keyName = CodeMirror.keyName(e);\r\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\r\n              (keyName == 'Backspace' && query == '')) {\r\n            vimGlobalState.searchHistoryController.pushInput(query);\r\n            vimGlobalState.searchHistoryController.reset();\r\n            updateSearchQuery(cm, originalQuery);\r\n            clearSearchHighlight(cm);\r\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\r\n            CodeMirror.e_stop(e);\r\n            clearInputState(cm);\r\n            close();\r\n            cm.focus();\r\n          } else if (keyName == 'Up' || keyName == 'Down') {\r\n            CodeMirror.e_stop(e);\r\n          } else if (keyName == 'Ctrl-U') {\r\n            // Ctrl-U clears input.\r\n            CodeMirror.e_stop(e);\r\n            close('');\r\n          }\r\n        }\r\n        switch (command.searchArgs.querySrc) {\r\n          case 'prompt':\r\n            var macroModeState = vimGlobalState.macroModeState;\r\n            if (macroModeState.isPlaying) {\r\n              var query = macroModeState.replaySearchQueries.shift();\r\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\r\n            } else {\r\n              showPrompt(cm, {\r\n                  onClose: onPromptClose,\r\n                  prefix: promptPrefix,\r\n                  desc: searchPromptDesc,\r\n                  onKeyUp: onPromptKeyUp,\r\n                  onKeyDown: onPromptKeyDown\r\n              });\r\n            }\r\n            break;\r\n          case 'wordUnderCursor':\r\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\r\n                true /** forward */, false /** bigWord */,\r\n                true /** noSymbol */);\r\n            var isKeyword = true;\r\n            if (!word) {\r\n              word = expandWordUnderCursor(cm, false /** inclusive */,\r\n                  true /** forward */, false /** bigWord */,\r\n                  false /** noSymbol */);\r\n              isKeyword = false;\r\n            }\r\n            if (!word) {\r\n              return;\r\n            }\r\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\r\n                word.end.ch);\r\n            if (isKeyword && wholeWordOnly) {\r\n                query = '\\\\b' + query + '\\\\b';\r\n            } else {\r\n              query = escapeRegex(query);\r\n            }\r\n\r\n            // cachedCursor is used to save the old position of the cursor\r\n            // when * or # causes vim to seek for the nearest word and shift\r\n            // the cursor before entering the motion.\r\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\r\n            cm.setCursor(word.start);\r\n\r\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\r\n            break;\r\n        }\r\n      },\r\n      processEx: function(cm, vim, command) {\r\n        function onPromptClose(input) {\r\n          // Give the prompt some time to close so that if processCommand shows\r\n          // an error, the elements don't overlap.\r\n          vimGlobalState.exCommandHistoryController.pushInput(input);\r\n          vimGlobalState.exCommandHistoryController.reset();\r\n          exCommandDispatcher.processCommand(cm, input);\r\n        }\r\n        function onPromptKeyDown(e, input, close) {\r\n          var keyName = CodeMirror.keyName(e), up, offset;\r\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\r\n              (keyName == 'Backspace' && input == '')) {\r\n            vimGlobalState.exCommandHistoryController.pushInput(input);\r\n            vimGlobalState.exCommandHistoryController.reset();\r\n            CodeMirror.e_stop(e);\r\n            clearInputState(cm);\r\n            close();\r\n            cm.focus();\r\n          }\r\n          if (keyName == 'Up' || keyName == 'Down') {\r\n            CodeMirror.e_stop(e);\r\n            up = keyName == 'Up' ? true : false;\r\n            offset = e.target ? e.target.selectionEnd : 0;\r\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\r\n            close(input);\r\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\r\n          } else if (keyName == 'Ctrl-U') {\r\n            // Ctrl-U clears input.\r\n            CodeMirror.e_stop(e);\r\n            close('');\r\n          } else {\r\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\r\n              vimGlobalState.exCommandHistoryController.reset();\r\n          }\r\n        }\r\n        if (command.type == 'keyToEx') {\r\n          // Handle user defined Ex to Ex mappings\r\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\r\n        } else {\r\n          if (vim.visualMode) {\r\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\r\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\r\n          } else {\r\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\r\n                onKeyDown: onPromptKeyDown});\r\n          }\r\n        }\r\n      },\r\n      evalInput: function(cm, vim) {\r\n        // If the motion command is set, execute both the operator and motion.\r\n        // Otherwise return.\r\n        var inputState = vim.inputState;\r\n        var motion = inputState.motion;\r\n        var motionArgs = inputState.motionArgs || {};\r\n        var operator = inputState.operator;\r\n        var operatorArgs = inputState.operatorArgs || {};\r\n        var registerName = inputState.registerName;\r\n        var sel = vim.sel;\r\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\r\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\r\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\r\n        var oldHead = copyCursor(origHead);\r\n        var oldAnchor = copyCursor(origAnchor);\r\n        var newHead, newAnchor;\r\n        var repeat;\r\n        if (operator) {\r\n          this.recordLastEdit(vim, inputState);\r\n        }\r\n        if (inputState.repeatOverride !== undefined) {\r\n          // If repeatOverride is specified, that takes precedence over the\r\n          // input state's repeat. Used by Ex mode and can be user defined.\r\n          repeat = inputState.repeatOverride;\r\n        } else {\r\n          repeat = inputState.getRepeat();\r\n        }\r\n        if (repeat > 0 && motionArgs.explicitRepeat) {\r\n          motionArgs.repeatIsExplicit = true;\r\n        } else if (motionArgs.noRepeat ||\r\n            (!motionArgs.explicitRepeat && repeat === 0)) {\r\n          repeat = 1;\r\n          motionArgs.repeatIsExplicit = false;\r\n        }\r\n        if (inputState.selectedCharacter) {\r\n          // If there is a character input, stick it in all of the arg arrays.\r\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\r\n              inputState.selectedCharacter;\r\n        }\r\n        motionArgs.repeat = repeat;\r\n        clearInputState(cm);\r\n        if (motion) {\r\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim);\r\n          vim.lastMotion = motions[motion];\r\n          if (!motionResult) {\r\n            return;\r\n          }\r\n          if (motionArgs.toJumplist) {\r\n            if (!operator && cm.ace.curOp != null)\r\n              cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\r\n            var jumpList = vimGlobalState.jumpList;\r\n            // if the current motion is # or *, use cachedCursor\r\n            var cachedCursor = jumpList.cachedCursor;\r\n            if (cachedCursor) {\r\n              recordJumpPosition(cm, cachedCursor, motionResult);\r\n              delete jumpList.cachedCursor;\r\n            } else {\r\n              recordJumpPosition(cm, origHead, motionResult);\r\n            }\r\n          }\r\n          if (motionResult instanceof Array) {\r\n            newAnchor = motionResult[0];\r\n            newHead = motionResult[1];\r\n          } else {\r\n            newHead = motionResult;\r\n          }\r\n          // TODO: Handle null returns from motion commands better.\r\n          if (!newHead) {\r\n            newHead = copyCursor(origHead);\r\n          }\r\n          if (vim.visualMode) {\r\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\r\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\r\n            }\r\n            if (newAnchor) {\r\n              newAnchor = clipCursorToContent(cm, newAnchor, true);\r\n            }\r\n            newAnchor = newAnchor || oldAnchor;\r\n            sel.anchor = newAnchor;\r\n            sel.head = newHead;\r\n            updateCmSelection(cm);\r\n            updateMark(cm, vim, '<',\r\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\r\n                    : newHead);\r\n            updateMark(cm, vim, '>',\r\n                cursorIsBefore(newAnchor, newHead) ? newHead\r\n                    : newAnchor);\r\n          } else if (!operator) {\r\n            newHead = clipCursorToContent(cm, newHead);\r\n            cm.setCursor(newHead.line, newHead.ch);\r\n          }\r\n        }\r\n        if (operator) {\r\n          if (operatorArgs.lastSel) {\r\n            // Replaying a visual mode operation\r\n            newAnchor = oldAnchor;\r\n            var lastSel = operatorArgs.lastSel;\r\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\r\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\r\n            if (lastSel.visualLine) {\r\n              // Linewise Visual mode: The same number of lines.\r\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\r\n            } else if (lastSel.visualBlock) {\r\n              // Blockwise Visual mode: The same number of lines and columns.\r\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\r\n            } else if (lastSel.head.line == lastSel.anchor.line) {\r\n              // Normal Visual mode within one line: The same number of characters.\r\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\r\n            } else {\r\n              // Normal Visual mode with several lines: The same number of lines, in the\r\n              // last line the same number of characters as in the last line the last time.\r\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\r\n            }\r\n            vim.visualMode = true;\r\n            vim.visualLine = lastSel.visualLine;\r\n            vim.visualBlock = lastSel.visualBlock;\r\n            sel = vim.sel = {\r\n              anchor: newAnchor,\r\n              head: newHead\r\n            };\r\n            updateCmSelection(cm);\r\n          } else if (vim.visualMode) {\r\n            operatorArgs.lastSel = {\r\n              anchor: copyCursor(sel.anchor),\r\n              head: copyCursor(sel.head),\r\n              visualBlock: vim.visualBlock,\r\n              visualLine: vim.visualLine\r\n            };\r\n          }\r\n          var curStart, curEnd, linewise, mode;\r\n          var cmSel;\r\n          if (vim.visualMode) {\r\n            // Init visual op\r\n            curStart = cursorMin(sel.head, sel.anchor);\r\n            curEnd = cursorMax(sel.head, sel.anchor);\r\n            linewise = vim.visualLine || operatorArgs.linewise;\r\n            mode = vim.visualBlock ? 'block' :\r\n                   linewise ? 'line' :\r\n                   'char';\r\n            cmSel = makeCmSelection(cm, {\r\n              anchor: curStart,\r\n              head: curEnd\r\n            }, mode);\r\n            if (linewise) {\r\n              var ranges = cmSel.ranges;\r\n              if (mode == 'block') {\r\n                // Linewise operators in visual block mode extend to end of line\r\n                for (var i = 0; i < ranges.length; i++) {\r\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\r\n                }\r\n              } else if (mode == 'line') {\r\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\r\n              }\r\n            }\r\n          } else {\r\n            // Init motion op\r\n            curStart = copyCursor(newAnchor || oldAnchor);\r\n            curEnd = copyCursor(newHead || oldHead);\r\n            if (cursorIsBefore(curEnd, curStart)) {\r\n              var tmp = curStart;\r\n              curStart = curEnd;\r\n              curEnd = tmp;\r\n            }\r\n            linewise = motionArgs.linewise || operatorArgs.linewise;\r\n            if (linewise) {\r\n              // Expand selection to entire line.\r\n              expandSelectionToLine(cm, curStart, curEnd);\r\n            } else if (motionArgs.forward) {\r\n              // Clip to trailing newlines only if the motion goes forward.\r\n              clipToLine(cm, curStart, curEnd);\r\n            }\r\n            mode = 'char';\r\n            var exclusive = !motionArgs.inclusive || linewise;\r\n            cmSel = makeCmSelection(cm, {\r\n              anchor: curStart,\r\n              head: curEnd\r\n            }, mode, exclusive);\r\n          }\r\n          cm.setSelections(cmSel.ranges, cmSel.primary);\r\n          vim.lastMotion = null;\r\n          operatorArgs.repeat = repeat; // For indent in visual mode.\r\n          operatorArgs.registerName = registerName;\r\n          // Keep track of linewise as it affects how paste and change behave.\r\n          operatorArgs.linewise = linewise;\r\n          var operatorMoveTo = operators[operator](\r\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\r\n          if (vim.visualMode) {\r\n            exitVisualMode(cm, operatorMoveTo != null);\r\n          }\r\n          if (operatorMoveTo) {\r\n            cm.setCursor(operatorMoveTo);\r\n          }\r\n        }\r\n      },\r\n      recordLastEdit: function(vim, inputState, actionCommand) {\r\n        var macroModeState = vimGlobalState.macroModeState;\r\n        if (macroModeState.isPlaying) { return; }\r\n        vim.lastEditInputState = inputState;\r\n        vim.lastEditActionCommand = actionCommand;\r\n        macroModeState.lastInsertModeChanges.changes = [];\r\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\r\n      }\r\n    };\r\n\r\n    /**\r\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\r\n     *     position of the cursor.\r\n     */\r\n    // All of the functions below return Cursor objects.\r\n    var motions = {\r\n      moveToTopLine: function(cm, _head, motionArgs) {\r\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\r\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\r\n      },\r\n      moveToMiddleLine: function(cm) {\r\n        var range = getUserVisibleLines(cm);\r\n        var line = Math.floor((range.top + range.bottom) * 0.5);\r\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\r\n      },\r\n      moveToBottomLine: function(cm, _head, motionArgs) {\r\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\r\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\r\n      },\r\n      expandToLine: function(_cm, head, motionArgs) {\r\n        // Expands forward to end of line, and then to next line if repeat is\r\n        // >1. Does not handle backward motion!\r\n        var cur = head;\r\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\r\n      },\r\n      findNext: function(cm, _head, motionArgs) {\r\n        var state = getSearchState(cm);\r\n        var query = state.getQuery();\r\n        if (!query) {\r\n          return;\r\n        }\r\n        var prev = !motionArgs.forward;\r\n        // If search is initiated with ? instead of /, negate direction.\r\n        prev = (state.isReversed()) ? !prev : prev;\r\n        highlightSearchMatches(cm, query);\r\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\r\n      },\r\n      goToMark: function(cm, _head, motionArgs, vim) {\r\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\r\n        if (pos) {\r\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\r\n        }\r\n        return null;\r\n      },\r\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\r\n        if (vim.visualBlock && motionArgs.sameLine) {\r\n          var sel = vim.sel;\r\n          return [\r\n            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),\r\n            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))\r\n          ];\r\n        } else {\r\n          return ([vim.sel.head, vim.sel.anchor]);\r\n        }\r\n      },\r\n      jumpToMark: function(cm, head, motionArgs, vim) {\r\n        var best = head;\r\n        for (var i = 0; i < motionArgs.repeat; i++) {\r\n          var cursor = best;\r\n          for (var key in vim.marks) {\r\n            if (!isLowerCase(key)) {\r\n              continue;\r\n            }\r\n            var mark = vim.marks[key].find();\r\n            var isWrongDirection = (motionArgs.forward) ?\r\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\r\n\r\n            if (isWrongDirection) {\r\n              continue;\r\n            }\r\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\r\n              continue;\r\n            }\r\n\r\n            var equal = cursorEqual(cursor, best);\r\n            var between = (motionArgs.forward) ?\r\n              cursorIsBetween(cursor, mark, best) :\r\n              cursorIsBetween(best, mark, cursor);\r\n\r\n            if (equal || between) {\r\n              best = mark;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (motionArgs.linewise) {\r\n          // Vim places the cursor on the first non-whitespace character of\r\n          // the line if there is one, else it places the cursor at the end\r\n          // of the line, regardless of whether a mark was found.\r\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\r\n        }\r\n        return best;\r\n      },\r\n      moveByCharacters: function(_cm, head, motionArgs) {\r\n        var cur = head;\r\n        var repeat = motionArgs.repeat;\r\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\r\n        return Pos(cur.line, ch);\r\n      },\r\n      moveByLines: function(cm, head, motionArgs, vim) {\r\n        var cur = head;\r\n        var endCh = cur.ch;\r\n        // Depending what our last motion was, we may want to do different\r\n        // things. If our last motion was moving vertically, we want to\r\n        // preserve the HPos from our last horizontal move.  If our last motion\r\n        // was going to the end of a line, moving vertically we should go to\r\n        // the end of the line, etc.\r\n        switch (vim.lastMotion) {\r\n          case this.moveByLines:\r\n          case this.moveByDisplayLines:\r\n          case this.moveByScroll:\r\n          case this.moveToColumn:\r\n          case this.moveToEol:\r\n            endCh = vim.lastHPos;\r\n            break;\r\n          default:\r\n            vim.lastHPos = endCh;\r\n        }\r\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\r\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\r\n        var first = cm.firstLine();\r\n        var last = cm.lastLine();\r\n        // Vim go to line begin or line end when cursor at first/last line and\r\n        // move to previous/next line is triggered.\r\n        if (line < first && cur.line == first){\r\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\r\n        }else if (line > last && cur.line == last){\r\n            return this.moveToEol(cm, head, motionArgs, vim);\r\n        }\r\n        // ace_patch{\r\n        var fold = cm.ace.session.getFoldLine(line);\r\n        if (fold) {\r\n          if (motionArgs.forward) {\r\n            if (line > fold.start.row)\r\n              line = fold.end.row + 1;\r\n          } else {\r\n            line = fold.start.row;\r\n          }\r\n        }\r\n        // ace_patch}\r\n        if (motionArgs.toFirstChar){\r\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\r\n          vim.lastHPos = endCh;\r\n        }\r\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;\r\n        return Pos(line, endCh);\r\n      },\r\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\r\n        var cur = head;\r\n        switch (vim.lastMotion) {\r\n          case this.moveByDisplayLines:\r\n          case this.moveByScroll:\r\n          case this.moveByLines:\r\n          case this.moveToColumn:\r\n          case this.moveToEol:\r\n            break;\r\n          default:\r\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\r\n        }\r\n        var repeat = motionArgs.repeat;\r\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\r\n        if (res.hitSide) {\r\n          if (motionArgs.forward) {\r\n            var lastCharCoords = cm.charCoords(res, 'div');\r\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\r\n            var res = cm.coordsChar(goalCoords, 'div');\r\n          } else {\r\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\r\n            resCoords.left = vim.lastHSPos;\r\n            res = cm.coordsChar(resCoords, 'div');\r\n          }\r\n        }\r\n        vim.lastHPos = res.ch;\r\n        return res;\r\n      },\r\n      moveByPage: function(cm, head, motionArgs) {\r\n        // CodeMirror only exposes functions that move the cursor page down, so\r\n        // doing this bad hack to move the cursor and move it back. evalInput\r\n        // will move the cursor to where it should be in the end.\r\n        var curStart = head;\r\n        var repeat = motionArgs.repeat;\r\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\r\n      },\r\n      moveByParagraph: function(cm, head, motionArgs) {\r\n        var dir = motionArgs.forward ? 1 : -1;\r\n        return findParagraph(cm, head, motionArgs.repeat, dir);\r\n      },\r\n      moveByScroll: function(cm, head, motionArgs, vim) {\r\n        var scrollbox = cm.getScrollInfo();\r\n        var curEnd = null;\r\n        var repeat = motionArgs.repeat;\r\n        if (!repeat) {\r\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\r\n        }\r\n        var orig = cm.charCoords(head, 'local');\r\n        motionArgs.repeat = repeat;\r\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\r\n        if (!curEnd) {\r\n          return null;\r\n        }\r\n        var dest = cm.charCoords(curEnd, 'local');\r\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\r\n        return curEnd;\r\n      },\r\n      moveByWords: function(cm, head, motionArgs) {\r\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\r\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\r\n      },\r\n      moveTillCharacter: function(cm, _head, motionArgs) {\r\n        var repeat = motionArgs.repeat;\r\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\r\n            motionArgs.selectedCharacter);\r\n        var increment = motionArgs.forward ? -1 : 1;\r\n        recordLastCharacterSearch(increment, motionArgs);\r\n        if (!curEnd) return null;\r\n        curEnd.ch += increment;\r\n        return curEnd;\r\n      },\r\n      moveToCharacter: function(cm, head, motionArgs) {\r\n        var repeat = motionArgs.repeat;\r\n        recordLastCharacterSearch(0, motionArgs);\r\n        return moveToCharacter(cm, repeat, motionArgs.forward,\r\n            motionArgs.selectedCharacter) || head;\r\n      },\r\n      moveToSymbol: function(cm, head, motionArgs) {\r\n        var repeat = motionArgs.repeat;\r\n        return findSymbol(cm, repeat, motionArgs.forward,\r\n            motionArgs.selectedCharacter) || head;\r\n      },\r\n      moveToColumn: function(cm, head, motionArgs, vim) {\r\n        var repeat = motionArgs.repeat;\r\n        // repeat is equivalent to which column we want to move to!\r\n        vim.lastHPos = repeat - 1;\r\n        vim.lastHSPos = cm.charCoords(head,'div').left;\r\n        return moveToColumn(cm, repeat);\r\n      },\r\n      moveToEol: function(cm, head, motionArgs, vim) {\r\n        var cur = head;\r\n        vim.lastHPos = Infinity;\r\n        var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);\r\n        var end=cm.clipPos(retval);\r\n        end.ch--;\r\n        vim.lastHSPos = cm.charCoords(end,'div').left;\r\n        return retval;\r\n      },\r\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\r\n        // Go to the start of the line where the text begins, or the end for\r\n        // whitespace-only lines\r\n        var cursor = head;\r\n        return Pos(cursor.line,\r\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\r\n      },\r\n      moveToMatchedSymbol: function(cm, head) {\r\n        var cursor = head;\r\n        var line = cursor.line;\r\n        var ch = cursor.ch;\r\n        var lineText = cm.getLine(line);\r\n        var symbol;\r\n        do {\r\n          symbol = lineText.charAt(ch++);\r\n          if (symbol && isMatchableSymbol(symbol)) {\r\n            var style = cm.getTokenTypeAt(Pos(line, ch));\r\n            if (style !== \"string\" && style !== \"comment\") {\r\n              break;\r\n            }\r\n          }\r\n        } while (symbol);\r\n        if (symbol) {\r\n          var matched = cm.findMatchingBracket(Pos(line, ch));\r\n          return matched.to;\r\n        } else {\r\n          return cursor;\r\n        }\r\n      },\r\n      moveToStartOfLine: function(_cm, head) {\r\n        return Pos(head.line, 0);\r\n      },\r\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\r\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\r\n        if (motionArgs.repeatIsExplicit) {\r\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\r\n        }\r\n        return Pos(lineNum,\r\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\r\n      },\r\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\r\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\r\n        //     outside of a () block.\r\n\r\n        // TODO: adding <> >< to this map doesn't work, presumably because\r\n        // they're operators\r\n        var mirroredPairs = {'(': ')', ')': '(',\r\n                             '{': '}', '}': '{',\r\n                             '[': ']', ']': '[',\r\n                             '<': '>', '>': '<'};\r\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\r\n\r\n        var character = motionArgs.selectedCharacter;\r\n        // 'b' refers to  '()' block.\r\n        // 'B' refers to  '{}' block.\r\n        if (character == 'b') {\r\n          character = '(';\r\n        } else if (character == 'B') {\r\n          character = '{';\r\n        }\r\n\r\n        // Inclusive is the difference between a and i\r\n        // TODO: Instead of using the additional text object map to perform text\r\n        //     object operations, merge the map into the defaultKeyMap and use\r\n        //     motionArgs to define behavior. Define separate entries for 'aw',\r\n        //     'iw', 'a[', 'i[', etc.\r\n        var inclusive = !motionArgs.textObjectInner;\r\n\r\n        var tmp;\r\n        if (mirroredPairs[character]) {\r\n          tmp = selectCompanionObject(cm, head, character, inclusive);\r\n        } else if (selfPaired[character]) {\r\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\r\n        } else if (character === 'W') {\r\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\r\n                                                     true /** bigWord */);\r\n        } else if (character === 'w') {\r\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\r\n                                                     false /** bigWord */);\r\n        } else if (character === 'p') {\r\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\r\n          motionArgs.linewise = true;\r\n          if (vim.visualMode) {\r\n            if (!vim.visualLine) { vim.visualLine = true; }\r\n          } else {\r\n            var operatorArgs = vim.inputState.operatorArgs;\r\n            if (operatorArgs) { operatorArgs.linewise = true; }\r\n            tmp.end.line--;\r\n          }\r\n        } else {\r\n          // No text object defined for this, don't move.\r\n          return null;\r\n        }\r\n\r\n        if (!cm.state.vim.visualMode) {\r\n          return [tmp.start, tmp.end];\r\n        } else {\r\n          return expandSelection(cm, tmp.start, tmp.end);\r\n        }\r\n      },\r\n\r\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\r\n        var lastSearch = vimGlobalState.lastCharacterSearch;\r\n        var repeat = motionArgs.repeat;\r\n        var forward = motionArgs.forward === lastSearch.forward;\r\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\r\n        cm.moveH(-increment, 'char');\r\n        motionArgs.inclusive = forward ? true : false;\r\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\r\n        if (!curEnd) {\r\n          cm.moveH(increment, 'char');\r\n          return head;\r\n        }\r\n        curEnd.ch += increment;\r\n        return curEnd;\r\n      }\r\n    };\r\n\r\n    function defineMotion(name, fn) {\r\n      motions[name] = fn;\r\n    }\r\n\r\n    function fillArray(val, times) {\r\n      var arr = [];\r\n      for (var i = 0; i < times; i++) {\r\n        arr.push(val);\r\n      }\r\n      return arr;\r\n    }\r\n    /**\r\n     * An operator acts on a text selection. It receives the list of selections\r\n     * as input. The corresponding CodeMirror selection is guaranteed to\r\n    * match the input selection.\r\n     */\r\n    var operators = {\r\n      change: function(cm, args, ranges) {\r\n        var finalHead, text;\r\n        var vim = cm.state.vim;\r\n        vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock = vim.visualBlock;\r\n        if (!vim.visualMode) {\r\n          var anchor = ranges[0].anchor,\r\n              head = ranges[0].head;\r\n          text = cm.getRange(anchor, head);\r\n          var lastState = vim.lastEditInputState || {};\r\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\r\n            // Exclude trailing whitespace if the range is not all whitespace.\r\n            var match = (/\\s+$/).exec(text);\r\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\r\n              head = offsetCursor(head, 0, - match[0].length);\r\n              text = text.slice(0, - match[0].length);\r\n            }\r\n          }\r\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\r\n          var wasLastLine = cm.firstLine() == cm.lastLine();\r\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\r\n            cm.replaceRange('', prevLineEnd, head);\r\n          } else {\r\n            cm.replaceRange('', anchor, head);\r\n          }\r\n          if (args.linewise) {\r\n            // Push the next line back down, if there is a next line.\r\n            if (!wasLastLine) {\r\n              cm.setCursor(prevLineEnd);\r\n              CodeMirror.commands.newlineAndIndent(cm);\r\n            }\r\n            // make sure cursor ends up at the end of the line.\r\n            anchor.ch = Number.MAX_VALUE;\r\n          }\r\n          finalHead = anchor;\r\n        } else {\r\n          text = cm.getSelection();\r\n          var replacement = fillArray('', ranges.length);\r\n          cm.replaceSelections(replacement);\r\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\r\n        }\r\n        vimGlobalState.registerController.pushText(\r\n            args.registerName, 'change', text,\r\n            args.linewise, ranges.length > 1);\r\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\r\n      },\r\n      // delete is a javascript keyword.\r\n      'delete': function(cm, args, ranges) {\r\n        var finalHead, text;\r\n        var vim = cm.state.vim;\r\n        if (!vim.visualBlock) {\r\n          var anchor = ranges[0].anchor,\r\n              head = ranges[0].head;\r\n          if (args.linewise &&\r\n              head.line != cm.firstLine() &&\r\n              anchor.line == cm.lastLine() &&\r\n              anchor.line == head.line - 1) {\r\n            // Special case for dd on last line (and first line).\r\n            if (anchor.line == cm.firstLine()) {\r\n              anchor.ch = 0;\r\n            } else {\r\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\r\n            }\r\n          }\r\n          text = cm.getRange(anchor, head);\r\n          cm.replaceRange('', anchor, head);\r\n          finalHead = anchor;\r\n          if (args.linewise) {\r\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\r\n          }\r\n        } else {\r\n          text = cm.getSelection();\r\n          var replacement = fillArray('', ranges.length);\r\n          cm.replaceSelections(replacement);\r\n          finalHead = ranges[0].anchor;\r\n        }\r\n        vimGlobalState.registerController.pushText(\r\n            args.registerName, 'delete', text,\r\n            args.linewise, vim.visualBlock);\r\n        var includeLineBreak = vim.insertMode\r\n        return clipCursorToContent(cm, finalHead, includeLineBreak);\r\n      },\r\n      indent: function(cm, args, ranges) {\r\n        var vim = cm.state.vim;\r\n        var startLine = ranges[0].anchor.line;\r\n        var endLine = vim.visualBlock ?\r\n          ranges[ranges.length - 1].anchor.line :\r\n          ranges[0].head.line;\r\n        // In visual mode, n> shifts the selection right n times, instead of\r\n        // shifting n lines right once.\r\n        var repeat = (vim.visualMode) ? args.repeat : 1;\r\n        if (args.linewise) {\r\n          // The only way to delete a newline is to delete until the start of\r\n          // the next line, so in linewise mode evalInput will include the next\r\n          // line. We don't want this in indent, so we go back a line.\r\n          endLine--;\r\n        }\r\n        for (var i = startLine; i <= endLine; i++) {\r\n          for (var j = 0; j < repeat; j++) {\r\n            cm.indentLine(i, args.indentRight);\r\n          }\r\n        }\r\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\r\n      },\r\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\r\n        var selections = cm.getSelections();\r\n        var swapped = [];\r\n        var toLower = args.toLower;\r\n        for (var j = 0; j < selections.length; j++) {\r\n          var toSwap = selections[j];\r\n          var text = '';\r\n          if (toLower === true) {\r\n            text = toSwap.toLowerCase();\r\n          } else if (toLower === false) {\r\n            text = toSwap.toUpperCase();\r\n          } else {\r\n            for (var i = 0; i < toSwap.length; i++) {\r\n              var character = toSwap.charAt(i);\r\n              text += isUpperCase(character) ? character.toLowerCase() :\r\n                  character.toUpperCase();\r\n            }\r\n          }\r\n          swapped.push(text);\r\n        }\r\n        cm.replaceSelections(swapped);\r\n        if (args.shouldMoveCursor){\r\n          return newHead;\r\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\r\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\r\n        } else if (args.linewise){\r\n          return oldAnchor;\r\n        } else {\r\n          return cursorMin(ranges[0].anchor, ranges[0].head);\r\n        }\r\n      },\r\n      yank: function(cm, args, ranges, oldAnchor) {\r\n        var vim = cm.state.vim;\r\n        var text = cm.getSelection();\r\n        var endPos = vim.visualMode\r\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\r\n          : oldAnchor;\r\n        vimGlobalState.registerController.pushText(\r\n            args.registerName, 'yank',\r\n            text, args.linewise, vim.visualBlock);\r\n        return endPos;\r\n      }\r\n    };\r\n\r\n    function defineOperator(name, fn) {\r\n      operators[name] = fn;\r\n    }\r\n\r\n    var actions = {\r\n      jumpListWalk: function(cm, actionArgs, vim) {\r\n        if (vim.visualMode) {\r\n          return;\r\n        }\r\n        var repeat = actionArgs.repeat;\r\n        var forward = actionArgs.forward;\r\n        var jumpList = vimGlobalState.jumpList;\r\n\r\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\r\n        var markPos = mark ? mark.find() : undefined;\r\n        markPos = markPos ? markPos : cm.getCursor();\r\n        cm.setCursor(markPos);\r\n        cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\r\n      },\r\n      scroll: function(cm, actionArgs, vim) {\r\n        if (vim.visualMode) {\r\n          return;\r\n        }\r\n        var repeat = actionArgs.repeat || 1;\r\n        var lineHeight = cm.defaultTextHeight();\r\n        var top = cm.getScrollInfo().top;\r\n        var delta = lineHeight * repeat;\r\n        var newPos = actionArgs.forward ? top + delta : top - delta;\r\n        var cursor = copyCursor(cm.getCursor());\r\n        var cursorCoords = cm.charCoords(cursor, 'local');\r\n        if (actionArgs.forward) {\r\n          if (newPos > cursorCoords.top) {\r\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\r\n             cursor.line = Math.ceil(cursor.line);\r\n             cm.setCursor(cursor);\r\n             cursorCoords = cm.charCoords(cursor, 'local');\r\n             cm.scrollTo(null, cursorCoords.top);\r\n          } else {\r\n             // Cursor stays within bounds.  Just reposition the scroll window.\r\n             cm.scrollTo(null, newPos);\r\n          }\r\n        } else {\r\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\r\n          if (newBottom < cursorCoords.bottom) {\r\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\r\n             cursor.line = Math.floor(cursor.line);\r\n             cm.setCursor(cursor);\r\n             cursorCoords = cm.charCoords(cursor, 'local');\r\n             cm.scrollTo(\r\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\r\n          } else {\r\n             // Cursor stays within bounds.  Just reposition the scroll window.\r\n             cm.scrollTo(null, newPos);\r\n          }\r\n        }\r\n      },\r\n      scrollToCursor: function(cm, actionArgs) {\r\n        var lineNum = cm.getCursor().line;\r\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\r\n        var height = cm.getScrollInfo().clientHeight;\r\n        var y = charCoords.top;\r\n        var lineHeight = charCoords.bottom - y;\r\n        switch (actionArgs.position) {\r\n          case 'center': y = y - (height / 2) + lineHeight;\r\n            break;\r\n          case 'bottom': y = y - height + lineHeight*1.4;\r\n            break;\r\n          case 'top': y = y + lineHeight*0.4;\r\n            break;\r\n        }\r\n        cm.scrollTo(null, y);\r\n      },\r\n      replayMacro: function(cm, actionArgs, vim) {\r\n        var registerName = actionArgs.selectedCharacter;\r\n        var repeat = actionArgs.repeat;\r\n        var macroModeState = vimGlobalState.macroModeState;\r\n        if (registerName == '@') {\r\n          registerName = macroModeState.latestRegister;\r\n        }\r\n        while(repeat--){\r\n          executeMacroRegister(cm, vim, macroModeState, registerName);\r\n        }\r\n      },\r\n      enterMacroRecordMode: function(cm, actionArgs) {\r\n        var macroModeState = vimGlobalState.macroModeState;\r\n        var registerName = actionArgs.selectedCharacter;\r\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\r\n          macroModeState.enterMacroRecordMode(cm, registerName);\r\n        }\r\n      },\r\n      toggleOverwrite: function(cm) {\r\n        if (!cm.state.overwrite) {\r\n          cm.toggleOverwrite(true);\r\n          cm.setOption('keyMap', 'vim-replace');\r\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\r\n        } else {\r\n          cm.toggleOverwrite(false);\r\n          cm.setOption('keyMap', 'vim-insert');\r\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\r\n        }\r\n      },\r\n      enterInsertMode: function(cm, actionArgs, vim) {\r\n        if (cm.getOption('readOnly')) { return; }\r\n        vim.insertMode = true;\r\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\r\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\r\n        var sel = vim.sel;\r\n        var head = actionArgs.head || cm.getCursor('head');\r\n        var height = cm.listSelections().length;\r\n        if (insertAt == 'eol') {\r\n          head = Pos(head.line, lineLength(cm, head.line));\r\n        } else if (insertAt == 'charAfter') {\r\n          head = offsetCursor(head, 0, 1);\r\n        } else if (insertAt == 'firstNonBlank') {\r\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\r\n        } else if (insertAt == 'startOfSelectedArea') {\r\n          if (!vim.visualBlock) {\r\n            if (sel.head.line < sel.anchor.line) {\r\n              head = sel.head;\r\n            } else {\r\n              head = Pos(sel.anchor.line, 0);\r\n            }\r\n          } else {\r\n            head = Pos(\r\n                Math.min(sel.head.line, sel.anchor.line),\r\n                Math.min(sel.head.ch, sel.anchor.ch));\r\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\r\n          }\r\n        } else if (insertAt == 'endOfSelectedArea') {\r\n          if (!vim.visualBlock) {\r\n            if (sel.head.line >= sel.anchor.line) {\r\n              head = offsetCursor(sel.head, 0, 1);\r\n            } else {\r\n              head = Pos(sel.anchor.line, 0);\r\n            }\r\n          } else {\r\n            head = Pos(\r\n                Math.min(sel.head.line, sel.anchor.line),\r\n                Math.max(sel.head.ch + 1, sel.anchor.ch));\r\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\r\n          }\r\n        } else if (insertAt == 'inplace') {\r\n          if (vim.visualMode){\r\n            return;\r\n          }\r\n        }\r\n        cm.setOption('disableInput', false);\r\n        if (actionArgs && actionArgs.replace) {\r\n          // Handle Replace-mode as a special case of insert mode.\r\n          cm.toggleOverwrite(true);\r\n          cm.setOption('keyMap', 'vim-replace');\r\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\r\n        } else {\r\n          cm.toggleOverwrite(false);\r\n          cm.setOption('keyMap', 'vim-insert');\r\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\r\n        }\r\n        if (!vimGlobalState.macroModeState.isPlaying) {\r\n          // Only record if not replaying.\r\n          cm.on('change', onChange);\r\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\r\n        }\r\n        if (vim.visualMode) {\r\n          exitVisualMode(cm);\r\n        }\r\n        selectForInsert(cm, head, height);\r\n      },\r\n      toggleVisualMode: function(cm, actionArgs, vim) {\r\n        var repeat = actionArgs.repeat;\r\n        var anchor = cm.getCursor();\r\n        var head;\r\n        // TODO: The repeat should actually select number of characters/lines\r\n        //     equal to the repeat times the size of the previous visual\r\n        //     operation.\r\n        if (!vim.visualMode) {\r\n          // Entering visual mode\r\n          vim.visualMode = true;\r\n          vim.visualLine = !!actionArgs.linewise;\r\n          vim.visualBlock = !!actionArgs.blockwise;\r\n          head = clipCursorToContent(\r\n              cm, Pos(anchor.line, anchor.ch + repeat - 1),\r\n              true /** includeLineBreak */);\r\n          vim.sel = {\r\n            anchor: anchor,\r\n            head: head\r\n          };\r\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\r\n          updateCmSelection(cm);\r\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\r\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\r\n        } else if (vim.visualLine ^ actionArgs.linewise ||\r\n            vim.visualBlock ^ actionArgs.blockwise) {\r\n          // Toggling between modes\r\n          vim.visualLine = !!actionArgs.linewise;\r\n          vim.visualBlock = !!actionArgs.blockwise;\r\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\r\n          updateCmSelection(cm);\r\n        } else {\r\n          exitVisualMode(cm);\r\n        }\r\n      },\r\n      reselectLastSelection: function(cm, _actionArgs, vim) {\r\n        var lastSelection = vim.lastSelection;\r\n        if (vim.visualMode) {\r\n          updateLastSelection(cm, vim);\r\n        }\r\n        if (lastSelection) {\r\n          var anchor = lastSelection.anchorMark.find();\r\n          var head = lastSelection.headMark.find();\r\n          if (!anchor || !head) {\r\n            // If the marks have been destroyed due to edits, do nothing.\r\n            return;\r\n          }\r\n          vim.sel = {\r\n            anchor: anchor,\r\n            head: head\r\n          };\r\n          vim.visualMode = true;\r\n          vim.visualLine = lastSelection.visualLine;\r\n          vim.visualBlock = lastSelection.visualBlock;\r\n          updateCmSelection(cm);\r\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\r\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\r\n          CodeMirror.signal(cm, 'vim-mode-change', {\r\n            mode: 'visual',\r\n            subMode: vim.visualLine ? 'linewise' :\r\n                     vim.visualBlock ? 'blockwise' : ''});\r\n        }\r\n      },\r\n      joinLines: function(cm, actionArgs, vim) {\r\n        var curStart, curEnd;\r\n        if (vim.visualMode) {\r\n          curStart = cm.getCursor('anchor');\r\n          curEnd = cm.getCursor('head');\r\n          if (cursorIsBefore(curEnd, curStart)) {\r\n            var tmp = curEnd;\r\n            curEnd = curStart;\r\n            curStart = tmp;\r\n          }\r\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\r\n        } else {\r\n          // Repeat is the number of lines to join. Minimum 2 lines.\r\n          var repeat = Math.max(actionArgs.repeat, 2);\r\n          curStart = cm.getCursor();\r\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,\r\n                                               Infinity));\r\n        }\r\n        var finalCh = 0;\r\n        for (var i = curStart.line; i < curEnd.line; i++) {\r\n          finalCh = lineLength(cm, curStart.line);\r\n          var tmp = Pos(curStart.line + 1,\r\n                        lineLength(cm, curStart.line + 1));\r\n          var text = cm.getRange(curStart, tmp);\r\n          text = text.replace(/\\n\\s*/g, ' ');\r\n          cm.replaceRange(text, curStart, tmp);\r\n        }\r\n        var curFinalPos = Pos(curStart.line, finalCh);\r\n        if (vim.visualMode) {\r\n          exitVisualMode(cm, false);\r\n        }\r\n        cm.setCursor(curFinalPos);\r\n      },\r\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\r\n        vim.insertMode = true;\r\n        var insertAt = copyCursor(cm.getCursor());\r\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\r\n          // Special case for inserting newline before start of document.\r\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\r\n          cm.setCursor(cm.firstLine(), 0);\r\n        } else {\r\n          insertAt.line = (actionArgs.after) ? insertAt.line :\r\n              insertAt.line - 1;\r\n          insertAt.ch = lineLength(cm, insertAt.line);\r\n          cm.setCursor(insertAt);\r\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\r\n              CodeMirror.commands.newlineAndIndent;\r\n          newlineFn(cm);\r\n        }\r\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\r\n      },\r\n      paste: function(cm, actionArgs, vim) {\r\n        var cur = copyCursor(cm.getCursor());\r\n        var register = vimGlobalState.registerController.getRegister(\r\n            actionArgs.registerName);\r\n        var text = register.toString();\r\n        if (!text) {\r\n          return;\r\n        }\r\n        if (actionArgs.matchIndent) {\r\n          var tabSize = cm.getOption(\"tabSize\");\r\n          // length that considers tabs and tabSize\r\n          var whitespaceLength = function(str) {\r\n            var tabs = (str.split(\"\\t\").length - 1);\r\n            var spaces = (str.split(\" \").length - 1);\r\n            return tabs * tabSize + spaces * 1;\r\n          };\r\n          var currentLine = cm.getLine(cm.getCursor().line);\r\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\r\n          // chomp last newline b/c don't want it to match /^\\s*/gm\r\n          var chompedText = text.replace(/\\n$/, '');\r\n          var wasChomped = text !== chompedText;\r\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\r\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\r\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\r\n            if (newIndent < 0) {\r\n              return \"\";\r\n            }\r\n            else if (cm.getOption(\"indentWithTabs\")) {\r\n              var quotient = Math.floor(newIndent / tabSize);\r\n              return Array(quotient + 1).join('\\t');\r\n            }\r\n            else {\r\n              return Array(newIndent + 1).join(' ');\r\n            }\r\n          });\r\n          text += wasChomped ? \"\\n\" : \"\";\r\n        }\r\n        if (actionArgs.repeat > 1) {\r\n          var text = Array(actionArgs.repeat + 1).join(text);\r\n        }\r\n        var linewise = register.linewise;\r\n        var blockwise = register.blockwise;\r\n        if (linewise && !blockwise) {\r\n          if(vim.visualMode) {\r\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\r\n          } else if (actionArgs.after) {\r\n            // Move the newline at the end to the start instead, and paste just\r\n            // before the newline character of the line we are on right now.\r\n            text = '\\n' + text.slice(0, text.length - 1);\r\n            cur.ch = lineLength(cm, cur.line);\r\n          } else {\r\n            cur.ch = 0;\r\n          }\r\n        } else {\r\n          if (blockwise) {\r\n            text = text.split('\\n');\r\n            for (var i = 0; i < text.length; i++) {\r\n              text[i] = (text[i] == '') ? ' ' : text[i];\r\n            }\r\n          }\r\n          cur.ch += actionArgs.after ? 1 : 0;\r\n        }\r\n        var curPosFinal;\r\n        var idx;\r\n        if (vim.visualMode) {\r\n          //  save the pasted text for reselection if the need arises\r\n          vim.lastPastedText = text;\r\n          var lastSelectionCurEnd;\r\n          var selectedArea = getSelectedAreaRange(cm, vim);\r\n          var selectionStart = selectedArea[0];\r\n          var selectionEnd = selectedArea[1];\r\n          var selectedText = cm.getSelection();\r\n          var selections = cm.listSelections();\r\n          var emptyStrings = new Array(selections.length).join('1').split('1');\r\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\r\n          if (vim.lastSelection) {\r\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\r\n          }\r\n          // push the previously selected text to unnamed register\r\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\r\n          if (blockwise) {\r\n            // first delete the selected text\r\n            cm.replaceSelections(emptyStrings);\r\n            // Set new selections as per the block length of the yanked text\r\n            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);\r\n            cm.setCursor(selectionStart);\r\n            selectBlock(cm, selectionEnd);\r\n            cm.replaceSelections(text);\r\n            curPosFinal = selectionStart;\r\n          } else if (vim.visualBlock) {\r\n            cm.replaceSelections(emptyStrings);\r\n            cm.setCursor(selectionStart);\r\n            cm.replaceRange(text, selectionStart, selectionStart);\r\n            curPosFinal = selectionStart;\r\n          } else {\r\n            cm.replaceRange(text, selectionStart, selectionEnd);\r\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\r\n          }\r\n          // restore the the curEnd marker\r\n          if(lastSelectionCurEnd) {\r\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\r\n          }\r\n          if (linewise) {\r\n            curPosFinal.ch=0;\r\n          }\r\n        } else {\r\n          if (blockwise) {\r\n            cm.setCursor(cur);\r\n            for (var i = 0; i < text.length; i++) {\r\n              var line = cur.line+i;\r\n              if (line > cm.lastLine()) {\r\n                cm.replaceRange('\\n',  Pos(line, 0));\r\n              }\r\n              var lastCh = lineLength(cm, line);\r\n              if (lastCh < cur.ch) {\r\n                extendLineToColumn(cm, line, cur.ch);\r\n              }\r\n            }\r\n            cm.setCursor(cur);\r\n            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));\r\n            cm.replaceSelections(text);\r\n            curPosFinal = cur;\r\n          } else {\r\n            cm.replaceRange(text, cur);\r\n            // Now fine tune the cursor to where we want it.\r\n            if (linewise && actionArgs.after) {\r\n              curPosFinal = Pos(\r\n              cur.line + 1,\r\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\r\n            } else if (linewise && !actionArgs.after) {\r\n              curPosFinal = Pos(\r\n                cur.line,\r\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\r\n            } else if (!linewise && actionArgs.after) {\r\n              idx = cm.indexFromPos(cur);\r\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\r\n            } else {\r\n              idx = cm.indexFromPos(cur);\r\n              curPosFinal = cm.posFromIndex(idx + text.length);\r\n            }\r\n          }\r\n        }\r\n        if (vim.visualMode) {\r\n          exitVisualMode(cm, false);\r\n        }\r\n        cm.setCursor(curPosFinal);\r\n      },\r\n      undo: function(cm, actionArgs) {\r\n        cm.operation(function() {\r\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\r\n          cm.setCursor(cm.getCursor('anchor'));\r\n        });\r\n      },\r\n      redo: function(cm, actionArgs) {\r\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\r\n      },\r\n      setRegister: function(_cm, actionArgs, vim) {\r\n        vim.inputState.registerName = actionArgs.selectedCharacter;\r\n      },\r\n      setMark: function(cm, actionArgs, vim) {\r\n        var markName = actionArgs.selectedCharacter;\r\n        updateMark(cm, vim, markName, cm.getCursor());\r\n      },\r\n      replace: function(cm, actionArgs, vim) {\r\n        var replaceWith = actionArgs.selectedCharacter;\r\n        var curStart = cm.getCursor();\r\n        var replaceTo;\r\n        var curEnd;\r\n        var selections = cm.listSelections();\r\n        if (vim.visualMode) {\r\n          curStart = cm.getCursor('start');\r\n          curEnd = cm.getCursor('end');\r\n        } else {\r\n          var line = cm.getLine(curStart.line);\r\n          replaceTo = curStart.ch + actionArgs.repeat;\r\n          if (replaceTo > line.length) {\r\n            replaceTo=line.length;\r\n          }\r\n          curEnd = Pos(curStart.line, replaceTo);\r\n        }\r\n        if (replaceWith=='\\n') {\r\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\r\n          // special case, where vim help says to replace by just one line-break\r\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\r\n        } else {\r\n          var replaceWithStr = cm.getRange(curStart, curEnd);\r\n          //replace all characters in range by selected, but keep linebreaks\r\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\r\n          if (vim.visualBlock) {\r\n            // Tabs are split in visua block before replacing\r\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\r\n            replaceWithStr = cm.getSelection();\r\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\r\n            cm.replaceSelections(replaceWithStr);\r\n          } else {\r\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\r\n          }\r\n          if (vim.visualMode) {\r\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\r\n                         selections[0].anchor : selections[0].head;\r\n            cm.setCursor(curStart);\r\n            exitVisualMode(cm, false);\r\n          } else {\r\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\r\n          }\r\n        }\r\n      },\r\n      incrementNumberToken: function(cm, actionArgs) {\r\n        var cur = cm.getCursor();\r\n        var lineStr = cm.getLine(cur.line);\r\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\r\n        var match;\r\n        var start;\r\n        var end;\r\n        var numberStr;\r\n        while ((match = re.exec(lineStr)) !== null) {\r\n          start = match.index;\r\n          end = start + match[0].length;\r\n          if (cur.ch < end)break;\r\n        }\r\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\r\n        if (match) {\r\n          var baseStr = match[2] || match[4]\r\n          var digits = match[3] || match[5]\r\n          var increment = actionArgs.increase ? 1 : -1;\r\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\r\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\r\n          numberStr = number.toString(base);\r\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : ''\r\n          if (numberStr.charAt(0) === '-') {\r\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\r\n          } else {\r\n            numberStr = baseStr + zeroPadding + numberStr;\r\n          }\r\n          var from = Pos(cur.line, start);\r\n          var to = Pos(cur.line, end);\r\n          cm.replaceRange(numberStr, from, to);\r\n        } else {\r\n          return;\r\n        }\r\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\r\n      },\r\n      repeatLastEdit: function(cm, actionArgs, vim) {\r\n        var lastEditInputState = vim.lastEditInputState;\r\n        if (!lastEditInputState) { return; }\r\n        var repeat = actionArgs.repeat;\r\n        if (repeat && actionArgs.repeatIsExplicit) {\r\n          vim.lastEditInputState.repeatOverride = repeat;\r\n        } else {\r\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\r\n        }\r\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\r\n      },\r\n      indent: function(cm, actionArgs) {\r\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\r\n      },\r\n      exitInsertMode: exitInsertMode\r\n    };\r\n\r\n    function defineAction(name, fn) {\r\n      actions[name] = fn;\r\n    }\r\n\r\n    /*\r\n     * Below are miscellaneous utility functions used by vim.js\r\n     */\r\n\r\n    /**\r\n     * Clips cursor to ensure that line is within the buffer's range\r\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\r\n     */\r\n    function clipCursorToContent(cm, cur, includeLineBreak) {\r\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\r\n      var maxCh = lineLength(cm, line) - 1;\r\n      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh;\r\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\r\n      return Pos(line, ch);\r\n    }\r\n    function copyArgs(args) {\r\n      var ret = {};\r\n      for (var prop in args) {\r\n        if (args.hasOwnProperty(prop)) {\r\n          ret[prop] = args[prop];\r\n        }\r\n      }\r\n      return ret;\r\n    }\r\n    function offsetCursor(cur, offsetLine, offsetCh) {\r\n      if (typeof offsetLine === 'object') {\r\n        offsetCh = offsetLine.ch;\r\n        offsetLine = offsetLine.line;\r\n      }\r\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\r\n    }\r\n    function getOffset(anchor, head) {\r\n      return {\r\n        line: head.line - anchor.line,\r\n        ch: head.line - anchor.line\r\n      };\r\n    }\r\n    function commandMatches(keys, keyMap, context, inputState) {\r\n      // Partial matches are not applied. They inform the key handler\r\n      // that the current key sequence is a subsequence of a valid key\r\n      // sequence, so that the key buffer is not cleared.\r\n      var match, partial = [], full = [];\r\n      for (var i = 0; i < keyMap.length; i++) {\r\n        var command = keyMap[i];\r\n        if (context == 'insert' && command.context != 'insert' ||\r\n            command.context && command.context != context ||\r\n            inputState.operator && command.type == 'action' ||\r\n            !(match = commandMatch(keys, command.keys))) { continue; }\r\n        if (match == 'partial') { partial.push(command); }\r\n        if (match == 'full') { full.push(command); }\r\n      }\r\n      return {\r\n        partial: partial.length && partial,\r\n        full: full.length && full\r\n      };\r\n    }\r\n    function commandMatch(pressed, mapped) {\r\n      if (mapped.slice(-11) == '<character>') {\r\n        // Last character matches anything.\r\n        var prefixLen = mapped.length - 11;\r\n        var pressedPrefix = pressed.slice(0, prefixLen);\r\n        var mappedPrefix = mapped.slice(0, prefixLen);\r\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\r\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\r\n      } else {\r\n        return pressed == mapped ? 'full' :\r\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\r\n      }\r\n    }\r\n    function lastChar(keys) {\r\n      var match = /^.*(<[^>]+>)$/.exec(keys);\r\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\r\n      if (selectedCharacter.length > 1){\r\n        switch(selectedCharacter){\r\n          case '<CR>':\r\n            selectedCharacter='\\n';\r\n            break;\r\n          case '<Space>':\r\n            selectedCharacter=' ';\r\n            break;\r\n          default:\r\n            selectedCharacter='';\r\n            break;\r\n        }\r\n      }\r\n      return selectedCharacter;\r\n    }\r\n    function repeatFn(cm, fn, repeat) {\r\n      return function() {\r\n        for (var i = 0; i < repeat; i++) {\r\n          fn(cm);\r\n        }\r\n      };\r\n    }\r\n    function copyCursor(cur) {\r\n      return Pos(cur.line, cur.ch);\r\n    }\r\n    function cursorEqual(cur1, cur2) {\r\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\r\n    }\r\n    function cursorIsBefore(cur1, cur2) {\r\n      if (cur1.line < cur2.line) {\r\n        return true;\r\n      }\r\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    function cursorMin(cur1, cur2) {\r\n      if (arguments.length > 2) {\r\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\r\n      }\r\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\r\n    }\r\n    function cursorMax(cur1, cur2) {\r\n      if (arguments.length > 2) {\r\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\r\n      }\r\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\r\n    }\r\n    function cursorIsBetween(cur1, cur2, cur3) {\r\n      // returns true if cur2 is between cur1 and cur3.\r\n      var cur1before2 = cursorIsBefore(cur1, cur2);\r\n      var cur2before3 = cursorIsBefore(cur2, cur3);\r\n      return cur1before2 && cur2before3;\r\n    }\r\n    function lineLength(cm, lineNum) {\r\n      return cm.getLine(lineNum).length;\r\n    }\r\n    function trim(s) {\r\n      if (s.trim) {\r\n        return s.trim();\r\n      }\r\n      return s.replace(/^\\s+|\\s+$/g, '');\r\n    }\r\n    function escapeRegex(s) {\r\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\r\n    }\r\n    function extendLineToColumn(cm, lineNum, column) {\r\n      var endCh = lineLength(cm, lineNum);\r\n      var spaces = new Array(column-endCh+1).join(' ');\r\n      cm.setCursor(Pos(lineNum, endCh));\r\n      cm.replaceRange(spaces, cm.getCursor());\r\n    }\r\n    // This functions selects a rectangular block\r\n    // of text with selectionEnd as any of its corner\r\n    // Height of block:\r\n    // Difference in selectionEnd.line and first/last selection.line\r\n    // Width of the block:\r\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\r\n    function selectBlock(cm, selectionEnd) {\r\n      var selections = [], ranges = cm.listSelections();\r\n      var head = copyCursor(cm.clipPos(selectionEnd));\r\n      var isClipped = !cursorEqual(selectionEnd, head);\r\n      var curHead = cm.getCursor('head');\r\n      var primIndex = getIndex(ranges, curHead);\r\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\r\n      var max = ranges.length - 1;\r\n      var index = max - primIndex > primIndex ? max : 0;\r\n      var base = ranges[index].anchor;\r\n\r\n      var firstLine = Math.min(base.line, head.line);\r\n      var lastLine = Math.max(base.line, head.line);\r\n      var baseCh = base.ch, headCh = head.ch;\r\n\r\n      var dir = ranges[index].head.ch - baseCh;\r\n      var newDir = headCh - baseCh;\r\n      if (dir > 0 && newDir <= 0) {\r\n        baseCh++;\r\n        if (!isClipped) { headCh--; }\r\n      } else if (dir < 0 && newDir >= 0) {\r\n        baseCh--;\r\n        if (!wasClipped) { headCh++; }\r\n      } else if (dir < 0 && newDir == -1) {\r\n        baseCh--;\r\n        headCh++;\r\n      }\r\n      for (var line = firstLine; line <= lastLine; line++) {\r\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\r\n        selections.push(range);\r\n      }\r\n      cm.setSelections(selections);\r\n      selectionEnd.ch = headCh;\r\n      base.ch = baseCh;\r\n      return base;\r\n    }\r\n    function selectForInsert(cm, head, height) {\r\n      var sel = [];\r\n      for (var i = 0; i < height; i++) {\r\n        var lineHead = offsetCursor(head, i, 0);\r\n        sel.push({anchor: lineHead, head: lineHead});\r\n      }\r\n      cm.setSelections(sel, 0);\r\n    }\r\n    // getIndex returns the index of the cursor in the selections.\r\n    function getIndex(ranges, cursor, end) {\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\r\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\r\n        if (atAnchor || atHead) {\r\n          return i;\r\n        }\r\n      }\r\n      return -1;\r\n    }\r\n    function getSelectedAreaRange(cm, vim) {\r\n      var lastSelection = vim.lastSelection;\r\n      var getCurrentSelectedAreaRange = function() {\r\n        var selections = cm.listSelections();\r\n        var start =  selections[0];\r\n        var end = selections[selections.length-1];\r\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\r\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\r\n        return [selectionStart, selectionEnd];\r\n      };\r\n      var getLastSelectedAreaRange = function() {\r\n        var selectionStart = cm.getCursor();\r\n        var selectionEnd = cm.getCursor();\r\n        var block = lastSelection.visualBlock;\r\n        if (block) {\r\n          var width = block.width;\r\n          var height = block.height;\r\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\r\n          var selections = [];\r\n          // selectBlock creates a 'proper' rectangular block.\r\n          // We do not want that in all cases, so we manually set selections.\r\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\r\n            var anchor = Pos(i, selectionStart.ch);\r\n            var head = Pos(i, selectionEnd.ch);\r\n            var range = {anchor: anchor, head: head};\r\n            selections.push(range);\r\n          }\r\n          cm.setSelections(selections);\r\n        } else {\r\n          var start = lastSelection.anchorMark.find();\r\n          var end = lastSelection.headMark.find();\r\n          var line = end.line - start.line;\r\n          var ch = end.ch - start.ch;\r\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\r\n          if (lastSelection.visualLine) {\r\n            selectionStart = Pos(selectionStart.line, 0);\r\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\r\n          }\r\n          cm.setSelection(selectionStart, selectionEnd);\r\n        }\r\n        return [selectionStart, selectionEnd];\r\n      };\r\n      if (!vim.visualMode) {\r\n      // In case of replaying the action.\r\n        return getLastSelectedAreaRange();\r\n      } else {\r\n        return getCurrentSelectedAreaRange();\r\n      }\r\n    }\r\n    // Updates the previous selection with the current selection's values. This\r\n    // should only be called in visual mode.\r\n    function updateLastSelection(cm, vim) {\r\n      var anchor = vim.sel.anchor;\r\n      var head = vim.sel.head;\r\n      // To accommodate the effect of lastPastedText in the last selection\r\n      if (vim.lastPastedText) {\r\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\r\n        vim.lastPastedText = null;\r\n      }\r\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\r\n                           'headMark': cm.setBookmark(head),\r\n                           'anchor': copyCursor(anchor),\r\n                           'head': copyCursor(head),\r\n                           'visualMode': vim.visualMode,\r\n                           'visualLine': vim.visualLine,\r\n                           'visualBlock': vim.visualBlock};\r\n    }\r\n    function expandSelection(cm, start, end) {\r\n      var sel = cm.state.vim.sel;\r\n      var head = sel.head;\r\n      var anchor = sel.anchor;\r\n      var tmp;\r\n      if (cursorIsBefore(end, start)) {\r\n        tmp = end;\r\n        end = start;\r\n        start = tmp;\r\n      }\r\n      if (cursorIsBefore(head, anchor)) {\r\n        head = cursorMin(start, head);\r\n        anchor = cursorMax(anchor, end);\r\n      } else {\r\n        anchor = cursorMin(start, anchor);\r\n        head = cursorMax(head, end);\r\n        head = offsetCursor(head, 0, -1);\r\n        if (head.ch == -1 && head.line != cm.firstLine()) {\r\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\r\n        }\r\n      }\r\n      return [anchor, head];\r\n    }\r\n    /**\r\n     * Updates the CodeMirror selection to match the provided vim selection.\r\n     * If no arguments are given, it uses the current vim selection state.\r\n     */\r\n    function updateCmSelection(cm, sel, mode) {\r\n      var vim = cm.state.vim;\r\n      sel = sel || vim.sel;\r\n      var mode = mode ||\r\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\r\n      var cmSel = makeCmSelection(cm, sel, mode);\r\n      cm.setSelections(cmSel.ranges, cmSel.primary);\r\n      updateFakeCursor(cm);\r\n    }\r\n    function makeCmSelection(cm, sel, mode, exclusive) {\r\n      var head = copyCursor(sel.head);\r\n      var anchor = copyCursor(sel.anchor);\r\n      if (mode == 'char') {\r\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\r\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\r\n        head = offsetCursor(sel.head, 0, headOffset);\r\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\r\n        return {\r\n          ranges: [{anchor: anchor, head: head}],\r\n          primary: 0\r\n        };\r\n      } else if (mode == 'line') {\r\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\r\n          anchor.ch = 0;\r\n\r\n          var lastLine = cm.lastLine();\r\n          if (head.line > lastLine) {\r\n            head.line = lastLine;\r\n          }\r\n          head.ch = lineLength(cm, head.line);\r\n        } else {\r\n          head.ch = 0;\r\n          anchor.ch = lineLength(cm, anchor.line);\r\n        }\r\n        return {\r\n          ranges: [{anchor: anchor, head: head}],\r\n          primary: 0\r\n        };\r\n      } else if (mode == 'block') {\r\n        var top = Math.min(anchor.line, head.line),\r\n            left = Math.min(anchor.ch, head.ch),\r\n            bottom = Math.max(anchor.line, head.line),\r\n            right = Math.max(anchor.ch, head.ch) + 1;\r\n        var height = bottom - top + 1;\r\n        var primary = head.line == top ? 0 : height - 1;\r\n        var ranges = [];\r\n        for (var i = 0; i < height; i++) {\r\n          ranges.push({\r\n            anchor: Pos(top + i, left),\r\n            head: Pos(top + i, right)\r\n          });\r\n        }\r\n        return {\r\n          ranges: ranges,\r\n          primary: primary\r\n        };\r\n      }\r\n    }\r\n    function getHead(cm) {\r\n      var cur = cm.getCursor('head');\r\n      if (cm.getSelection().length == 1) {\r\n        // Small corner case when only 1 character is selected. The \"real\"\r\n        // head is the left of head and anchor.\r\n        cur = cursorMin(cur, cm.getCursor('anchor'));\r\n      }\r\n      return cur;\r\n    }\r\n\r\n    /**\r\n     * If moveHead is set to false, the CodeMirror selection will not be\r\n     * touched. The caller assumes the responsibility of putting the cursor\r\n    * in the right place.\r\n     */\r\n    function exitVisualMode(cm, moveHead) {\r\n      var vim = cm.state.vim;\r\n      if (moveHead !== false) {\r\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\r\n      }\r\n      updateLastSelection(cm, vim);\r\n      vim.visualMode = false;\r\n      vim.visualLine = false;\r\n      vim.visualBlock = false;\r\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\r\n      if (vim.fakeCursor) {\r\n        vim.fakeCursor.clear();\r\n      }\r\n    }\r\n\r\n    // Remove any trailing newlines from the selection. For\r\n    // example, with the caret at the start of the last word on the line,\r\n    // 'dw' should word, but not the newline, while 'w' should advance the\r\n    // caret to the first character of the next line.\r\n    function clipToLine(cm, curStart, curEnd) {\r\n      var selection = cm.getRange(curStart, curEnd);\r\n      // Only clip if the selection ends with trailing newline + whitespace\r\n      if (/\\n\\s*$/.test(selection)) {\r\n        var lines = selection.split('\\n');\r\n        // We know this is all whitespace.\r\n        lines.pop();\r\n\r\n        // Cases:\r\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\r\n        // 2. Last word is not an empty line - clip the trailing '\\n'\r\n        var line;\r\n        // Find the line containing the last word, and clip all whitespace up\r\n        // to it.\r\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\r\n          curEnd.line--;\r\n          curEnd.ch = 0;\r\n        }\r\n        // If the last word is not an empty line, clip an additional newline\r\n        if (line) {\r\n          curEnd.line--;\r\n          curEnd.ch = lineLength(cm, curEnd.line);\r\n        } else {\r\n          curEnd.ch = 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Expand the selection to line ends.\r\n    function expandSelectionToLine(_cm, curStart, curEnd) {\r\n      curStart.ch = 0;\r\n      curEnd.ch = 0;\r\n      curEnd.line++;\r\n    }\r\n\r\n    function findFirstNonWhiteSpaceCharacter(text) {\r\n      if (!text) {\r\n        return 0;\r\n      }\r\n      var firstNonWS = text.search(/\\S/);\r\n      return firstNonWS == -1 ? text.length : firstNonWS;\r\n    }\r\n\r\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\r\n      var cur = getHead(cm);\r\n      var line = cm.getLine(cur.line);\r\n      var idx = cur.ch;\r\n\r\n      // Seek to first word or non-whitespace character, depending on if\r\n      // noSymbol is true.\r\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\r\n      while (!test(line.charAt(idx))) {\r\n        idx++;\r\n        if (idx >= line.length) { return null; }\r\n      }\r\n\r\n      if (bigWord) {\r\n        test = bigWordCharTest[0];\r\n      } else {\r\n        test = wordCharTest[0];\r\n        if (!test(line.charAt(idx))) {\r\n          test = wordCharTest[1];\r\n        }\r\n      }\r\n\r\n      var end = idx, start = idx;\r\n      while (test(line.charAt(end)) && end < line.length) { end++; }\r\n      while (test(line.charAt(start)) && start >= 0) { start--; }\r\n      start++;\r\n\r\n      if (inclusive) {\r\n        // If present, include all whitespace after word.\r\n        // Otherwise, include all whitespace before word, except indentation.\r\n        var wordEnd = end;\r\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\r\n        if (wordEnd == end) {\r\n          var wordStart = start;\r\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\r\n          if (!start) { start = wordStart; }\r\n        }\r\n      }\r\n      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };\r\n    }\r\n\r\n    function recordJumpPosition(cm, oldCur, newCur) {\r\n      if (!cursorEqual(oldCur, newCur)) {\r\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\r\n      }\r\n    }\r\n\r\n    function recordLastCharacterSearch(increment, args) {\r\n        vimGlobalState.lastCharacterSearch.increment = increment;\r\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\r\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\r\n    }\r\n\r\n    var symbolToMode = {\r\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\r\n        '[': 'section', ']': 'section',\r\n        '*': 'comment', '/': 'comment',\r\n        'm': 'method', 'M': 'method',\r\n        '#': 'preprocess'\r\n    };\r\n    var findSymbolModes = {\r\n      bracket: {\r\n        isComplete: function(state) {\r\n          if (state.nextCh === state.symb) {\r\n            state.depth++;\r\n            if (state.depth >= 1)return true;\r\n          } else if (state.nextCh === state.reverseSymb) {\r\n            state.depth--;\r\n          }\r\n          return false;\r\n        }\r\n      },\r\n      section: {\r\n        init: function(state) {\r\n          state.curMoveThrough = true;\r\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\r\n        },\r\n        isComplete: function(state) {\r\n          return state.index === 0 && state.nextCh === state.symb;\r\n        }\r\n      },\r\n      comment: {\r\n        isComplete: function(state) {\r\n          var found = state.lastCh === '*' && state.nextCh === '/';\r\n          state.lastCh = state.nextCh;\r\n          return found;\r\n        }\r\n      },\r\n      // TODO: The original Vim implementation only operates on level 1 and 2.\r\n      // The current implementation doesn't check for code block level and\r\n      // therefore it operates on any levels.\r\n      method: {\r\n        init: function(state) {\r\n          state.symb = (state.symb === 'm' ? '{' : '}');\r\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\r\n        },\r\n        isComplete: function(state) {\r\n          if (state.nextCh === state.symb)return true;\r\n          return false;\r\n        }\r\n      },\r\n      preprocess: {\r\n        init: function(state) {\r\n          state.index = 0;\r\n        },\r\n        isComplete: function(state) {\r\n          if (state.nextCh === '#') {\r\n            var token = state.lineText.match(/#(\\w+)/)[1];\r\n            if (token === 'endif') {\r\n              if (state.forward && state.depth === 0) {\r\n                return true;\r\n              }\r\n              state.depth++;\r\n            } else if (token === 'if') {\r\n              if (!state.forward && state.depth === 0) {\r\n                return true;\r\n              }\r\n              state.depth--;\r\n            }\r\n            if (token === 'else' && state.depth === 0)return true;\r\n          }\r\n          return false;\r\n        }\r\n      }\r\n    };\r\n    function findSymbol(cm, repeat, forward, symb) {\r\n      var cur = copyCursor(cm.getCursor());\r\n      var increment = forward ? 1 : -1;\r\n      var endLine = forward ? cm.lineCount() : -1;\r\n      var curCh = cur.ch;\r\n      var line = cur.line;\r\n      var lineText = cm.getLine(line);\r\n      var state = {\r\n        lineText: lineText,\r\n        nextCh: lineText.charAt(curCh),\r\n        lastCh: null,\r\n        index: curCh,\r\n        symb: symb,\r\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\r\n        forward: forward,\r\n        depth: 0,\r\n        curMoveThrough: false\r\n      };\r\n      var mode = symbolToMode[symb];\r\n      if (!mode)return cur;\r\n      var init = findSymbolModes[mode].init;\r\n      var isComplete = findSymbolModes[mode].isComplete;\r\n      if (init) { init(state); }\r\n      while (line !== endLine && repeat) {\r\n        state.index += increment;\r\n        state.nextCh = state.lineText.charAt(state.index);\r\n        if (!state.nextCh) {\r\n          line += increment;\r\n          state.lineText = cm.getLine(line) || '';\r\n          if (increment > 0) {\r\n            state.index = 0;\r\n          } else {\r\n            var lineLen = state.lineText.length;\r\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\r\n          }\r\n          state.nextCh = state.lineText.charAt(state.index);\r\n        }\r\n        if (isComplete(state)) {\r\n          cur.line = line;\r\n          cur.ch = state.index;\r\n          repeat--;\r\n        }\r\n      }\r\n      if (state.nextCh || state.curMoveThrough) {\r\n        return Pos(line, state.index);\r\n      }\r\n      return cur;\r\n    }\r\n\r\n    /*\r\n     * Returns the boundaries of the next word. If the cursor in the middle of\r\n     * the word, then returns the boundaries of the current word, starting at\r\n     * the cursor. If the cursor is at the start/end of a word, and we are going\r\n     * forward/backward, respectively, find the boundaries of the next word.\r\n     *\r\n     * @param {CodeMirror} cm CodeMirror object.\r\n     * @param {Cursor} cur The cursor position.\r\n     * @param {boolean} forward True to search forward. False to search\r\n     *     backward.\r\n     * @param {boolean} bigWord True if punctuation count as part of the word.\r\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\r\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\r\n     *     as words.\r\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\r\n     *     the word, or null if there are no more words.\r\n     */\r\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\r\n      var lineNum = cur.line;\r\n      var pos = cur.ch;\r\n      var line = cm.getLine(lineNum);\r\n      var dir = forward ? 1 : -1;\r\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\r\n\r\n      if (emptyLineIsWord && line == '') {\r\n        lineNum += dir;\r\n        line = cm.getLine(lineNum);\r\n        if (!isLine(cm, lineNum)) {\r\n          return null;\r\n        }\r\n        pos = (forward) ? 0 : line.length;\r\n      }\r\n\r\n      while (true) {\r\n        if (emptyLineIsWord && line == '') {\r\n          return { from: 0, to: 0, line: lineNum };\r\n        }\r\n        var stop = (dir > 0) ? line.length : -1;\r\n        var wordStart = stop, wordEnd = stop;\r\n        // Find bounds of next word.\r\n        while (pos != stop) {\r\n          var foundWord = false;\r\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\r\n            if (charTests[i](line.charAt(pos))) {\r\n              wordStart = pos;\r\n              // Advance to end of word.\r\n              while (pos != stop && charTests[i](line.charAt(pos))) {\r\n                pos += dir;\r\n              }\r\n              wordEnd = pos;\r\n              foundWord = wordStart != wordEnd;\r\n              if (wordStart == cur.ch && lineNum == cur.line &&\r\n                  wordEnd == wordStart + dir) {\r\n                // We started at the end of a word. Find the next one.\r\n                continue;\r\n              } else {\r\n                return {\r\n                  from: Math.min(wordStart, wordEnd + 1),\r\n                  to: Math.max(wordStart, wordEnd),\r\n                  line: lineNum };\r\n              }\r\n            }\r\n          }\r\n          if (!foundWord) {\r\n            pos += dir;\r\n          }\r\n        }\r\n        // Advance to next/prev line.\r\n        lineNum += dir;\r\n        if (!isLine(cm, lineNum)) {\r\n          return null;\r\n        }\r\n        line = cm.getLine(lineNum);\r\n        pos = (dir > 0) ? 0 : line.length;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @param {CodeMirror} cm CodeMirror object.\r\n     * @param {Pos} cur The position to start from.\r\n     * @param {int} repeat Number of words to move past.\r\n     * @param {boolean} forward True to search forward. False to search\r\n     *     backward.\r\n     * @param {boolean} wordEnd True to move to end of word. False to move to\r\n     *     beginning of word.\r\n     * @param {boolean} bigWord True if punctuation count as part of the word.\r\n     *     False if only alphabet characters count as part of the word.\r\n     * @return {Cursor} The position the cursor should move to.\r\n     */\r\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\r\n      var curStart = copyCursor(cur);\r\n      var words = [];\r\n      if (forward && !wordEnd || !forward && wordEnd) {\r\n        repeat++;\r\n      }\r\n      // For 'e', empty lines are not considered words, go figure.\r\n      var emptyLineIsWord = !(forward && wordEnd);\r\n      for (var i = 0; i < repeat; i++) {\r\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\r\n        if (!word) {\r\n          var eodCh = lineLength(cm, cm.lastLine());\r\n          words.push(forward\r\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\r\n              : {line: 0, from: 0, to: 0});\r\n          break;\r\n        }\r\n        words.push(word);\r\n        cur = Pos(word.line, forward ? (word.to - 1) : word.from);\r\n      }\r\n      var shortCircuit = words.length != repeat;\r\n      var firstWord = words[0];\r\n      var lastWord = words.pop();\r\n      if (forward && !wordEnd) {\r\n        // w\r\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\r\n          // We did not start in the middle of a word. Discard the extra word at the end.\r\n          lastWord = words.pop();\r\n        }\r\n        return Pos(lastWord.line, lastWord.from);\r\n      } else if (forward && wordEnd) {\r\n        return Pos(lastWord.line, lastWord.to - 1);\r\n      } else if (!forward && wordEnd) {\r\n        // ge\r\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\r\n          // We did not start in the middle of a word. Discard the extra word at the end.\r\n          lastWord = words.pop();\r\n        }\r\n        return Pos(lastWord.line, lastWord.to);\r\n      } else {\r\n        // b\r\n        return Pos(lastWord.line, lastWord.from);\r\n      }\r\n    }\r\n\r\n    function moveToCharacter(cm, repeat, forward, character) {\r\n      var cur = cm.getCursor();\r\n      var start = cur.ch;\r\n      var idx;\r\n      for (var i = 0; i < repeat; i ++) {\r\n        var line = cm.getLine(cur.line);\r\n        idx = charIdxInLine(start, line, character, forward, true);\r\n        if (idx == -1) {\r\n          return null;\r\n        }\r\n        start = idx;\r\n      }\r\n      return Pos(cm.getCursor().line, idx);\r\n    }\r\n\r\n    function moveToColumn(cm, repeat) {\r\n      // repeat is always >= 1, so repeat - 1 always corresponds\r\n      // to the column we want to go to.\r\n      var line = cm.getCursor().line;\r\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\r\n    }\r\n\r\n    function updateMark(cm, vim, markName, pos) {\r\n      if (!inArray(markName, validMarks)) {\r\n        return;\r\n      }\r\n      if (vim.marks[markName]) {\r\n        vim.marks[markName].clear();\r\n      }\r\n      vim.marks[markName] = cm.setBookmark(pos);\r\n    }\r\n\r\n    function charIdxInLine(start, line, character, forward, includeChar) {\r\n      // Search for char in line.\r\n      // motion_options: {forward, includeChar}\r\n      // If includeChar = true, include it too.\r\n      // If forward = true, search forward, else search backwards.\r\n      // If char is not found on this line, do nothing\r\n      var idx;\r\n      if (forward) {\r\n        idx = line.indexOf(character, start + 1);\r\n        if (idx != -1 && !includeChar) {\r\n          idx -= 1;\r\n        }\r\n      } else {\r\n        idx = line.lastIndexOf(character, start - 1);\r\n        if (idx != -1 && !includeChar) {\r\n          idx += 1;\r\n        }\r\n      }\r\n      return idx;\r\n    }\r\n\r\n    function findParagraph(cm, head, repeat, dir, inclusive) {\r\n      var line = head.line;\r\n      var min = cm.firstLine();\r\n      var max = cm.lastLine();\r\n      var start, end, i = line;\r\n      function isEmpty(i) { return !/\\S/.test(cm.getLine(i)); } // ace_patch\r\n      function isBoundary(i, dir, any) {\r\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\r\n        return !isEmpty(i) && isEmpty(i + dir);\r\n      }\r\n      function skipFold(i) {\r\n          dir = dir > 0 ? 1 : -1;\r\n          var foldLine = cm.ace.session.getFoldLine(i);\r\n          if (foldLine) {\r\n              if (i + dir > foldLine.start.row && i + dir < foldLine.end.row)\r\n                  dir = (dir > 0 ? foldLine.end.row : foldLine.start.row) - i;\r\n          }\r\n      }\r\n      if (dir) {\r\n        while (min <= i && i <= max && repeat > 0) {\r\n          skipFold(i);\r\n          if (isBoundary(i, dir)) { repeat--; }\r\n          i += dir;\r\n        }\r\n        return new Pos(i, 0);\r\n      }\r\n\r\n      var vim = cm.state.vim;\r\n      if (vim.visualLine && isBoundary(line, 1, true)) {\r\n        var anchor = vim.sel.anchor;\r\n        if (isBoundary(anchor.line, -1, true)) {\r\n          if (!inclusive || anchor.line != line) {\r\n            line += 1;\r\n          }\r\n        }\r\n      }\r\n      var startState = isEmpty(line);\r\n      for (i = line; i <= max && repeat; i++) {\r\n        if (isBoundary(i, 1, true)) {\r\n          if (!inclusive || isEmpty(i) != startState) {\r\n            repeat--;\r\n          }\r\n        }\r\n      }\r\n      end = new Pos(i, 0);\r\n      // select boundary before paragraph for the last one\r\n      if (i > max && !startState) { startState = true; }\r\n      else { inclusive = false; }\r\n      for (i = line; i > min; i--) {\r\n        if (!inclusive || isEmpty(i) == startState || i == line) {\r\n          if (isBoundary(i, -1, true)) { break; }\r\n        }\r\n      }\r\n      start = new Pos(i, 0);\r\n      return { start: start, end: end };\r\n    }\r\n\r\n    // TODO: perhaps this finagling of start and end positions belonds\r\n    // in codemirror/replaceRange?\r\n    function selectCompanionObject(cm, head, symb, inclusive) {\r\n      var cur = head, start, end;\r\n\r\n      var bracketRegexp = ({\r\n        '(': /[()]/, ')': /[()]/,\r\n        '[': /[[\\]]/, ']': /[[\\]]/,\r\n        '{': /[{}]/, '}': /[{}]/,\r\n        '<': /[<>]/, '>': /[<>]/})[symb];\r\n      var openSym = ({\r\n        '(': '(', ')': '(',\r\n        '[': '[', ']': '[',\r\n        '{': '{', '}': '{',\r\n        '<': '<', '>': '<'})[symb];\r\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\r\n      // Due to the behavior of scanForBracket, we need to add an offset if the\r\n      // cursor is on a matching open bracket.\r\n      var offset = curChar === openSym ? 1 : 0;\r\n\r\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, null, {'bracketRegex': bracketRegexp});\r\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, null, {'bracketRegex': bracketRegexp});\r\n\r\n      if (!start || !end) {\r\n        return { start: cur, end: cur };\r\n      }\r\n\r\n      start = start.pos;\r\n      end = end.pos;\r\n\r\n      if ((start.line == end.line && start.ch > end.ch)\r\n          || (start.line > end.line)) {\r\n        var tmp = start;\r\n        start = end;\r\n        end = tmp;\r\n      }\r\n\r\n      if (inclusive) {\r\n        end.ch += 1;\r\n      } else {\r\n        start.ch += 1;\r\n      }\r\n\r\n      return { start: start, end: end };\r\n    }\r\n\r\n    // Takes in a symbol and a cursor and tries to simulate text objects that\r\n    // have identical opening and closing symbols\r\n    // TODO support across multiple lines\r\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\r\n      var cur = copyCursor(head);\r\n      var line = cm.getLine(cur.line);\r\n      var chars = line.split('');\r\n      var start, end, i, len;\r\n      var firstIndex = chars.indexOf(symb);\r\n\r\n      // the decision tree is to always look backwards for the beginning first,\r\n      // but if the cursor is in front of the first instance of the symb,\r\n      // then move the cursor forward\r\n      if (cur.ch < firstIndex) {\r\n        cur.ch = firstIndex;\r\n        // Why is this line even here???\r\n        // cm.setCursor(cur.line, firstIndex+1);\r\n      }\r\n      // otherwise if the cursor is currently on the closing symbol\r\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\r\n        end = cur.ch; // assign end to the current cursor\r\n        --cur.ch; // make sure to look backwards\r\n      }\r\n\r\n      // if we're currently on the symbol, we've got a start\r\n      if (chars[cur.ch] == symb && !end) {\r\n        start = cur.ch + 1; // assign start to ahead of the cursor\r\n      } else {\r\n        // go backwards to find the start\r\n        for (i = cur.ch; i > -1 && !start; i--) {\r\n          if (chars[i] == symb) {\r\n            start = i + 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      // look forwards for the end symbol\r\n      if (start && !end) {\r\n        for (i = start, len = chars.length; i < len && !end; i++) {\r\n          if (chars[i] == symb) {\r\n            end = i;\r\n          }\r\n        }\r\n      }\r\n\r\n      // nothing found\r\n      if (!start || !end) {\r\n        return { start: cur, end: cur };\r\n      }\r\n\r\n      // include the symbols\r\n      if (inclusive) {\r\n        --start; ++end;\r\n      }\r\n\r\n      return {\r\n        start: Pos(cur.line, start),\r\n        end: Pos(cur.line, end)\r\n      };\r\n    }\r\n\r\n    // Search functions\r\n    defineOption('pcre', true, 'boolean');\r\n    function SearchState() {}\r\n    SearchState.prototype = {\r\n      getQuery: function() {\r\n        return vimGlobalState.query;\r\n      },\r\n      setQuery: function(query) {\r\n        vimGlobalState.query = query;\r\n      },\r\n      getOverlay: function() {\r\n        return this.searchOverlay;\r\n      },\r\n      setOverlay: function(overlay) {\r\n        this.searchOverlay = overlay;\r\n      },\r\n      isReversed: function() {\r\n        return vimGlobalState.isReversed;\r\n      },\r\n      setReversed: function(reversed) {\r\n        vimGlobalState.isReversed = reversed;\r\n      },\r\n      getScrollbarAnnotate: function() {\r\n        return this.annotate;\r\n      },\r\n      setScrollbarAnnotate: function(annotate) {\r\n        this.annotate = annotate;\r\n      }\r\n    };\r\n    function getSearchState(cm) {\r\n      var vim = cm.state.vim;\r\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\r\n    }\r\n    function dialog(cm, template, shortText, onClose, options) {\r\n      if (cm.openDialog) {\r\n        cm.openDialog(template, onClose, { bottom: true, value: options.value,\r\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\r\n            selectValueOnOpen: false, onClose: function() {\r\n              if (cm.state.vim) {\r\n                cm.state.vim.status = \"\";\r\n                cm.ace.renderer.$loop.schedule(cm.ace.renderer.CHANGE_CURSOR);\r\n              }\r\n            }});\r\n      }\r\n      else {\r\n        onClose(prompt(shortText, ''));\r\n      }\r\n    }\r\n    \r\n    function splitBySlash(argString) {\r\n      return splitBySeparator(argString, '/');\r\n    }\r\n  \r\n    function findUnescapedSlashes(argString) {\r\n      return findUnescapedSeparators(argString, '/');\r\n    }\r\n\r\n    function splitBySeparator(argString, separator) {\r\n      var slashes = findUnescapedSeparators(argString, separator) || [];\r\n      if (!slashes.length) return [];\r\n      var tokens = [];\r\n      // in case of strings like foo/bar\r\n      if (slashes[0] !== 0) return;\r\n      for (var i = 0; i < slashes.length; i++) {\r\n        if (typeof slashes[i] == 'number')\r\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\r\n      }\r\n      return tokens;\r\n    }\r\n\r\n    function findUnescapedSeparators(str, separator) {\r\n      if (!separator)\r\n        separator = '/';\r\n\r\n      var escapeNextChar = false;\r\n      var slashes = [];\r\n      for (var i = 0; i < str.length; i++) {\r\n        var c = str.charAt(i);\r\n        if (!escapeNextChar && c == separator) {\r\n          slashes.push(i);\r\n        }\r\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\r\n      }\r\n      return slashes;\r\n    }\r\n\r\n    // Translates a search string from ex (vim) syntax into javascript form.\r\n    function translateRegex(str) {\r\n      // When these match, add a '\\' if unescaped or remove one if escaped.\r\n      var specials = '|(){';\r\n      // Remove, but never add, a '\\' for these.\r\n      var unescape = '}';\r\n      var escapeNextChar = false;\r\n      var out = [];\r\n      for (var i = -1; i < str.length; i++) {\r\n        var c = str.charAt(i) || '';\r\n        var n = str.charAt(i+1) || '';\r\n        var specialComesNext = (n && specials.indexOf(n) != -1);\r\n        if (escapeNextChar) {\r\n          if (c !== '\\\\' || !specialComesNext) {\r\n            out.push(c);\r\n          }\r\n          escapeNextChar = false;\r\n        } else {\r\n          if (c === '\\\\') {\r\n            escapeNextChar = true;\r\n            // Treat the unescape list as special for removing, but not adding '\\'.\r\n            if (n && unescape.indexOf(n) != -1) {\r\n              specialComesNext = true;\r\n            }\r\n            // Not passing this test means removing a '\\'.\r\n            if (!specialComesNext || n === '\\\\') {\r\n              out.push(c);\r\n            }\r\n          } else {\r\n            out.push(c);\r\n            if (specialComesNext && n !== '\\\\') {\r\n              out.push('\\\\');\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return out.join('');\r\n    }\r\n\r\n    // Translates the replace part of a search and replace from ex (vim) syntax into\r\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\r\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\r\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\r\n    function translateRegexReplace(str) {\r\n      var escapeNextChar = false;\r\n      var out = [];\r\n      for (var i = -1; i < str.length; i++) {\r\n        var c = str.charAt(i) || '';\r\n        var n = str.charAt(i+1) || '';\r\n        if (charUnescapes[c + n]) {\r\n          out.push(charUnescapes[c+n]);\r\n          i++;\r\n        } else if (escapeNextChar) {\r\n          // At any point in the loop, escapeNextChar is true if the previous\r\n          // character was a '\\' and was not escaped.\r\n          out.push(c);\r\n          escapeNextChar = false;\r\n        } else {\r\n          if (c === '\\\\') {\r\n            escapeNextChar = true;\r\n            if ((isNumber(n) || n === '$')) {\r\n              out.push('$');\r\n            } else if (n !== '/' && n !== '\\\\') {\r\n              out.push('\\\\');\r\n            }\r\n          } else {\r\n            if (c === '$') {\r\n              out.push('$');\r\n            }\r\n            out.push(c);\r\n            if (n === '/') {\r\n              out.push('\\\\');\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return out.join('');\r\n    }\r\n\r\n    // Unescape \\ and / in the replace part, for PCRE mode.\r\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\r\n    function unescapeRegexReplace(str) {\r\n      var stream = new CodeMirror.StringStream(str);\r\n      var output = [];\r\n      while (!stream.eol()) {\r\n        // Search for \\.\r\n        while (stream.peek() && stream.peek() != '\\\\') {\r\n          output.push(stream.next());\r\n        }\r\n        var matched = false;\r\n        for (var matcher in unescapes) {\r\n          if (stream.match(matcher, true)) {\r\n            matched = true;\r\n            output.push(unescapes[matcher]);\r\n            break;\r\n          }\r\n        }\r\n        if (!matched) {\r\n          // Don't change anything\r\n          output.push(stream.next());\r\n        }\r\n      }\r\n      return output.join('');\r\n    }\r\n\r\n    /**\r\n     * Extract the regular expression from the query and return a Regexp object.\r\n     * Returns null if the query is blank.\r\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\r\n     * If smartCase is passed in, and the query contains upper case letters,\r\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\r\n     * If the query contains the /i in the flag part of the regular expression,\r\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\r\n     *   through to the Regex object.\r\n     */\r\n    function parseQuery(query, ignoreCase, smartCase) {\r\n      // First update the last search register\r\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\r\n      lastSearchRegister.setText(query);\r\n      // Check if the query is already a regex.\r\n      if (query instanceof RegExp) { return query; }\r\n      // First try to extract regex + flags from the input. If no flags found,\r\n      // extract just the regex. IE does not accept flags directly defined in\r\n      // the regex string in the form /regex/flags\r\n      var slashes = findUnescapedSlashes(query);\r\n      var regexPart;\r\n      var forceIgnoreCase;\r\n      if (!slashes.length) {\r\n        // Query looks like 'regexp'\r\n        regexPart = query;\r\n      } else {\r\n        // Query looks like 'regexp/...'\r\n        regexPart = query.substring(0, slashes[0]);\r\n        var flagsPart = query.substring(slashes[0]);\r\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\r\n      }\r\n      if (!regexPart) {\r\n        return null;\r\n      }\r\n      if (!getOption('pcre')) {\r\n        regexPart = translateRegex(regexPart);\r\n      }\r\n      if (smartCase) {\r\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\r\n      }\r\n      var regexp = new RegExp(regexPart,\r\n          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);\r\n      return regexp;\r\n    }\r\n    function showConfirm(cm, text) {\r\n      if (cm.openNotification) {\r\n        cm.openNotification('<span style=\"color: red\">' + text + '</span>',\r\n                            {bottom: true, duration: 5000});\r\n      } else {\r\n        alert(text);\r\n      }\r\n    }\r\n    function makePrompt(prefix, desc) {\r\n      var raw = '<span style=\"font-family: monospace; white-space: pre\">' +\r\n          (prefix || \"\") + '<input type=\"text\" autocorrect=\"off\" autocapitalize=\"none\" autocomplete=\"off\"></span>';\r\n      if (desc)\r\n        raw += ' <span style=\"color: #888\">' + desc + '</span>';\r\n      return raw;\r\n    }\r\n    var searchPromptDesc = '(Javascript regexp)';\r\n    function showPrompt(cm, options) {\r\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\r\n      var prompt = makePrompt(options.prefix, options.desc);\r\n      dialog(cm, prompt, shortText, options.onClose, options);\r\n    }\r\n    function regexEqual(r1, r2) {\r\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\r\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\r\n          for (var i = 0; i < props.length; i++) {\r\n              var prop = props[i];\r\n              if (r1[prop] !== r2[prop]) {\r\n                  return false;\r\n              }\r\n          }\r\n          return true;\r\n      }\r\n      return false;\r\n    }\r\n    // Returns true if the query is valid.\r\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\r\n      if (!rawQuery) {\r\n        return;\r\n      }\r\n      var state = getSearchState(cm);\r\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\r\n      if (!query) {\r\n        return;\r\n      }\r\n      highlightSearchMatches(cm, query);\r\n      if (regexEqual(query, state.getQuery())) {\r\n        return query;\r\n      }\r\n      state.setQuery(query);\r\n      return query;\r\n    }\r\n    function searchOverlay(query) {\r\n      if (query.source.charAt(0) == '^') {\r\n        var matchSol = true;\r\n      }\r\n      return {\r\n        token: function(stream) {\r\n          if (matchSol && !stream.sol()) {\r\n            stream.skipToEnd();\r\n            return;\r\n          }\r\n          var match = stream.match(query, false);\r\n          if (match) {\r\n            if (match[0].length == 0) {\r\n              // Matched empty string, skip to next.\r\n              stream.next();\r\n              return 'searching';\r\n            }\r\n            if (!stream.sol()) {\r\n              // Backtrack 1 to match \\b\r\n              stream.backUp(1);\r\n              if (!query.exec(stream.next() + match[0])) {\r\n                stream.next();\r\n                return null;\r\n              }\r\n            }\r\n            stream.match(query);\r\n            return 'searching';\r\n          }\r\n          while (!stream.eol()) {\r\n            stream.next();\r\n            if (stream.match(query, false)) break;\r\n          }\r\n        },\r\n        query: query\r\n      };\r\n    }\r\n    function highlightSearchMatches(cm, query) {\r\n      var searchState = getSearchState(cm);\r\n      var overlay = searchState.getOverlay();\r\n      if (!overlay || query != overlay.query) {\r\n        if (overlay) {\r\n          cm.removeOverlay(overlay);\r\n        }\r\n        overlay = searchOverlay(query);\r\n        cm.addOverlay(overlay);\r\n        if (cm.showMatchesOnScrollbar) {\r\n          if (searchState.getScrollbarAnnotate()) {\r\n            searchState.getScrollbarAnnotate().clear();\r\n          }\r\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\r\n        }\r\n        searchState.setOverlay(overlay);\r\n      }\r\n    }\r\n    function findNext(cm, prev, query, repeat) {\r\n      if (repeat === undefined) { repeat = 1; }\r\n      return cm.operation(function() {\r\n        var pos = cm.getCursor();\r\n        var cursor = cm.getSearchCursor(query, pos);\r\n        for (var i = 0; i < repeat; i++) {\r\n          var found = cursor.find(prev);\r\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }\r\n          if (!found) {\r\n            // SearchCursor may have returned null because it hit EOF, wrap\r\n            // around and try again.\r\n            cursor = cm.getSearchCursor(query,\r\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );\r\n            if (!cursor.find(prev)) {\r\n              return;\r\n            }\r\n          }\r\n        }\r\n        return cursor.from();\r\n      });\r\n    }\r\n    function clearSearchHighlight(cm) {\r\n      var state = getSearchState(cm);\r\n      cm.removeOverlay(getSearchState(cm).getOverlay());\r\n      state.setOverlay(null);\r\n      if (state.getScrollbarAnnotate()) {\r\n        state.getScrollbarAnnotate().clear();\r\n        state.setScrollbarAnnotate(null);\r\n      }\r\n    }\r\n    /**\r\n     * Check if pos is in the specified range, INCLUSIVE.\r\n     * Range can be specified with 1 or 2 arguments.\r\n     * If the first range argument is an array, treat it as an array of line\r\n     * numbers. Match pos against any of the lines.\r\n     * If the first range argument is a number,\r\n     *   if there is only 1 range argument, check if pos has the same line\r\n     *       number\r\n     *   if there are 2 range arguments, then check if pos is in between the two\r\n     *       range arguments.\r\n     */\r\n    function isInRange(pos, start, end) {\r\n      if (typeof pos != 'number') {\r\n        // Assume it is a cursor position. Get the line number.\r\n        pos = pos.line;\r\n      }\r\n      if (start instanceof Array) {\r\n        return inArray(pos, start);\r\n      } else {\r\n        if (end) {\r\n          return (pos >= start && pos <= end);\r\n        } else {\r\n          return pos == start;\r\n        }\r\n      }\r\n    }\r\n    function getUserVisibleLines(cm) {\r\n      // ace_patch{\r\n      var renderer = cm.ace.renderer;\r\n      return {\r\n        top: renderer.getFirstFullyVisibleRow(),\r\n        bottom: renderer.getLastFullyVisibleRow()\r\n      }\r\n      // ace_patch}\r\n    }\r\n\r\n    function getMarkPos(cm, vim, markName) {\r\n      /* TODO reenable when selection history in ace is implemented\r\n      if (markName == '\\'') {\r\n        var history = cm.doc.history.done;\r\n        var event = history[history.length - 2];\r\n        return event && event.ranges && event.ranges[0].head;\r\n      } else if (markName == '.') {\r\n        if (cm.doc.history.lastModTime == 0) {\r\n          return  // If no changes, bail out; don't bother to copy or reverse history array.\r\n        } else {\r\n          var changeHistory = cm.doc.history.done.filter(function(el){ if (el.changes !== undefined) { return el } });\r\n          changeHistory.reverse();\r\n          var lastEditPos = changeHistory[0].changes[0].to;\r\n        }\r\n        return lastEditPos;\r\n      }\r\n      */\r\n\r\n      var mark = vim.marks[markName];\r\n      return mark && mark.find();\r\n    }\r\n\r\n    var ExCommandDispatcher = function() {\r\n      this.buildCommandMap_();\r\n    };\r\n    ExCommandDispatcher.prototype = {\r\n      processCommand: function(cm, input, opt_params) {\r\n        var that = this;\r\n        cm.operation(function () {\r\n          cm.curOp.isVimOp = true;\r\n          that._processCommand(cm, input, opt_params);\r\n        });\r\n      },\r\n      _processCommand: function(cm, input, opt_params) {\r\n        var vim = cm.state.vim;\r\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\r\n        var previousCommand = commandHistoryRegister.toString();\r\n        if (vim.visualMode) {\r\n          exitVisualMode(cm);\r\n        }\r\n        var inputStream = new CodeMirror.StringStream(input);\r\n        // update \": with the latest command whether valid or invalid\r\n        commandHistoryRegister.setText(input);\r\n        var params = opt_params || {};\r\n        params.input = input;\r\n        try {\r\n          this.parseInput_(cm, inputStream, params);\r\n        } catch(e) {\r\n          showConfirm(cm, e);\r\n          throw e;\r\n        }\r\n        var command;\r\n        var commandName;\r\n        if (!params.commandName) {\r\n          // If only a line range is defined, move to the line.\r\n          if (params.line !== undefined) {\r\n            commandName = 'move';\r\n          }\r\n        } else {\r\n          command = this.matchCommand_(params.commandName);\r\n          if (command) {\r\n            commandName = command.name;\r\n            if (command.excludeFromCommandHistory) {\r\n              commandHistoryRegister.setText(previousCommand);\r\n            }\r\n            this.parseCommandArgs_(inputStream, params, command);\r\n            if (command.type == 'exToKey') {\r\n              // Handle Ex to Key mapping.\r\n              for (var i = 0; i < command.toKeys.length; i++) {\r\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\r\n              }\r\n              return;\r\n            } else if (command.type == 'exToEx') {\r\n              // Handle Ex to Ex mapping.\r\n              this.processCommand(cm, command.toInput);\r\n              return;\r\n            }\r\n          }\r\n        }\r\n        if (!commandName) {\r\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\r\n          return;\r\n        }\r\n        try {\r\n          exCommands[commandName](cm, params);\r\n          // Possibly asynchronous commands (e.g. substitute, which might have a\r\n          // user confirmation), are responsible for calling the callback when\r\n          // done. All others have it taken care of for them here.\r\n          if ((!command || !command.possiblyAsync) && params.callback) {\r\n            params.callback();\r\n          }\r\n        } catch(e) {\r\n          showConfirm(cm, e);\r\n          throw e;\r\n        }\r\n      },\r\n      parseInput_: function(cm, inputStream, result) {\r\n        inputStream.eatWhile(':');\r\n        // Parse range.\r\n        if (inputStream.eat('%')) {\r\n          result.line = cm.firstLine();\r\n          result.lineEnd = cm.lastLine();\r\n        } else {\r\n          result.line = this.parseLineSpec_(cm, inputStream);\r\n          if (result.line !== undefined && inputStream.eat(',')) {\r\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\r\n          }\r\n        }\r\n\r\n        // Parse command name.\r\n        var commandMatch = inputStream.match(/^(\\w+)/);\r\n        if (commandMatch) {\r\n          result.commandName = commandMatch[1];\r\n        } else {\r\n          result.commandName = inputStream.match(/.*/)[0];\r\n        }\r\n\r\n        return result;\r\n      },\r\n      parseLineSpec_: function(cm, inputStream) {\r\n        var numberMatch = inputStream.match(/^(\\d+)/);\r\n        if (numberMatch) {\r\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\r\n          // not something the user actually wanted. (NB: vim does allow this.)\r\n          return parseInt(numberMatch[1], 10) - 1;\r\n        }\r\n        switch (inputStream.next()) {\r\n          case '.':\r\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\r\n          case '$':\r\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\r\n          case '\\'':\r\n            var markName = inputStream.next();\r\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\r\n            if (!markPos) throw new Error('Mark not set');\r\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\r\n          case '-':\r\n          case '+':\r\n            inputStream.backUp(1);\r\n            // Offset is relative to current line if not otherwise specified.\r\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\r\n          default:\r\n            inputStream.backUp(1);\r\n            return undefined;\r\n        }\r\n      },\r\n      parseLineSpecOffset_: function(inputStream, line) {\r\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\r\n        if (offsetMatch) {\r\n          var offset = parseInt(offsetMatch[2], 10);\r\n          if (offsetMatch[1] == \"-\") {\r\n            line -= offset;\r\n          } else {\r\n            line += offset;\r\n          }\r\n        }\r\n        return line;\r\n      },\r\n      parseCommandArgs_: function(inputStream, params, command) {\r\n        if (inputStream.eol()) {\r\n          return;\r\n        }\r\n        params.argString = inputStream.match(/.*/)[0];\r\n        // Parse command-line arguments\r\n        var delim = command.argDelimiter || /\\s+/;\r\n        var args = trim(params.argString).split(delim);\r\n        if (args.length && args[0]) {\r\n          params.args = args;\r\n        }\r\n      },\r\n      matchCommand_: function(commandName) {\r\n        // Return the command in the command map that matches the shortest\r\n        // prefix of the passed in command name. The match is guaranteed to be\r\n        // unambiguous if the defaultExCommandMap's shortNames are set up\r\n        // correctly. (see @code{defaultExCommandMap}).\r\n        for (var i = commandName.length; i > 0; i--) {\r\n          var prefix = commandName.substring(0, i);\r\n          if (this.commandMap_[prefix]) {\r\n            var command = this.commandMap_[prefix];\r\n            if (command.name.indexOf(commandName) === 0) {\r\n              return command;\r\n            }\r\n          }\r\n        }\r\n        return null;\r\n      },\r\n      buildCommandMap_: function() {\r\n        this.commandMap_ = {};\r\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\r\n          var command = defaultExCommandMap[i];\r\n          var key = command.shortName || command.name;\r\n          this.commandMap_[key] = command;\r\n        }\r\n      },\r\n      map: function(lhs, rhs, ctx) {\r\n        if (lhs != ':' && lhs.charAt(0) == ':') {\r\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\r\n          var commandName = lhs.substring(1);\r\n          if (rhs != ':' && rhs.charAt(0) == ':') {\r\n            // Ex to Ex mapping\r\n            this.commandMap_[commandName] = {\r\n              name: commandName,\r\n              type: 'exToEx',\r\n              toInput: rhs.substring(1),\r\n              user: true\r\n            };\r\n          } else {\r\n            // Ex to key mapping\r\n            this.commandMap_[commandName] = {\r\n              name: commandName,\r\n              type: 'exToKey',\r\n              toKeys: rhs,\r\n              user: true\r\n            };\r\n          }\r\n        } else {\r\n          if (rhs != ':' && rhs.charAt(0) == ':') {\r\n            // Key to Ex mapping.\r\n            var mapping = {\r\n              keys: lhs,\r\n              type: 'keyToEx',\r\n              exArgs: { input: rhs.substring(1) }\r\n            };\r\n            if (ctx) { mapping.context = ctx; }\r\n            defaultKeymap.unshift(mapping);\r\n          } else {\r\n            // Key to key mapping\r\n            var mapping = {\r\n              keys: lhs,\r\n              type: 'keyToKey',\r\n              toKeys: rhs\r\n            };\r\n            if (ctx) { mapping.context = ctx; }\r\n            defaultKeymap.unshift(mapping);\r\n          }\r\n        }\r\n      },\r\n      unmap: function(lhs, ctx) {\r\n        if (lhs != ':' && lhs.charAt(0) == ':') {\r\n          // Ex to Ex or Ex to key mapping\r\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\r\n          var commandName = lhs.substring(1);\r\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\r\n            delete this.commandMap_[commandName];\r\n            return;\r\n          }\r\n        } else {\r\n          // Key to Ex or key to key mapping\r\n          var keys = lhs;\r\n          for (var i = 0; i < defaultKeymap.length; i++) {\r\n            if (keys == defaultKeymap[i].keys\r\n                && defaultKeymap[i].context === ctx) {\r\n              defaultKeymap.splice(i, 1);\r\n              return;\r\n            }\r\n          }\r\n        }\r\n        // ace_patch\r\n      }\r\n    };\r\n\r\n    var exCommands = {\r\n      colorscheme: function(cm, params) {\r\n        if (!params.args || params.args.length < 1) {\r\n          showConfirm(cm, cm.getOption('theme'));\r\n          return;\r\n        }\r\n        cm.setOption('theme', params.args[0]);\r\n      },\r\n      map: function(cm, params, ctx) {\r\n        var mapArgs = params.args;\r\n        if (!mapArgs || mapArgs.length < 2) {\r\n          if (cm) {\r\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\r\n          }\r\n          return;\r\n        }\r\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\r\n      },\r\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\r\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\r\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\r\n      unmap: function(cm, params, ctx) {\r\n        var mapArgs = params.args;\r\n        if (!mapArgs || mapArgs.length < 1) {\r\n          if (cm) {\r\n            showConfirm(cm, 'No such mapping: ' + params.input);\r\n          }\r\n          return;\r\n        }\r\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\r\n      },\r\n      move: function(cm, params) {\r\n        commandDispatcher.processCommand(cm, cm.state.vim, {\r\n            type: 'motion',\r\n            motion: 'moveToLineOrEdgeOfDocument',\r\n            motionArgs: { forward: false, explicitRepeat: true,\r\n              linewise: true },\r\n            repeatOverride: params.line+1});\r\n      },\r\n      set: function(cm, params) {\r\n        var setArgs = params.args;\r\n        // Options passed through to the setOption/getOption calls. May be passed in by the\r\n        // local/global versions of the set command\r\n        var setCfg = params.setCfg || {};\r\n        if (!setArgs || setArgs.length < 1) {\r\n          if (cm) {\r\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\r\n          }\r\n          return;\r\n        }\r\n        var expr = setArgs[0].split('=');\r\n        var optionName = expr[0];\r\n        var value = expr[1];\r\n        var forceGet = false;\r\n\r\n        if (optionName.charAt(optionName.length - 1) == '?') {\r\n          // If post-fixed with ?, then the set is actually a get.\r\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\r\n          optionName = optionName.substring(0, optionName.length - 1);\r\n          forceGet = true;\r\n        }\r\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\r\n          // To set boolean options to false, the option name is prefixed with\r\n          // 'no'.\r\n          optionName = optionName.substring(2);\r\n          value = false;\r\n        }\r\n\r\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\r\n        if (optionIsBoolean && value == undefined) {\r\n          // Calling set with a boolean option sets it to true.\r\n          value = true;\r\n        }\r\n        // If no value is provided, then we assume this is a get.\r\n        if (!optionIsBoolean && value === undefined || forceGet) {\r\n          var oldValue = getOption(optionName, cm, setCfg);\r\n          if (oldValue instanceof Error) {\r\n            showConfirm(cm, oldValue.message);\r\n          } else if (oldValue === true || oldValue === false) {\r\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\r\n          } else {\r\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\r\n          }\r\n        } else {\r\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\r\n          if (setOptionReturn instanceof Error) {\r\n            showConfirm(cm, setOptionReturn.message);\r\n          }\r\n        }\r\n      },\r\n      setlocal: function (cm, params) {\r\n        // setCfg is passed through to setOption\r\n        params.setCfg = {scope: 'local'};\r\n        this.set(cm, params);\r\n      },\r\n      setglobal: function (cm, params) {\r\n        // setCfg is passed through to setOption\r\n        params.setCfg = {scope: 'global'};\r\n        this.set(cm, params);\r\n      },\r\n      registers: function(cm, params) {\r\n        var regArgs = params.args;\r\n        var registers = vimGlobalState.registerController.registers;\r\n        var regInfo = '----------Registers----------<br><br>';\r\n        if (!regArgs) {\r\n          for (var registerName in registers) {\r\n            var text = registers[registerName].toString();\r\n            if (text.length) {\r\n              regInfo += '\"' + registerName + '    ' + text + '<br>';\r\n            }\r\n          }\r\n        } else {\r\n          var registerName;\r\n          regArgs = regArgs.join('');\r\n          for (var i = 0; i < regArgs.length; i++) {\r\n            registerName = regArgs.charAt(i);\r\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\r\n              continue;\r\n            }\r\n            var register = registers[registerName] || new Register();\r\n            regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\r\n          }\r\n        }\r\n        showConfirm(cm, regInfo);\r\n      },\r\n      sort: function(cm, params) {\r\n        var reverse, ignoreCase, unique, number, pattern;\r\n        function parseArgs() {\r\n          if (params.argString) {\r\n            var args = new CodeMirror.StringStream(params.argString);\r\n            if (args.eat('!')) { reverse = true; }\r\n            if (args.eol()) { return; }\r\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\r\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\r\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\r\n            if (opts[1]) {\r\n              ignoreCase = opts[1].indexOf('i') != -1;\r\n              unique = opts[1].indexOf('u') != -1;\r\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\r\n              var hex = opts[1].indexOf('x') != -1 && 1;\r\n              var octal = opts[1].indexOf('o') != -1 && 1;\r\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\r\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\r\n            }\r\n            if (opts[2]) {\r\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\r\n            }\r\n          }\r\n        }\r\n        var err = parseArgs();\r\n        if (err) {\r\n          showConfirm(cm, err + ': ' + params.argString);\r\n          return;\r\n        }\r\n        var lineStart = params.line || cm.firstLine();\r\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\r\n        if (lineStart == lineEnd) { return; }\r\n        var curStart = Pos(lineStart, 0);\r\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\r\n        var text = cm.getRange(curStart, curEnd).split('\\n');\r\n        var numberRegex = pattern ? pattern :\r\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\r\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\r\n           (number == 'octal') ? /([0-7]+)/ : null;\r\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\r\n        var numPart = [], textPart = [];\r\n        if (number || pattern) {\r\n          for (var i = 0; i < text.length; i++) {\r\n            var matchPart = pattern ? text[i].match(pattern) : null;\r\n            if (matchPart && matchPart[0] != '') {\r\n              numPart.push(matchPart);\r\n            } else if (!pattern && numberRegex.exec(text[i])) {\r\n              numPart.push(text[i]);\r\n            } else {\r\n              textPart.push(text[i]);\r\n            }\r\n          }\r\n        } else {\r\n          textPart = text;\r\n        }\r\n        function compareFn(a, b) {\r\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\r\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\r\n          var anum = number && numberRegex.exec(a);\r\n          var bnum = number && numberRegex.exec(b);\r\n          if (!anum) { return a < b ? -1 : 1; }\r\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\r\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\r\n          return anum - bnum;\r\n        }\r\n        function comparePatternFn(a, b) {\r\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\r\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\r\n          return (a[0] < b[0]) ? -1 : 1;\r\n        }\r\n        numPart.sort(pattern ? comparePatternFn : compareFn);\r\n        if (pattern) {\r\n          for (var i = 0; i < numPart.length; i++) {\r\n            numPart[i] = numPart[i].input;\r\n          }\r\n        } else if (!number) { textPart.sort(compareFn); }\r\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\r\n        if (unique) { // Remove duplicate lines\r\n          var textOld = text;\r\n          var lastLine;\r\n          text = [];\r\n          for (var i = 0; i < textOld.length; i++) {\r\n            if (textOld[i] != lastLine) {\r\n              text.push(textOld[i]);\r\n            }\r\n            lastLine = textOld[i];\r\n          }\r\n        }\r\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\r\n      },\r\n      global: function(cm, params) {\r\n        // a global command is of the form\r\n        // :[range]g/pattern/[cmd]\r\n        // argString holds the string /pattern/[cmd]\r\n        var argString = params.argString;\r\n        if (!argString) {\r\n          showConfirm(cm, 'Regular Expression missing from global');\r\n          return;\r\n        }\r\n        // range is specified here\r\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\r\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\r\n        // get the tokens from argString\r\n        var tokens = splitBySlash(argString);\r\n        var regexPart = argString, cmd;\r\n        if (tokens.length) {\r\n          regexPart = tokens[0];\r\n          cmd = tokens.slice(1, tokens.length).join('/');\r\n        }\r\n        if (regexPart) {\r\n          // If regex part is empty, then use the previous query. Otherwise\r\n          // use the regex part as the new query.\r\n          try {\r\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\r\n             true /** smartCase */);\r\n          } catch (e) {\r\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\r\n           return;\r\n          }\r\n        }\r\n        // now that we have the regexPart, search for regex matches in the\r\n        // specified range of lines\r\n        var query = getSearchState(cm).getQuery();\r\n        var matchedLines = [], content = '';\r\n        for (var i = lineStart; i <= lineEnd; i++) {\r\n          var matched = query.test(cm.getLine(i));\r\n          if (matched) {\r\n            matchedLines.push(i+1);\r\n            content+= cm.getLine(i) + '<br>';\r\n          }\r\n        }\r\n        // if there is no [cmd], just display the list of matched lines\r\n        if (!cmd) {\r\n          showConfirm(cm, content);\r\n          return;\r\n        }\r\n        var index = 0;\r\n        var nextCommand = function() {\r\n          if (index < matchedLines.length) {\r\n            var command = matchedLines[index] + cmd;\r\n            exCommandDispatcher.processCommand(cm, command, {\r\n              callback: nextCommand\r\n            });\r\n          }\r\n          index++;\r\n        };\r\n        nextCommand();\r\n      },\r\n      substitute: function(cm, params) {\r\n        if (!cm.getSearchCursor) {\r\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\r\n              'any other getSearchCursor implementation.');\r\n        }\r\n        var argString = params.argString;\r\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\r\n        var regexPart, replacePart = '', trailing, flagsPart, count;\r\n        var confirm = false; // Whether to confirm each replace.\r\n        var global = false; // True to replace all instances on a line, false to replace only 1.\r\n        if (tokens.length) {\r\n          regexPart = tokens[0];\r\n          replacePart = tokens[1];\r\n          if (regexPart && regexPart[regexPart.length - 1] === '$') {\r\n            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\n';\r\n            replacePart = replacePart ? replacePart + '\\n' : '\\n';\r\n          }\r\n          if (replacePart !== undefined) {\r\n            if (getOption('pcre')) {\r\n              replacePart = unescapeRegexReplace(replacePart);\r\n            } else {\r\n              replacePart = translateRegexReplace(replacePart);\r\n            }\r\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\r\n          }\r\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\r\n        } else {\r\n          // either the argString is empty or its of the form ' hello/world'\r\n          // actually splitBySlash returns a list of tokens\r\n          // only if the string starts with a '/'\r\n          if (argString && argString.length) {\r\n            showConfirm(cm, 'Substitutions should be of the form ' +\r\n                ':s/pattern/replace/');\r\n            return;\r\n          }\r\n        }\r\n        // After the 3rd slash, we can have flags followed by a space followed\r\n        // by count.\r\n        if (trailing) {\r\n          flagsPart = trailing[0];\r\n          count = parseInt(trailing[1]);\r\n          if (flagsPart) {\r\n            if (flagsPart.indexOf('c') != -1) {\r\n              confirm = true;\r\n              flagsPart.replace('c', '');\r\n            }\r\n            if (flagsPart.indexOf('g') != -1) {\r\n              global = true;\r\n              flagsPart.replace('g', '');\r\n            }\r\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\r\n          }\r\n        }\r\n        if (regexPart) {\r\n          // If regex part is empty, then use the previous query. Otherwise use\r\n          // the regex part as the new query.\r\n          try {\r\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\r\n              true /** smartCase */);\r\n          } catch (e) {\r\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\r\n            return;\r\n          }\r\n        }\r\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\r\n        if (replacePart === undefined) {\r\n          showConfirm(cm, 'No previous substitute regular expression');\r\n          return;\r\n        }\r\n        var state = getSearchState(cm);\r\n        var query = state.getQuery();\r\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\r\n        var lineEnd = params.lineEnd || lineStart;\r\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\r\n          lineEnd = Infinity;\r\n        }\r\n        if (count) {\r\n          lineStart = lineEnd;\r\n          lineEnd = lineStart + count - 1;\r\n        }\r\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\r\n        var cursor = cm.getSearchCursor(query, startPos);\r\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\r\n      },\r\n      redo: CodeMirror.commands.redo,\r\n      undo: CodeMirror.commands.undo,\r\n      write: function(cm) {\r\n        if (CodeMirror.commands.save) {\r\n          // If a save command is defined, call it.\r\n          CodeMirror.commands.save(cm);\r\n        } else if (cm.save) {\r\n          // Saves to text area if no save command is defined and cm.save() is available.\r\n          cm.save();\r\n        }\r\n      },\r\n      nohlsearch: function(cm) {\r\n        clearSearchHighlight(cm);\r\n      },\r\n      yank: function (cm) {\r\n        var cur = copyCursor(cm.getCursor());\r\n        var line = cur.line;\r\n        var lineText = cm.getLine(line);\r\n        vimGlobalState.registerController.pushText(\r\n          '0', 'yank', lineText, true, true);\r\n      },\r\n      delmarks: function(cm, params) {\r\n        if (!params.argString || !trim(params.argString)) {\r\n          showConfirm(cm, 'Argument required');\r\n          return;\r\n        }\r\n\r\n        var state = cm.state.vim;\r\n        var stream = new CodeMirror.StringStream(trim(params.argString));\r\n        while (!stream.eol()) {\r\n          stream.eatSpace();\r\n\r\n          // Record the streams position at the beginning of the loop for use\r\n          // in error messages.\r\n          var count = stream.pos;\r\n\r\n          if (!stream.match(/[a-zA-Z]/, false)) {\r\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\r\n            return;\r\n          }\r\n\r\n          var sym = stream.next();\r\n          // Check if this symbol is part of a range\r\n          if (stream.match('-', true)) {\r\n            // This symbol is part of a range.\r\n\r\n            // The range must terminate at an alphabetic character.\r\n            if (!stream.match(/[a-zA-Z]/, false)) {\r\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\r\n              return;\r\n            }\r\n\r\n            var startMark = sym;\r\n            var finishMark = stream.next();\r\n            // The range must terminate at an alphabetic character which\r\n            // shares the same case as the start of the range.\r\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\r\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\r\n              var start = startMark.charCodeAt(0);\r\n              var finish = finishMark.charCodeAt(0);\r\n              if (start >= finish) {\r\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\r\n                return;\r\n              }\r\n\r\n              // Because marks are always ASCII values, and we have\r\n              // determined that they are the same case, we can use\r\n              // their char codes to iterate through the defined range.\r\n              for (var j = 0; j <= finish - start; j++) {\r\n                var mark = String.fromCharCode(start + j);\r\n                delete state.marks[mark];\r\n              }\r\n            } else {\r\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\r\n              return;\r\n            }\r\n          } else {\r\n            // This symbol is a valid mark, and is not part of a range.\r\n            delete state.marks[sym];\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    var exCommandDispatcher = new ExCommandDispatcher();\r\n\r\n    /**\r\n    * @param {CodeMirror} cm CodeMirror instance we are in.\r\n    * @param {boolean} confirm Whether to confirm each replace.\r\n    * @param {Cursor} lineStart Line to start replacing from.\r\n    * @param {Cursor} lineEnd Line to stop replacing at.\r\n    * @param {RegExp} query Query for performing matches with.\r\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\r\n    *     $2, etc for replacing captured groups using Javascript replace.\r\n    * @param {function()} callback A callback for when the replace is done.\r\n    */\r\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\r\n        replaceWith, callback) {\r\n      // Set up all the functions.\r\n      cm.state.vim.exMode = true;\r\n      var done = false;\r\n      var lastPos = searchCursor.from();\r\n      function replaceAll() {\r\n        cm.operation(function() {\r\n          while (!done) {\r\n            replace();\r\n            next();\r\n          }\r\n          stop();\r\n        });\r\n      }\r\n      function replace() {\r\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\r\n        var newText = text.replace(query, replaceWith);\r\n        searchCursor.replace(newText);\r\n      }\r\n      function next() {\r\n        // The below only loops to skip over multiple occurrences on the same\r\n        // line when 'global' is not true.\r\n        while(searchCursor.findNext() &&\r\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\r\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\r\n            continue;\r\n          }\r\n          cm.scrollIntoView(searchCursor.from(), 30);\r\n          cm.setSelection(searchCursor.from(), searchCursor.to());\r\n          lastPos = searchCursor.from();\r\n          done = false;\r\n          return;\r\n        }\r\n        done = true;\r\n      }\r\n      function stop(close) {\r\n        if (close) { close(); }\r\n        cm.focus();\r\n        if (lastPos) {\r\n          cm.setCursor(lastPos);\r\n          var vim = cm.state.vim;\r\n          vim.exMode = false;\r\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\r\n        }\r\n        if (callback) { callback(); }\r\n      }\r\n      function onPromptKeyDown(e, _value, close) {\r\n        // Swallow all keys.\r\n        CodeMirror.e_stop(e);\r\n        var keyName = CodeMirror.keyName(e);\r\n        switch (keyName) {\r\n          case 'Y':\r\n            replace(); next(); break;\r\n          case 'N':\r\n            next(); break;\r\n          case 'A':\r\n            // replaceAll contains a call to close of its own. We don't want it\r\n            // to fire too early or multiple times.\r\n            var savedCallback = callback;\r\n            callback = undefined;\r\n            cm.operation(replaceAll);\r\n            callback = savedCallback;\r\n            break;\r\n          case 'L':\r\n            replace();\r\n            // fall through and exit.\r\n          case 'Q':\r\n          case 'Esc':\r\n          case 'Ctrl-C':\r\n          case 'Ctrl-[':\r\n            stop(close);\r\n            break;\r\n        }\r\n        if (done) { stop(close); }\r\n        return true;\r\n      }\r\n\r\n      // Actually do replace.\r\n      next();\r\n      if (done) {\r\n        showConfirm(cm, 'No matches for ' + query.source);\r\n        return;\r\n      }\r\n      if (!confirm) {\r\n        replaceAll();\r\n        if (callback) { callback(); }\r\n        return;\r\n      }\r\n      showPrompt(cm, {\r\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\r\n        onKeyDown: onPromptKeyDown\r\n      });\r\n    }\r\n\r\n    CodeMirror.keyMap.vim = {\r\n      attach: attachVimMap,\r\n      detach: detachVimMap,\r\n      call: cmKey\r\n    };\r\n\r\n    function exitInsertMode(cm) {\r\n      var vim = cm.state.vim;\r\n      var macroModeState = vimGlobalState.macroModeState;\r\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\r\n      var isPlaying = macroModeState.isPlaying;\r\n      var lastChange = macroModeState.lastInsertModeChanges;\r\n      if (!isPlaying) {\r\n        cm.off('change', onChange);\r\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\r\n      }\r\n      if (!isPlaying && vim.insertModeRepeat > 1) {\r\n        // Perform insert mode repeat for commands like 3,a and 3,o.\r\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\r\n            true /** repeatForInsert */);\r\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\r\n      }\r\n      delete vim.insertModeRepeat;\r\n      vim.insertMode = false;\r\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\r\n      cm.setOption('keyMap', 'vim');\r\n      cm.setOption('disableInput', true);\r\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\r\n      // update the \". register before exiting insert mode\r\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\r\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\r\n      if (macroModeState.isRecording) {\r\n        logInsertModeChange(macroModeState);\r\n      }\r\n    }\r\n\r\n    function _mapCommand(command) {\r\n      defaultKeymap.unshift(command);\r\n    }\r\n\r\n    function mapCommand(keys, type, name, args, extra) {\r\n      var command = {keys: keys, type: type};\r\n      command[type] = name;\r\n      command[type + \"Args\"] = args;\r\n      for (var key in extra)\r\n        command[key] = extra[key];\r\n      _mapCommand(command);\r\n    }\r\n\r\n    // The timeout in milliseconds for the two-character ESC keymap should be\r\n    // adjusted according to your typing speed to prevent false positives.\r\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\r\n\r\n    CodeMirror.keyMap['vim-insert'] = {\r\n      // TODO: override navigation keys so that Esc will cancel automatic\r\n      // indentation from o, O, i_<CR>\r\n      'Ctrl-N': 'autocomplete',\r\n      'Ctrl-P': 'autocomplete',\r\n      'Enter': function(cm) {\r\n        var fn = CodeMirror.commands.newlineAndIndentContinueComment ||\r\n            CodeMirror.commands.newlineAndIndent;\r\n        fn(cm);\r\n      },\r\n      fallthrough: ['default'],\r\n      attach: attachVimMap,\r\n      detach: detachVimMap,\r\n      call: cmKey\r\n    };\r\n\r\n    CodeMirror.keyMap['vim-replace'] = {\r\n      'Backspace': 'goCharLeft',\r\n      fallthrough: ['vim-insert'],\r\n      attach: attachVimMap,\r\n      detach: detachVimMap,\r\n      call: cmKey\r\n    };\r\n\r\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\r\n      var register = vimGlobalState.registerController.getRegister(registerName);\r\n      if (registerName == ':') {\r\n        // Read-only register containing last Ex command.\r\n        if (register.keyBuffer[0]) {\r\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\r\n        }\r\n        macroModeState.isPlaying = false;\r\n        return;\r\n      }\r\n      var keyBuffer = register.keyBuffer;\r\n      var imc = 0;\r\n      macroModeState.isPlaying = true;\r\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\r\n      for (var i = 0; i < keyBuffer.length; i++) {\r\n        var text = keyBuffer[i];\r\n        var match, key;\r\n        while (text) {\r\n          // Pull off one command key, which is either a single character\r\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\r\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\r\n          key = match[0];\r\n          text = text.substring(match.index + key.length);\r\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\r\n          if (vim.insertMode) {\r\n            var changes = register.insertModeChanges[imc++].changes;\r\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\r\n                changes;\r\n            repeatInsertModeChanges(cm, changes, 1);\r\n            exitInsertMode(cm);\r\n          }\r\n        }\r\n      }\r\n      macroModeState.isPlaying = false;\r\n    }\r\n\r\n    function logKey(macroModeState, key) {\r\n      if (macroModeState.isPlaying) { return; }\r\n      var registerName = macroModeState.latestRegister;\r\n      var register = vimGlobalState.registerController.getRegister(registerName);\r\n      if (register) {\r\n        register.pushText(key);\r\n      }\r\n    }\r\n\r\n    function logInsertModeChange(macroModeState) {\r\n      if (macroModeState.isPlaying) { return; }\r\n      var registerName = macroModeState.latestRegister;\r\n      var register = vimGlobalState.registerController.getRegister(registerName);\r\n      if (register && register.pushInsertModeChanges) {\r\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\r\n      }\r\n    }\r\n\r\n    function logSearchQuery(macroModeState, query) {\r\n      if (macroModeState.isPlaying) { return; }\r\n      var registerName = macroModeState.latestRegister;\r\n      var register = vimGlobalState.registerController.getRegister(registerName);\r\n      if (register && register.pushSearchQuery) {\r\n        register.pushSearchQuery(query);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Listens for changes made in insert mode.\r\n     * Should only be active in insert mode.\r\n     */\r\n    function onChange(cm, changeObj) {\r\n      var macroModeState = vimGlobalState.macroModeState;\r\n      var lastChange = macroModeState.lastInsertModeChanges;\r\n      if (!macroModeState.isPlaying) {\r\n        while(changeObj) {\r\n          lastChange.expectCursorActivityForChange = true;\r\n          if (lastChange.ignoreCount > 1) {\r\n            lastChange.ignoreCount--;\r\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\r\n              || changeObj.origin === undefined /* only in testing */) {\r\n            var selectionCount = cm.listSelections().length;\r\n            if (selectionCount > 1)\r\n              lastChange.ignoreCount = selectionCount;\r\n            var text = changeObj.text.join('\\n');\r\n            if (lastChange.maybeReset) {\r\n              lastChange.changes = [];\r\n              lastChange.maybeReset = false;\r\n            }\r\n            if (cm.state.overwrite && !/\\n/.test(text)) {\r\n                lastChange.changes.push([text]);\r\n            } else {\r\n                lastChange.changes.push(text);\r\n            }\r\n          }\r\n          // Change objects may be chained with next.\r\n          changeObj = changeObj.next;\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n    * Listens for any kind of cursor activity on CodeMirror.\r\n    */\r\n    function onCursorActivity(cm) {\r\n      var vim = cm.state.vim;\r\n      if (vim.insertMode) {\r\n        // Tracking cursor activity in insert mode (for macro support).\r\n        var macroModeState = vimGlobalState.macroModeState;\r\n        if (macroModeState.isPlaying) { return; }\r\n        var lastChange = macroModeState.lastInsertModeChanges;\r\n        if (lastChange.expectCursorActivityForChange) {\r\n          lastChange.expectCursorActivityForChange = false;\r\n        } else {\r\n          // Cursor moved outside the context of an edit. Reset the change.\r\n          lastChange.maybeReset = true;\r\n        }\r\n      } else if (!cm.curOp.isVimOp) {\r\n        handleExternalSelection(cm, vim);\r\n      }\r\n      if (vim.visualMode) {\r\n        updateFakeCursor(cm);\r\n      }\r\n    }\r\n    function updateFakeCursor(cm) {\r\n      var vim = cm.state.vim;\r\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\r\n      var to = offsetCursor(from, 0, 1);\r\n      if (vim.fakeCursor) {\r\n        vim.fakeCursor.clear();\r\n      }\r\n      vim.fakeCursor = cm.markText(from, to, {className: 'cm-animate-fat-cursor'});\r\n    }\r\n    function handleExternalSelection(cm, vim) {\r\n      var anchor = cm.getCursor('anchor');\r\n      var head = cm.getCursor('head');\r\n      // Enter or exit visual mode to match mouse selection.\r\n      if (vim.visualMode && !cm.somethingSelected()) {\r\n        exitVisualMode(cm, false);\r\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\r\n        vim.visualMode = true;\r\n        vim.visualLine = false;\r\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\r\n      }\r\n      if (vim.visualMode) {\r\n        // Bind CodeMirror selection model to vim selection model.\r\n        // Mouse selections are considered visual characterwise.\r\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\r\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\r\n        head = offsetCursor(head, 0, headOffset);\r\n        anchor = offsetCursor(anchor, 0, anchorOffset);\r\n        vim.sel = {\r\n          anchor: anchor,\r\n          head: head\r\n        };\r\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\r\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\r\n      } else if (!vim.insertMode) {\r\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\r\n        vim.lastHPos = cm.getCursor().ch;\r\n      }\r\n    }\r\n\r\n    /** Wrapper for special keys pressed in insert mode */\r\n    function InsertModeKey(keyName) {\r\n      this.keyName = keyName;\r\n    }\r\n\r\n    /**\r\n    * Handles raw key down events from the text area.\r\n    * - Should only be active in insert mode.\r\n    * - For recording deletes in insert mode.\r\n    */\r\n    function onKeyEventTargetKeyDown(e) {\r\n      var macroModeState = vimGlobalState.macroModeState;\r\n      var lastChange = macroModeState.lastInsertModeChanges;\r\n      var keyName = CodeMirror.keyName(e);\r\n      if (!keyName) { return; }\r\n      function onKeyFound() {\r\n        if (lastChange.maybeReset) {\r\n          lastChange.changes = [];\r\n          lastChange.maybeReset = false;\r\n        }\r\n        lastChange.changes.push(new InsertModeKey(keyName));\r\n        return true;\r\n      }\r\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\r\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Repeats the last edit, which includes exactly 1 command and at most 1\r\n     * insert. Operator and motion commands are read from lastEditInputState,\r\n     * while action commands are read from lastEditActionCommand.\r\n     *\r\n     * If repeatForInsert is true, then the function was called by\r\n     * exitInsertMode to repeat the insert mode changes the user just made. The\r\n     * corresponding enterInsertMode call was made with a count.\r\n     */\r\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\r\n      var macroModeState = vimGlobalState.macroModeState;\r\n      macroModeState.isPlaying = true;\r\n      var isAction = !!vim.lastEditActionCommand;\r\n      var cachedInputState = vim.inputState;\r\n      function repeatCommand() {\r\n        if (isAction) {\r\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\r\n        } else {\r\n          commandDispatcher.evalInput(cm, vim);\r\n        }\r\n      }\r\n      function repeatInsert(repeat) {\r\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\r\n          // For some reason, repeat cw in desktop VIM does not repeat\r\n          // insert mode changes. Will conform to that behavior.\r\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\r\n          var changeObject = macroModeState.lastInsertModeChanges;\r\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\r\n        }\r\n      }\r\n      vim.inputState = vim.lastEditInputState;\r\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\r\n        // o and O repeat have to be interlaced with insert repeats so that the\r\n        // insertions appear on separate lines instead of the last line.\r\n        for (var i = 0; i < repeat; i++) {\r\n          repeatCommand();\r\n          repeatInsert(1);\r\n        }\r\n      } else {\r\n        if (!repeatForInsert) {\r\n          // Hack to get the cursor to end up at the right place. If I is\r\n          // repeated in insert mode repeat, cursor will be 1 insert\r\n          // change set left of where it should be.\r\n          repeatCommand();\r\n        }\r\n        repeatInsert(repeat);\r\n      }\r\n      vim.inputState = cachedInputState;\r\n      if (vim.insertMode && !repeatForInsert) {\r\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\r\n        // were called by an exitInsertMode call lower on the stack.\r\n        exitInsertMode(cm);\r\n      }\r\n      macroModeState.isPlaying = false;\r\n    }\r\n\r\n    function repeatInsertModeChanges(cm, changes, repeat) {\r\n      function keyHandler(binding) {\r\n        if (typeof binding == 'string') {\r\n          CodeMirror.commands[binding](cm);\r\n        } else {\r\n          binding(cm);\r\n        }\r\n        return true;\r\n      }\r\n      var head = cm.getCursor('head');\r\n      var inVisualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock;\r\n      if (inVisualBlock) {\r\n        // Set up block selection again for repeating the changes.\r\n        var vim = cm.state.vim;\r\n        var lastSel = vim.lastSelection;\r\n        var offset = getOffset(lastSel.anchor, lastSel.head);\r\n        selectForInsert(cm, head, offset.line + 1);\r\n        repeat = cm.listSelections().length;\r\n        cm.setCursor(head);\r\n      }\r\n      for (var i = 0; i < repeat; i++) {\r\n        if (inVisualBlock) {\r\n          cm.setCursor(offsetCursor(head, i, 0));\r\n        }\r\n        for (var j = 0; j < changes.length; j++) {\r\n          var change = changes[j];\r\n          if (change instanceof InsertModeKey) {\r\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\r\n          } else if (typeof change == \"string\") {\r\n            var cur = cm.getCursor();\r\n            cm.replaceRange(change, cur, cur);\r\n          } else {\r\n            var start = cm.getCursor();\r\n            var end = offsetCursor(start, 0, change[0].length);\r\n            cm.replaceRange(change[0], start, end);\r\n          }\r\n        }\r\n      }\r\n      if (inVisualBlock) {\r\n        cm.setCursor(offsetCursor(head, 0, 1));\r\n      }\r\n    }\r\n\r\n    resetVimGlobalState();\r\n  //};\r\n  // Initialize Vim and make it available as an API.\r\n  CodeMirror.Vim = Vim();\r\n\r\n  Vim = CodeMirror.Vim;\r\n\r\n  var specialKey = {'return':'CR',backspace:'BS','delete':'Del',esc:'Esc',\r\n    left:'Left',right:'Right',up:'Up',down:'Down',space: 'Space',\r\n    home:'Home',end:'End',pageup:'PageUp',pagedown:'PageDown', enter: 'CR'\r\n  };\r\n  function lookupKey(hashId, key, e) {\r\n    if (key.length > 1 && key[0] == \"n\") {\r\n      key = key.replace(\"numpad\", \"\");\r\n    }\r\n    key = specialKey[key] || key;\r\n    var name = '';\r\n    if (e.ctrlKey) { name += 'C-'; }\r\n    if (e.altKey) { name += 'A-'; }\r\n    if ((name || key.length > 1) && e.shiftKey) { name += 'S-'; }\r\n\r\n    name += key;\r\n    if (name.length > 1) { name = '<' + name + '>'; }\r\n    return name;\r\n  }\r\n  var handleKey = Vim.handleKey.bind(Vim);\r\n  Vim.handleKey = function(cm, key, origin) {\r\n    return cm.operation(function() {\r\n      return handleKey(cm, key, origin);\r\n    }, true);\r\n  }\r\n  function cloneVimState(state) {\r\n    var n = new state.constructor();\r\n    Object.keys(state).forEach(function(key) {\r\n      var o = state[key];\r\n      if (Array.isArray(o))\r\n        o = o.slice();\r\n      else if (o && typeof o == \"object\" && o.constructor != Object)\r\n        o = cloneVimState(o);\r\n      n[key] = o;\r\n    });\r\n    if (state.sel) {\r\n      n.sel = {\r\n        head: state.sel.head && copyCursor(state.sel.head),\r\n        anchor: state.sel.anchor && copyCursor(state.sel.anchor)\r\n      };\r\n    }\r\n    return n;\r\n  }\r\n  function multiSelectHandleKey(cm, key, origin) {\r\n    var isHandled = false;\r\n    var vim = Vim.maybeInitVimState_(cm);\r\n    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\r\n    if (vim.wasInVisualBlock && !cm.ace.inMultiSelectMode) {\r\n      vim.wasInVisualBlock = false;\r\n    } else if (cm.ace.inMultiSelectMode && vim.visualBlock) {\r\n       vim.wasInVisualBlock = true;\r\n    }\r\n    \r\n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && cm.ace.inMultiSelectMode) {\r\n      cm.ace.exitMultiSelectMode();\r\n    } else if (visualBlock || !cm.ace.inMultiSelectMode || cm.ace.inVirtualSelectionMode) {\r\n      isHandled = Vim.handleKey(cm, key, origin);\r\n    } else {\r\n      var old = cloneVimState(vim);\r\n      cm.operation(function() {\r\n        cm.ace.forEachSelection(function() {\r\n          var sel = cm.ace.selection;\r\n          cm.state.vim.lastHPos = sel.$desiredColumn == null ? sel.lead.column : sel.$desiredColumn;\r\n          var head = cm.getCursor(\"head\");\r\n          var anchor = cm.getCursor(\"anchor\");\r\n          var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\r\n          var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\r\n          head = offsetCursor(head, 0, headOffset);\r\n          anchor = offsetCursor(anchor, 0, anchorOffset);\r\n          cm.state.vim.sel.head = head;\r\n          cm.state.vim.sel.anchor = anchor;\r\n          \r\n          isHandled = handleKey(cm, key, origin);\r\n          sel.$desiredColumn = cm.state.vim.lastHPos == -1 ? null : cm.state.vim.lastHPos;\r\n          if (cm.virtualSelectionMode()) {\r\n            cm.state.vim = cloneVimState(old);\r\n          }\r\n        });\r\n        if (cm.curOp.cursorActivity && !isHandled)\r\n          cm.curOp.cursorActivity = false;\r\n      }, true);\r\n    }\r\n    if (isHandled && !vim.visualMode && !vim.insert)\r\n      handleExternalSelection(cm, vim);\r\n    return isHandled;\r\n  }\r\n  exports.CodeMirror = CodeMirror;\r\n  var getVim = Vim.maybeInitVimState_;\r\n  exports.handler = {\r\n    $id: \"ace/keyboard/vim\",\r\n    drawCursor: function(element, pixelPos, config, sel, session) {\r\n      var vim = this.state.vim || {};\r\n      var w = config.characterWidth;\r\n      var h = config.lineHeight;\r\n      var top = pixelPos.top;\r\n      var left = pixelPos.left;\r\n      if (!vim.insertMode) {\r\n        var isbackwards = !sel.cursor \r\n            ? session.selection.isBackwards() || session.selection.isEmpty()\r\n            : Range.comparePoints(sel.cursor, sel.start) <= 0;\r\n        if (!isbackwards && left > w)\r\n          left -= w;\r\n      }     \r\n      if (!vim.insertMode && vim.status) {\r\n        h = h / 2;\r\n        top += h;\r\n      }\r\n      dom.translate(element, left, top);\r\n      dom.setStyle(element.style, \"width\", w + \"px\");\r\n      dom.setStyle(element.style, \"height\", h + \"px\");\r\n    },\r\n    handleKeyboard: function(data, hashId, key, keyCode, e) {\r\n      var editor = data.editor;\r\n      var cm = editor.state.cm;\r\n      var vim = getVim(cm);\r\n      if (keyCode == -1) return;\r\n      \r\n      // in non-insert mode we try to find the ascii key corresponding to the text in textarea\r\n      // this is needed because in languages that use latin alphabet we want to get the key that browser sends to the textarea\r\n      // and in non\r\n      if (!vim.insertMode) {\r\n        if (hashId == -1) {\r\n          if (key.charCodeAt(0) > 0xFF) {\r\n            if (data.inputKey) {\r\n              key = data.inputKey;\r\n              if (key && data.inputHash == 4)\r\n                key = key.toUpperCase();\r\n            }\r\n          }\r\n          data.inputChar = key;\r\n        }\r\n        else if (hashId == 4 || hashId == 0) {\r\n          if (data.inputKey == key && data.inputHash == hashId && data.inputChar) {\r\n            // on mac text input doesn't repeat\r\n            key = data.inputChar;\r\n            hashId = -1\r\n          }\r\n          else {\r\n            data.inputChar = null;\r\n            data.inputKey = key;\r\n            data.inputHash = hashId;\r\n          }\r\n        }\r\n        else {\r\n          data.inputChar = data.inputKey = null;\r\n        }\r\n      }\r\n      \r\n      // ctrl-c is special it both exits mode and copies text\r\n      if (key == \"c\" && hashId == 1) { // key == \"ctrl-c\"\r\n        if (!useragent.isMac && editor.getCopyText()) {\r\n          editor.once(\"copy\", function() {\r\n            editor.selection.clearSelection();\r\n          });\r\n          return {command: \"null\", passEvent: true};\r\n        }\r\n      }\r\n      \r\n      if (key == \"esc\" && !vim.insertMode && !vim.visualMode && !cm.ace.inMultiSelectMode) {\r\n        var searchState = getSearchState(cm);\r\n        var overlay = searchState.getOverlay();\r\n        if (overlay) cm.removeOverlay(overlay);\r\n      }\r\n      \r\n      if (hashId == -1 || hashId & 1 || hashId === 0 && key.length > 1) {\r\n        var insertMode = vim.insertMode;\r\n        var name = lookupKey(hashId, key, e || {});\r\n        if (vim.status == null)\r\n          vim.status = \"\";\r\n        var isHandled = multiSelectHandleKey(cm, name, 'user');\r\n        vim = getVim(cm); // may be changed by multiSelectHandleKey\r\n        if (isHandled && vim.status != null)\r\n          vim.status += name;\r\n        else if (vim.status == null)\r\n          vim.status = \"\";\r\n        cm._signal(\"changeStatus\");\r\n        if (!isHandled && (hashId != -1 || insertMode))\r\n          return;\r\n        return {command: \"null\", passEvent: !isHandled};\r\n      }\r\n    },\r\n    attach: function(editor) {\r\n      if (!editor.state) editor.state = {};\r\n      var cm = new CodeMirror(editor);\r\n      editor.state.cm = cm;\r\n      editor.$vimModeHandler = this;\r\n      CodeMirror.keyMap.vim.attach(cm);\r\n      getVim(cm).status = null;\r\n      cm.on('vim-command-done', function() {\r\n        if (cm.virtualSelectionMode()) return;\r\n        getVim(cm).status = null;\r\n        cm.ace._signal(\"changeStatus\");\r\n        cm.ace.session.markUndoGroup();\r\n      });\r\n      cm.on(\"changeStatus\", function() {\r\n        cm.ace.renderer.updateCursor();\r\n        cm.ace._signal(\"changeStatus\");\r\n      });\r\n      cm.on(\"vim-mode-change\", function() {\r\n        if (cm.virtualSelectionMode()) return;\r\n        updateInputMode();\r\n        cm._signal(\"changeStatus\");\r\n      });\r\n      function updateInputMode() {\r\n        var isIntsert = getVim(cm).insertMode;\r\n        cm.ace.renderer.setStyle(\"normal-mode\", !isIntsert);\r\n        editor.textInput.setCommandMode(!isIntsert);\r\n        // without this press and hodl popup in mac is shown in normal mode\r\n        editor.renderer.$keepTextAreaAtCursor = isIntsert;\r\n        editor.renderer.$blockCursor = !isIntsert;\r\n      }\r\n      updateInputMode();\r\n      editor.renderer.$cursorLayer.drawCursor = this.drawCursor.bind(cm);\r\n    },\r\n    detach: function(editor) {\r\n      var cm = editor.state.cm;\r\n      CodeMirror.keyMap.vim.detach(cm);\r\n      cm.destroy();\r\n      editor.state.cm = null;\r\n      editor.$vimModeHandler = null;\r\n      editor.renderer.$cursorLayer.drawCursor = null;\r\n      editor.renderer.setStyle(\"normal-mode\", false);\r\n      editor.textInput.setCommandMode(false);\r\n      editor.renderer.$keepTextAreaAtCursor = true;\r\n    },\r\n    getStatusText: function(editor) {\r\n      var cm = editor.state.cm;\r\n      var vim = getVim(cm);\r\n      if (vim.insertMode)\r\n        return \"INSERT\";\r\n      var status = \"\";\r\n      if (vim.visualMode) {\r\n        status += \"VISUAL\";\r\n        if (vim.visualLine)\r\n          status += \" LINE\";\r\n        if (vim.visualBlock)\r\n          status += \" BLOCK\";\r\n      }\r\n      if (vim.status)\r\n        status += (status ? \" \" : \"\") + vim.status;\r\n      return status;\r\n    }\r\n  };\r\n  Vim.defineOption({\r\n    name: \"wrap\",\r\n    set: function(value, cm) {\r\n      if (cm) {cm.ace.setOption(\"wrap\", value)}\r\n    },\r\n    type: \"boolean\"\r\n  }, false);\r\n  Vim.defineEx('write', 'w', function() {\r\n    console.log(':write is not implemented')\r\n  });\r\n  defaultKeymap.push(\r\n    { keys: 'zc', type: 'action', action: 'fold', actionArgs: { open: false } },\r\n    { keys: 'zC', type: 'action', action: 'fold', actionArgs: { open: false, all: true } },\r\n    { keys: 'zo', type: 'action', action: 'fold', actionArgs: { open: true } },\r\n    { keys: 'zO', type: 'action', action: 'fold', actionArgs: { open: true, all: true } },\r\n    { keys: 'za', type: 'action', action: 'fold', actionArgs: { toggle: true } },\r\n    { keys: 'zA', type: 'action', action: 'fold', actionArgs: { toggle: true, all: true } },\r\n    { keys: 'zf', type: 'action', action: 'fold', actionArgs: { open: true, all: true } },\r\n    { keys: 'zd', type: 'action', action: 'fold', actionArgs: { open: true, all: true } },\r\n    \r\n    { keys: '<C-A-k>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorAbove\" } },\r\n    { keys: '<C-A-j>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorBelow\" } },\r\n    { keys: '<C-A-S-k>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorAboveSkipCurrent\" } },\r\n    { keys: '<C-A-S-j>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorBelowSkipCurrent\" } },\r\n    { keys: '<C-A-h>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectMoreBefore\" } },\r\n    { keys: '<C-A-l>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectMoreAfter\" } },\r\n    { keys: '<C-A-S-h>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectNextBefore\" } },\r\n    { keys: '<C-A-S-l>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectNextAfter\" } }\r\n  );\r\n  actions.aceCommand = function(cm, actionArgs, vim) {\r\n    cm.vimCmd = actionArgs;\r\n    if (cm.ace.inVirtualSelectionMode)\r\n      cm.ace.on(\"beforeEndOperation\", delayedExecAceCommand);\r\n    else\r\n      delayedExecAceCommand(null, cm.ace);\r\n  };\r\n  function delayedExecAceCommand(op, ace) {\r\n    ace.off(\"beforeEndOperation\", delayedExecAceCommand);\r\n    var cmd = ace.state.cm.vimCmd;\r\n    if (cmd) {\r\n      ace.execCommand(cmd.exec ? cmd : cmd.name, cmd.args);\r\n    }\r\n    ace.curOp = ace.prevOp;\r\n  }\r\n  actions.fold = function(cm, actionArgs, vim) {\r\n    cm.ace.execCommand(['toggleFoldWidget', 'toggleFoldWidget', 'foldOther', 'unfoldall'\r\n      ][(actionArgs.all ? 2 : 0) + (actionArgs.open ? 1 : 0)]);\r\n  };\r\n\r\n  exports.handler.defaultKeymap = defaultKeymap;\r\n  exports.handler.actions = actions;\r\n  exports.Vim = Vim;\r\n  \r\n  Vim.map(\"Y\", \"yy\", \"normal\");\r\n});\r\n"]}