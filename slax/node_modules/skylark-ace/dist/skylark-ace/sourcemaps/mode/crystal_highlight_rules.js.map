{"version":3,"sources":["mode/crystal_highlight_rules.js"],"names":["define","require","exports","module","oop","TextHighlightRules","CrystalHighlightRules","keywordMapper","this","$keywords","createKeywordMapper","keyword","constant.language","variable.language","support.function","extEscapeExspresssion","$rules","start","token","regex","push","next","defaultToken","onMatch","val","state","stack","nextState","length","unshift","shift","indexOf","stateName","value","currentState","tokens","split","splitRegex","type","rules","heredoc","normalizeRules","inherits"],"mappings":"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","file":"../../mode/crystal_highlight_rules.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function (require, exports, module) {\r\n    \"use strict\";\r\n\r\n    var oop = require(\"../lib/oop\");\r\n    var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\r\n\r\n    var CrystalHighlightRules = function () {\r\n\r\n        var builtinFunctions = (\r\n            \"puts|initialize|previous_def|typeof|as|pointerof|sizeof|instance_sizeof\"\r\n        );\r\n\r\n        var keywords = (\r\n            \"if|end|else|elsif|unless|case|when|break|while|next|until|def|return|class|new|getter|setter|property|lib\"\r\n            + \"|fun|do|struct|private|protected|public|module|super|abstract|include|extend|begin|enum|raise|yield|with\"\r\n            + \"|alias|rescue|ensure|macro|uninitialized|union|type|require\"\r\n        );\r\n\r\n        var buildinConstants = (\r\n            \"true|TRUE|false|FALSE|nil|NIL|__LINE__|__END_LINE__|__FILE__|__DIR__\"\r\n        );\r\n\r\n        var builtinVariables = (\r\n            \"$DEBUG|$defout|$FILENAME|$LOAD_PATH|$SAFE|$stdin|$stdout|$stderr|$VERBOSE|\" +\r\n            \"root_url|flash|session|cookies|params|request|response|logger|self\"\r\n        );\r\n\r\n        var keywordMapper = this.$keywords = this.createKeywordMapper({\r\n            \"keyword\": keywords,\r\n            \"constant.language\": buildinConstants,\r\n            \"variable.language\": builtinVariables,\r\n            \"support.function\": builtinFunctions\r\n        }, \"identifier\");\r\n\r\n        var hexNumber = \"(?:0[xX][\\\\dA-Fa-f]+)\";\r\n        var decNumber = \"(?:[0-9][\\\\d_]*)\";\r\n        var octNumber = \"(?:0o[0-7][0-7]*)\";\r\n        var binNumber = \"(?:0[bB][01]+)\";\r\n        var intNumber = \"(?:[+-]?)(?:\" + hexNumber + \"|\" + decNumber + \"|\" + octNumber + \"|\" + binNumber + \")(?:_?[iIuU](?:8|16|32|64))?\\\\b\";\r\n        var escapeExpression = /\\\\(?:[nsrtvfbae'\"\\\\]|[0-7]{3}|x[\\da-fA-F]{2}|u[\\da-fA-F]{4}|u{[\\da-fA-F]{1,6}})/;\r\n        var extEscapeExspresssion = /\\\\(?:[nsrtvfbae'\"\\\\]|[0-7]{3}|x[\\da-fA-F]{2}|u[\\da-fA-F]{4}|u{[\\da-fA-F]{1,6}}|u{(:?[\\da-fA-F]{2}\\s)*[\\da-fA-F]{2}})/;\r\n        // regexp must not have capturing parentheses. Use (?:) instead.\r\n        // regexps are ordered -> the first match is used\r\n\r\n        this.$rules = {\r\n            \"start\": [\r\n                {\r\n                    token: \"comment\",\r\n                    regex: \"#.*$\"\r\n                }, {\r\n                    token: \"string.regexp\",\r\n                    regex: \"[/]\",\r\n                    push: [{\r\n                        token: \"constant.language.escape\",\r\n                        regex: extEscapeExspresssion\r\n                    }, {\r\n                        token: \"string.regexp\",\r\n                        regex: \"[/][imx]*(?=[).,;\\\\s]|$)\",\r\n                        next: \"pop\"\r\n                    }, {\r\n                        defaultToken: \"string.regexp\"\r\n                    }]\r\n                },\r\n                [{\r\n                    regex: \"[{}]\", onMatch: function (val, state, stack) {\r\n                        this.next = val == \"{\" ? this.nextState : \"\";\r\n                        if (val == \"{\" && stack.length) {\r\n                            stack.unshift(\"start\", state);\r\n                            return \"paren.lparen\";\r\n                        }\r\n                        if (val == \"}\" && stack.length) {\r\n                            stack.shift();\r\n                            this.next = stack.shift();\r\n                            if (this.next.indexOf(\"string\") != -1)\r\n                                return \"paren.end\";\r\n                        }\r\n                        return val == \"{\" ? \"paren.lparen\" : \"paren.rparen\";\r\n                    },\r\n                    nextState: \"start\"\r\n                }, {\r\n                    token: \"string.start\",\r\n                    regex: /\"/,\r\n                    push: [{\r\n                        token: \"constant.language.escape\",\r\n                        regex: extEscapeExspresssion\r\n                    }, {\r\n                        token: \"string\",\r\n                        regex: /\\\\#{/\r\n                    }, {\r\n                        token: \"paren.start\",\r\n                        regex: /#{/,\r\n                        push: \"start\"\r\n                    }, {\r\n                        token: \"string.end\",\r\n                        regex: /\"/,\r\n                        next: \"pop\"\r\n                    }, {\r\n                        defaultToken: \"string\"\r\n                    }]\r\n                }, {\r\n                    token: \"string.start\",\r\n                    regex: /`/,\r\n                    push: [{\r\n                        token: \"constant.language.escape\",\r\n                        regex: extEscapeExspresssion\r\n                    }, {\r\n                        token: \"string\",\r\n                        regex: /\\\\#{/\r\n                    }, {\r\n                        token: \"paren.start\",\r\n                        regex: /#{/,\r\n                        push: \"start\"\r\n                    }, {\r\n                        token: \"string.end\",\r\n                        regex: /`/,\r\n                        next: \"pop\"\r\n                    }, {\r\n                        defaultToken: \"string\"\r\n                    }]\r\n                }, {\r\n                    stateName: \"rpstring\",\r\n                    token: \"string.start\",\r\n                    regex: /%[Qx]?\\(/,\r\n                    push: [{\r\n                        token: \"constant.language.escape\",\r\n                        regex: extEscapeExspresssion\r\n                    }, {\r\n                        token: \"string.start\",\r\n                        regex: /\\(/,\r\n                        push: \"rpstring\"\r\n                    }, {\r\n                        token: \"string.end\",\r\n                        regex: /\\)/,\r\n                        next: \"pop\"\r\n                    }, {\r\n                        token: \"paren.start\",\r\n                        regex: /#{/,\r\n                        push: \"start\"\r\n                    }, {\r\n                        defaultToken: \"string\"\r\n                    }]\r\n                }, {\r\n                    stateName: \"spstring\",\r\n                    token: \"string.start\",\r\n                    regex: /%[Qx]?\\[/,\r\n                    push: [{\r\n                        token: \"constant.language.escape\",\r\n                        regex: extEscapeExspresssion\r\n                    }, {\r\n                        token: \"string.start\",\r\n                        regex: /\\[/,\r\n                        push: \"spstring\"\r\n                    }, {\r\n                        token: \"string.end\",\r\n                        regex: /]/,\r\n                        next: \"pop\"\r\n                    }, {\r\n                        token: \"paren.start\",\r\n                        regex: /#{/,\r\n                        push: \"start\"\r\n                    }, {\r\n                        defaultToken: \"string\"\r\n                    }]\r\n                }, {\r\n                    stateName: \"fpstring\",\r\n                    token: \"string.start\",\r\n                    regex: /%[Qx]?{/,\r\n                    push: [{\r\n                        token: \"constant.language.escape\",\r\n                        regex: extEscapeExspresssion\r\n                    }, {\r\n                        token: \"string.start\",\r\n                        regex: /{/,\r\n                        push: \"fpstring\"\r\n                    }, {\r\n                        token: \"string.end\",\r\n                        regex: /}/,\r\n                        next: \"pop\"\r\n                    }, {\r\n                        token: \"paren.start\",\r\n                        regex: /#{/,\r\n                        push: \"start\"\r\n                    }, {\r\n                        defaultToken: \"string\"\r\n                    }]\r\n                }, {\r\n                    stateName: \"tpstring\",\r\n                    token: \"string.start\",\r\n                    regex: /%[Qx]?</,\r\n                    push: [{\r\n                        token: \"constant.language.escape\",\r\n                        regex: extEscapeExspresssion\r\n                    }, {\r\n                        token: \"string.start\",\r\n                        regex: /</,\r\n                        push: \"tpstring\"\r\n                    }, {\r\n                        token: \"string.end\",\r\n                        regex: />/,\r\n                        next: \"pop\"\r\n                    }, {\r\n                        token: \"paren.start\",\r\n                        regex: /#{/,\r\n                        push: \"start\"\r\n                    }, {\r\n                        defaultToken: \"string\"\r\n                    }]\r\n                }, {\r\n                    stateName: \"ppstring\",\r\n                    token: \"string.start\",\r\n                    regex: /%[Qx]?\\|/,\r\n                    push: [{\r\n                        token: \"constant.language.escape\",\r\n                        regex: extEscapeExspresssion\r\n                    }, {\r\n                        token: \"string.end\",\r\n                        regex: /\\|/,\r\n                        next: \"pop\"\r\n                    }, {\r\n                        token: \"paren.start\",\r\n                        regex: /#{/,\r\n                        push: \"start\"\r\n                    }, {\r\n                        defaultToken: \"string\"\r\n                    }]\r\n                }, {\r\n                    stateName: \"rpqstring\",\r\n                    token: \"string.start\",\r\n                    regex: /%[qwir]\\(/,\r\n                    push: [{\r\n                        token: \"string.start\",\r\n                        regex: /\\(/,\r\n                        push: \"rpqstring\"\r\n                    }, {\r\n                        token: \"string.end\",\r\n                        regex: /\\)/,\r\n                        next: \"pop\"\r\n                    }, {\r\n                        defaultToken: \"string\"\r\n                    }]\r\n                }, {\r\n                    stateName: \"spqstring\",\r\n                    token: \"string.start\",\r\n                    regex: /%[qwir]\\[/,\r\n                    push: [{\r\n                        token: \"string.start\",\r\n                        regex: /\\[/,\r\n                        push: \"spqstring\"\r\n                    }, {\r\n                        token: \"string.end\",\r\n                        regex: /]/,\r\n                        next: \"pop\"\r\n                    }, {\r\n                        defaultToken: \"string\"\r\n                    }]\r\n                }, {\r\n                    stateName: \"fpqstring\",\r\n                    token: \"string.start\",\r\n                    regex: /%[qwir]{/,\r\n                    push: [{\r\n                        token: \"string.start\",\r\n                        regex: /{/,\r\n                        push: \"fpqstring\"\r\n                    }, {\r\n                        token: \"string.end\",\r\n                        regex: /}/,\r\n                        next: \"pop\"\r\n                    }, {\r\n                        defaultToken: \"string\"\r\n                    }]\r\n                }, {\r\n                    stateName: \"tpqstring\",\r\n                    token: \"string.start\",\r\n                    regex: /%[qwir]</,\r\n                    push: [{\r\n                        token: \"string.start\",\r\n                        regex: /</,\r\n                        push: \"tpqstring\"\r\n                    }, {\r\n                        token: \"string.end\",\r\n                        regex: />/,\r\n                        next: \"pop\"\r\n                    }, {\r\n                        defaultToken: \"string\"\r\n                    }]\r\n                }, {\r\n                    stateName: \"ppqstring\",\r\n                    token: \"string.start\",\r\n                    regex: /%[qwir]\\|/,\r\n                    push: [{\r\n                        token: \"string.end\",\r\n                        regex: /\\|/,\r\n                        next: \"pop\"\r\n                    }, {\r\n                        defaultToken: \"string\"\r\n                    }]\r\n                }, {\r\n                    token: \"string.start\",\r\n                    regex: /'/,\r\n                    push: [{\r\n                        token: \"constant.language.escape\",\r\n                        regex: escapeExpression\r\n                    }, {\r\n                        token: \"string.end\",\r\n                        regex: /'|$/,\r\n                        next: \"pop\"\r\n                    }, {\r\n                        defaultToken: \"string\"\r\n                    }]\r\n                }], {\r\n                    token: \"text\", // namespaces aren't symbols\r\n                    regex: \"::\"\r\n                }, {\r\n                    token: \"variable.instance\", // instance variable\r\n                    regex: \"@{1,2}[a-zA-Z_\\\\d]+\"\r\n                }, {\r\n                    token: \"variable.fresh\", // fresh variable\r\n                    regex: \"%[a-zA-Z_\\\\d]+\"\r\n                }, {\r\n                    token: \"support.class\", // class name\r\n                    regex: \"[A-Z][a-zA-Z_\\\\d]+\"\r\n                }, {\r\n                    token: \"constant.other.symbol\", // symbol\r\n                    regex: \"[:](?:(?:===|<=>|\\\\[]\\\\?|\\\\[]=|\\\\[]|>>|\\\\*\\\\*|<<|==|!=|>=|<=|!~|=~|<|\\\\+|-|\\\\*|\\\\/|%|&|\\\\||\\\\^|>|!|~)|(?:(?:[A-Za-z_]|[@$](?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*[!=?]?))\"\r\n                }, {\r\n                    token: \"constant.numeric\", // float\r\n                    regex: \"[+-]?\\\\d(?:\\\\d|_(?=\\\\d))*(?:(?:\\\\.\\\\d(?:\\\\d|_(?=\\\\d))*)?(?:[eE][+-]?\\\\d+)?)?(?:_?[fF](?:32|64))?\\\\b\"\r\n                }, {\r\n                    token: \"constant.numeric\",\r\n                    regex: intNumber\r\n                }, {\r\n                    token: \"constant.other.symbol\",\r\n                    regex: ':\"',\r\n                    push: [{\r\n                        token: \"constant.language.escape\",\r\n                        regex: extEscapeExspresssion\r\n                    }, {\r\n                        token: \"constant.other.symbol\",\r\n                        regex: '\"',\r\n                        next: \"pop\"\r\n                    }, {\r\n                        defaultToken: \"constant.other.symbol\"\r\n                    }]\r\n                }, {\r\n                    token: \"constant.language.boolean\",\r\n                    regex: \"(?:true|false)\\\\b\"\r\n                }, {\r\n                    token: \"support.function\",\r\n                    regex: \"(?:is_a\\\\?|nil\\\\?|responds_to\\\\?|as\\\\?)\"\r\n                }, {\r\n                    token: keywordMapper,\r\n                    regex: \"[a-zA-Z_$][a-zA-Z0-9_$!?]*\\\\b\"\r\n                }, {\r\n                    token: \"variable.system\",\r\n                    regex: \"\\\\$\\\\!|\\\\$\\\\?\"\r\n                }, {\r\n                    token: \"punctuation.separator.key-value\",\r\n                    regex: \"=>\"\r\n                }, {\r\n                    stateName: \"heredoc\",\r\n                    onMatch: function (value, currentState, stack) {\r\n                        var next = \"heredoc\";\r\n                        var tokens = value.split(this.splitRegex);\r\n                        stack.push(next, tokens[3]);\r\n                        return [\r\n                            {type: \"constant\", value: tokens[1]},\r\n                            {type: \"string\", value: tokens[2]},\r\n                            {type: \"support.class\", value: tokens[3]},\r\n                            {type: \"string\", value: tokens[4]}\r\n                        ];\r\n                    },\r\n                    regex: \"(<<-)([']?)([\\\\w]+)([']?)\",\r\n                    rules: {\r\n                        heredoc: [{\r\n                            token: \"string\",\r\n                            regex: \"^ +\"\r\n                        }, {\r\n                            onMatch: function (value, currentState, stack) {\r\n                                if (value === stack[1]) {\r\n                                    stack.shift();\r\n                                    stack.shift();\r\n                                    this.next = stack[0] || \"start\";\r\n                                    return \"support.class\";\r\n                                }\r\n                                this.next = \"\";\r\n                                return \"string\";\r\n                            },\r\n                            regex: \".*$\",\r\n                            next: \"start\"\r\n                        }]\r\n                    }\r\n                }, {\r\n                    regex: \"$\",\r\n                    token: \"empty\",\r\n                    next: function (currentState, stack) {\r\n                        if (stack[0] === \"heredoc\")\r\n                            return stack[0];\r\n                        return currentState;\r\n                    }\r\n                }, {\r\n                    token: \"punctuation.operator\",\r\n                    regex: /[.]\\s*(?![.])/,\r\n                    push: [{\r\n                        token : \"punctuation.operator\",\r\n                        regex : /[.]\\s*(?![.])/\r\n                    }, {\r\n                        token : \"support.function\",\r\n                        regex : \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\r\n                    }, {\r\n                        regex: \"\",\r\n                        token: \"empty\",\r\n                        next: \"pop\"\r\n                    }]\r\n                }, {\r\n                    token: \"keyword.operator\",\r\n                    regex: \"!|\\\\$|%|&|\\\\*|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|\\\\?|\\\\:|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=|\\\\^|\\\\|\"\r\n                }, {\r\n                    token: \"punctuation.operator\",\r\n                    regex: /[?:,;.]/\r\n                }, {\r\n                    token: \"paren.lparen\",\r\n                    regex: \"[[({]\"\r\n                }, {\r\n                    token: \"paren.rparen\",\r\n                    regex: \"[\\\\])}]\"\r\n                }, {\r\n                    token: \"text\",\r\n                    regex: \"\\\\s+\"\r\n                }\r\n            ]\r\n        };\r\n\r\n        this.normalizeRules();\r\n    };\r\n\r\n    oop.inherits(CrystalHighlightRules, TextHighlightRules);\r\n\r\n    exports.CrystalHighlightRules = CrystalHighlightRules;\r\n});\r\n"]}