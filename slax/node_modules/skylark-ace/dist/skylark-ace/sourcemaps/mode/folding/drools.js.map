{"version":3,"sources":["mode/folding/drools.js"],"names":["define","require","exports","module","oop","Range","BaseFoldMode","FoldMode","TokenIterator","inherits","this","foldingStartMarker","foldingStopMarker","getFoldWidgetRange","session","foldStyle","row","line","getLine","match","index","position","column","length","iterator","seek","token","getCurrentToken","value","fromPoints","getCurrentTokenRow","getCurrentTokenColumn","stepForward","call","prototype"],"mappings":";;;;;;;AAAAA,OAAO,SAASC,EAASC,EAASC,GAClC,aAEA,IAAIC,EAAMH,EAAQ,iBACdI,EAAQJ,EAAQ,eAAeI,MAC/BC,EAAeL,EAAQ,eAAeM,SACtCC,EAAgBP,EAAQ,wBAAwBO,cAEhDD,EAAWL,EAAQK,SAAW,aAClCH,EAAIK,SAASF,EAAUD,GAEvB,WAGII,KAAKC,mBAAqB,qCAC1BD,KAAKE,kBAAoB,UAEzBF,KAAKG,mBAAqB,SAASC,EAASC,EAAWC,GACnD,IAAIC,EAAOH,EAAQI,QAAQF,GACvBG,EAAQF,EAAKE,MAAMT,KAAKC,oBAC5B,GAAIQ,EAAO,CACCA,EAAMC,MAEd,GAAID,EAAM,GAAI,CACV,IAAIE,GAAYL,IAAKA,EAAKM,OAAQL,EAAKM,QACnCC,EAAW,IAAIhB,EAAcM,EAASO,EAASL,IAAKK,EAASC,QAC7DG,EAAO,MACPC,EAAQF,EAASG,kBAIrB,IAHmB,QAAfD,EAAME,QACNH,EAAO,QAEJC,GAAO,CACV,GAAIA,EAAME,OAASH,EACf,OAAOpB,EAAMwB,WAAWR,GACpBL,IAAKQ,EAASM,qBACdR,OAAQE,EAASO,0BAGzBL,EAAQF,EAASQ,mBAQlCC,KAAK1B,EAAS2B","file":"../../../mode/folding/drools.js","sourcesContent":["define(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar oop = require(\"../../lib/oop\");\r\nvar Range = require(\"../../range\").Range;\r\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\r\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\r\n\r\nvar FoldMode = exports.FoldMode = function() {};\r\noop.inherits(FoldMode, BaseFoldMode);\r\n\r\n(function() {\r\n\r\n    // regular expressions that identify starting and stopping points\r\n    this.foldingStartMarker = /\\b(rule|declare|query|when|then)\\b/; \r\n    this.foldingStopMarker = /\\bend\\b/;\r\n\r\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\r\n        var line = session.getLine(row);\r\n        var match = line.match(this.foldingStartMarker);\r\n        if (match) {\r\n            var i = match.index;\r\n\r\n            if (match[1]) {\r\n                var position = {row: row, column: line.length};\r\n                var iterator = new TokenIterator(session, position.row, position.column);\r\n                var seek = \"end\";\r\n                var token = iterator.getCurrentToken();\r\n                if (token.value == \"when\") {\r\n                    seek = \"then\";\r\n                }\r\n                while (token) {\r\n                    if (token.value == seek) { \r\n                        return Range.fromPoints(position ,{\r\n                            row: iterator.getCurrentTokenRow(),\r\n                            column: iterator.getCurrentTokenColumn()\r\n                        });\r\n                    }\r\n                    token = iterator.stepForward();\r\n                }\r\n            }\r\n\r\n        }\r\n        // test each line, and return a range of segments to collapse\r\n    };\r\n\r\n}).call(FoldMode.prototype);\r\n\r\n});"]}