{"version":3,"sources":["mode/text_highlight_rules.js"],"names":["define","require","exports","module","lang","TextHighlightRules","this","$rules","start","token","regex","defaultToken","addRules","rules","prefix","key","state","i","length","rule","next","onMatch","indexOf","nextState","getRules","embedRules","HighlightRules","escapeRules","states","append","push","Array","prototype","apply","deepCopy","$embeds","getEmbeds","pushState","currentState","stack","unshift","popState","shift","normalizeRules","id","Object","keys","forEach","processState","processed","toInsert","isArray","end","stateName","r","includeName","include","map","x","args","concat","noEscape","filter","splice","keywordMap","createKeywordMapper","caseInsensitive","ignoreCase","splitChar","keywords","create","className","a","toLowerCase","list","split","getPrototypeOf","__proto__","$keywordList","value","getKeywords","$keywords","call"],"mappings":"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","file":"../../mode/text_highlight_rules.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar lang = require(\"../lib/lang\");\r\n\r\nvar TextHighlightRules = function() {\r\n\r\n    // regexp must not have capturing parentheses\r\n    // regexps are ordered -> the first match is used\r\n\r\n    this.$rules = {\r\n        \"start\" : [{\r\n            token : \"empty_line\",\r\n            regex : '^$'\r\n        }, {\r\n            defaultToken : \"text\"\r\n        }]\r\n    };\r\n};\r\n\r\n(function() {\r\n\r\n    this.addRules = function(rules, prefix) {\r\n        if (!prefix) {\r\n            for (var key in rules)\r\n                this.$rules[key] = rules[key];\r\n            return;\r\n        }\r\n        for (var key in rules) {\r\n            var state = rules[key];\r\n            for (var i = 0; i < state.length; i++) {\r\n                var rule = state[i];\r\n                if (rule.next || rule.onMatch) {\r\n                    if (typeof rule.next == \"string\") {\r\n                        if (rule.next.indexOf(prefix) !== 0)\r\n                            rule.next = prefix + rule.next;\r\n                    }\r\n                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)\r\n                        rule.nextState = prefix + rule.nextState;\r\n                }\r\n            }\r\n            this.$rules[prefix + key] = state;\r\n        }\r\n    };\r\n\r\n    this.getRules = function() {\r\n        return this.$rules;\r\n    };\r\n\r\n    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {\r\n        var embedRules = typeof HighlightRules == \"function\"\r\n            ? new HighlightRules().getRules()\r\n            : HighlightRules;\r\n        if (states) {\r\n            for (var i = 0; i < states.length; i++)\r\n                states[i] = prefix + states[i];\r\n        } else {\r\n            states = [];\r\n            for (var key in embedRules)\r\n                states.push(prefix + key);\r\n        }\r\n\r\n        this.addRules(embedRules, prefix);\r\n\r\n        if (escapeRules) {\r\n            var addRules = Array.prototype[append ? \"push\" : \"unshift\"];\r\n            for (var i = 0; i < states.length; i++)\r\n                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));\r\n        }\r\n\r\n        if (!this.$embeds)\r\n            this.$embeds = [];\r\n        this.$embeds.push(prefix);\r\n    };\r\n\r\n    this.getEmbeds = function() {\r\n        return this.$embeds;\r\n    };\r\n\r\n    var pushState = function(currentState, stack) {\r\n        if (currentState != \"start\" || stack.length)\r\n            stack.unshift(this.nextState, currentState);\r\n        return this.nextState;\r\n    };\r\n    var popState = function(currentState, stack) {\r\n        // if (stack[0] === currentState)\r\n        stack.shift();\r\n        return stack.shift() || \"start\";\r\n    };\r\n\r\n    this.normalizeRules = function() {\r\n        var id = 0;\r\n        var rules = this.$rules;\r\n        function processState(key) {\r\n            var state = rules[key];\r\n            state.processed = true;\r\n            for (var i = 0; i < state.length; i++) {\r\n                var rule = state[i];\r\n                var toInsert = null;\r\n                if (Array.isArray(rule)) {\r\n                    toInsert = rule;\r\n                    rule = {};\r\n                }\r\n                if (!rule.regex && rule.start) {\r\n                    rule.regex = rule.start;\r\n                    if (!rule.next)\r\n                        rule.next = [];\r\n                    rule.next.push({\r\n                        defaultToken: rule.token\r\n                    }, {\r\n                        token: rule.token + \".end\",\r\n                        regex: rule.end || rule.start,\r\n                        next: \"pop\"\r\n                    });\r\n                    rule.token = rule.token + \".start\";\r\n                    rule.push = true;\r\n                }\r\n                var next = rule.next || rule.push;\r\n                if (next && Array.isArray(next)) {\r\n                    var stateName = rule.stateName;\r\n                    if (!stateName)  {\r\n                        stateName = rule.token;\r\n                        if (typeof stateName != \"string\")\r\n                            stateName = stateName[0] || \"\";\r\n                        if (rules[stateName])\r\n                            stateName += id++;\r\n                    }\r\n                    rules[stateName] = next;\r\n                    rule.next = stateName;\r\n                    processState(stateName);\r\n                } else if (next == \"pop\") {\r\n                    rule.next = popState;\r\n                }\r\n\r\n                if (rule.push) {\r\n                    rule.nextState = rule.next || rule.push;\r\n                    rule.next = pushState;\r\n                    delete rule.push;\r\n                }\r\n\r\n                if (rule.rules) {\r\n                    for (var r in rule.rules) {\r\n                        if (rules[r]) {\r\n                            if (rules[r].push)\r\n                                rules[r].push.apply(rules[r], rule.rules[r]);\r\n                        } else {\r\n                            rules[r] = rule.rules[r];\r\n                        }\r\n                    }\r\n                }\r\n                var includeName = typeof rule == \"string\" ? rule : rule.include;\r\n                if (includeName) {\r\n                    if (Array.isArray(includeName))\r\n                        toInsert = includeName.map(function(x) { return rules[x]; });\r\n                    else\r\n                        toInsert = rules[includeName];\r\n                }\r\n\r\n                if (toInsert) {\r\n                    var args = [i, 1].concat(toInsert);\r\n                    if (rule.noEscape)\r\n                        args = args.filter(function(x) {return !x.next;});\r\n                    state.splice.apply(state, args);\r\n                    // skip included rules since they are already processed\r\n                    //i += args.length - 3;\r\n                    i--;\r\n                }\r\n                \r\n                if (rule.keywordMap) {\r\n                    rule.token = this.createKeywordMapper(\r\n                        rule.keywordMap, rule.defaultToken || \"text\", rule.caseInsensitive\r\n                    );\r\n                    delete rule.defaultToken;\r\n                }\r\n            }\r\n        }\r\n        Object.keys(rules).forEach(processState, this);\r\n    };\r\n\r\n    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {\r\n        var keywords = Object.create(null);\r\n        Object.keys(map).forEach(function(className) {\r\n            var a = map[className];\r\n            if (ignoreCase)\r\n                a = a.toLowerCase();\r\n            var list = a.split(splitChar || \"|\");\r\n            for (var i = list.length; i--; )\r\n                keywords[list[i]] = className;\r\n        });\r\n        // in old versions of opera keywords[\"__proto__\"] sets prototype\r\n        // even on objects with __proto__=null\r\n        if (Object.getPrototypeOf(keywords)) {\r\n            keywords.__proto__ = null;\r\n        }\r\n        this.$keywordList = Object.keys(keywords);\r\n        map = null;\r\n        return ignoreCase\r\n            ? function(value) {return keywords[value.toLowerCase()] || defaultToken; }\r\n            : function(value) {return keywords[value] || defaultToken; };\r\n    };\r\n\r\n    this.getKeywords = function() {\r\n        return this.$keywords;\r\n    };\r\n\r\n}).call(TextHighlightRules.prototype);\r\n\r\nexports.TextHighlightRules = TextHighlightRules;\r\n});\r\n"]}