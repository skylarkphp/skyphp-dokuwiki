{"version":3,"sources":["input/indent.js"],"names":["define","a","b","c","d","e","f","g","indentLine","cm","n","how","aggressive","state","doc","mode","indent","getContextBefore","tabSize","options","line","getLine","curSpace","countColumn","text","stateAfter","indentation","curSpaceString","match","test","slice","length","Pass","first","indentUnit","Math","max","indentString","pos","indentWithTabs","i","floor","spaceStr","replaceRange","Pos","sel","ranges","range","head","ch","replaceOneSelection","Range"],"mappings":";;;;;;;AAAAA,QACI,oBACA,cACA,qBACA,mBACA,qBACA,6BACA,gBACD,SAAUC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,GAC3B,aA+DA,OAASC,WA9DT,SAAoBC,EAAIC,EAAGC,EAAKC,GAC5B,IAAkBC,EAAdC,EAAML,EAAGK,IACF,MAAPH,IACAA,EAAM,OACC,SAAPA,IACKG,EAAIC,KAAKC,OAGVH,EAAQZ,EAAEgB,iBAAiBR,EAAIC,GAAGG,MAFlCF,EAAM,QAId,IAAIO,EAAUT,EAAGU,QAAQD,QACrBE,EAAOjB,EAAEkB,QAAQP,EAAKJ,GAAIY,EAAWf,EAAEgB,YAAYH,EAAKI,KAAM,KAAMN,GACpEE,EAAKK,aACLL,EAAKK,WAAa,MACtB,IAAiDC,EAA7CC,EAAiBP,EAAKI,KAAKI,MAAM,QAAQ,GAC7C,GAAKhB,GAAe,KAAKiB,KAAKT,EAAKI,OAG5B,GAAW,SAAPb,KACPe,EAAcZ,EAAIC,KAAKC,OAAOH,EAAOO,EAAKI,KAAKM,MAAMH,EAAeI,QAASX,EAAKI,QAC/DjB,EAAEyB,MAAQN,EAAc,KAAK,CAC5C,IAAKd,EACD,OACJD,EAAM,aAPVe,EAAc,EACdf,EAAM,MASC,QAAPA,EAEIe,EADAhB,EAAII,EAAImB,MACM1B,EAAEgB,YAAYpB,EAAEkB,QAAQP,EAAKJ,EAAI,GAAGc,KAAM,KAAMN,GAEhD,EACJ,OAAPP,EACPe,EAAcJ,EAAWb,EAAGU,QAAQe,WACtB,YAAPvB,EACPe,EAAcJ,EAAWb,EAAGU,QAAQe,WACf,iBAAPvB,IACde,EAAcJ,EAAWX,GAE7Be,EAAcS,KAAKC,IAAI,EAAGV,GAC1B,IAAIW,EAAe,GAAIC,EAAM,EAC7B,GAAI7B,EAAGU,QAAQoB,eACX,IAAK,IAAIC,EAAIL,KAAKM,MAAMf,EAAcR,GAAUsB,IAAKA,EACjDF,GAAOpB,EACPmB,GAAgB,KAIxB,GAFIC,EAAMZ,IACNW,GAAgB9B,EAAEmC,SAAShB,EAAcY,IACzCD,GAAgBV,EAGhB,OAFAvB,EAAEuC,aAAa7B,EAAKuB,EAAcnC,EAAE0C,IAAIlC,EAAG,GAAIR,EAAE0C,IAAIlC,EAAGiB,EAAeI,QAAS,UAChFX,EAAKK,WAAa,MACX,EAEP,IAAK,IAAIe,EAAI,EAAGA,EAAI1B,EAAI+B,IAAIC,OAAOf,OAAQS,IAAK,CAC5C,IAAIO,EAAQjC,EAAI+B,IAAIC,OAAON,GAC3B,GAAIO,EAAMC,KAAK5B,MAAQV,GAAKqC,EAAMC,KAAKC,GAAKtB,EAAeI,OAAQ,CAC/D,IAAIO,EAAMpC,EAAE0C,IAAIlC,EAAGiB,EAAeI,QAClCzB,EAAE4C,oBAAoBpC,EAAK0B,EAAG,IAAInC,EAAE8C,MAAMb,EAAKA,IAC/C","file":"../../input/indent.js","sourcesContent":["define([\n    '../line/highlight',\n    '../line/pos',\n    '../line/utils_line',\n    '../model/changes',\n    '../model/selection',\n    '../model/selection_updates',\n    '../util/misc'\n], function (a, b, c, d, e, f, g) {\n    'use strict';\n    function indentLine(cm, n, how, aggressive) {\n        let doc = cm.doc, state;\n        if (how == null)\n            how = 'add';\n        if (how == 'smart') {\n            if (!doc.mode.indent)\n                how = 'prev';\n            else\n                state = a.getContextBefore(cm, n).state;\n        }\n        let tabSize = cm.options.tabSize;\n        let line = c.getLine(doc, n), curSpace = g.countColumn(line.text, null, tabSize);\n        if (line.stateAfter)\n            line.stateAfter = null;\n        let curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n        if (!aggressive && !/\\S/.test(line.text)) {\n            indentation = 0;\n            how = 'not';\n        } else if (how == 'smart') {\n            indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n            if (indentation == g.Pass || indentation > 150) {\n                if (!aggressive)\n                    return;\n                how = 'prev';\n            }\n        }\n        if (how == 'prev') {\n            if (n > doc.first)\n                indentation = g.countColumn(c.getLine(doc, n - 1).text, null, tabSize);\n            else\n                indentation = 0;\n        } else if (how == 'add') {\n            indentation = curSpace + cm.options.indentUnit;\n        } else if (how == 'subtract') {\n            indentation = curSpace - cm.options.indentUnit;\n        } else if (typeof how == 'number') {\n            indentation = curSpace + how;\n        }\n        indentation = Math.max(0, indentation);\n        let indentString = '', pos = 0;\n        if (cm.options.indentWithTabs)\n            for (let i = Math.floor(indentation / tabSize); i; --i) {\n                pos += tabSize;\n                indentString += '\\t';\n            }\n        if (pos < indentation)\n            indentString += g.spaceStr(indentation - pos);\n        if (indentString != curSpaceString) {\n            d.replaceRange(doc, indentString, b.Pos(n, 0), b.Pos(n, curSpaceString.length), '+input');\n            line.stateAfter = null;\n            return true;\n        } else {\n            for (let i = 0; i < doc.sel.ranges.length; i++) {\n                let range = doc.sel.ranges[i];\n                if (range.head.line == n && range.head.ch < curSpaceString.length) {\n                    let pos = b.Pos(n, curSpaceString.length);\n                    f.replaceOneSelection(doc, i, new e.Range(pos, pos));\n                    break;\n                }\n            }\n        }\n    }\n    return { indentLine: indentLine };\n});"]}