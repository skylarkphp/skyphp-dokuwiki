{"version":3,"sources":["line/spans.js"],"names":["define","misc","pos","saw_special_spans","utils_line","MarkedSpan","marker","from","to","this","getMarkedSpanFor","spans","i","length","span","clearEmptySpans","clearWhenEmpty","splice","extraLeft","inclusiveLeft","extraRight","inclusiveRight","compareCollapsedMarkers","a","b","lenDiff","lines","aPos","find","bPos","fromCmp","cmp","toCmp","id","collapsedSpanAtSide","line","start","found","sps","sawCollapsedSpans","markedSpans","sp","collapsed","collapsedSpanAtStart","collapsedSpanAtEnd","visualLine","merged","lineIsHidden","doc","widgetNode","lineIsHiddenInner","end","text","lineLength","height","len","cur","ch","removeMarkedSpan","r","push","addMarkedSpan","concat","attachLine","stretchSpansOverChange","change","full","oldFirst","isLine","getLine","oldLast","startCh","endCh","isInsert","first","old","nw","type","insertLeft","endsAfter","markedSpansBefore","last","startsBefore","markedSpansAfter","sameLine","offset","lst","newMarkers","gapMarkers","gap","removeReadOnlyRanges","markers","iter","mark","readOnly","indexOf","parts","mk","m","j","p","newParts","dfrom","dto","apply","detachMarkedSpans","detachLine","attachMarkedSpans","collapsedSpanAround","conflictingCollapsedRange","lineNo","visualLineEnd","visualLineContinued","visualLineNo","lineN","vis","visualLineEndNo","lastLine","heightAtLine","lineObj","h","chunk","parent","children","findMaxLine","cm","d","display","maxLine","maxLineLength","maxLineChanged"],"mappings":"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","file":"../../line/spans.js","sourcesContent":["define([\n    '../util/misc',\n    './pos',\n    './saw_special_spans',\n    './utils_line'\n], function (misc, pos, saw_special_spans, utils_line) {\n    'use strict';\n    function MarkedSpan(marker, from, to) {\n        this.marker = marker;\n        this.from = from;\n        this.to = to;\n    }\n    function getMarkedSpanFor(spans, marker) {\n        if (spans)\n            for (let i = 0; i < spans.length; ++i) {\n                let span = spans[i];\n                if (span.marker == marker)\n                    return span;\n            }\n    }\n    function removeMarkedSpan(spans, span) {\n        let r;\n        for (let i = 0; i < spans.length; ++i)\n            if (spans[i] != span)\n                (r || (r = [])).push(spans[i]);\n        return r;\n    }\n    function addMarkedSpan(line, span) {\n        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n        span.marker.attachLine(line);\n    }\n    function markedSpansBefore(old, startCh, isInsert) {\n        let nw;\n        if (old)\n            for (let i = 0; i < old.length; ++i) {\n                let span = old[i], marker = span.marker;\n                let startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n                if (startsBefore || span.from == startCh && marker.type == 'bookmark' && (!isInsert || !span.marker.insertLeft)) {\n                    let endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n                    (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n                }\n            }\n        return nw;\n    }\n    function markedSpansAfter(old, endCh, isInsert) {\n        let nw;\n        if (old)\n            for (let i = 0; i < old.length; ++i) {\n                let span = old[i], marker = span.marker;\n                let endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n                if (endsAfter || span.from == endCh && marker.type == 'bookmark' && (!isInsert || span.marker.insertLeft)) {\n                    let startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n                    (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));\n                }\n            }\n        return nw;\n    }\n    function stretchSpansOverChange(doc, change) {\n        if (change.full)\n            return null;\n        let oldFirst = utils_line.isLine(doc, change.from.line) && utils_line.getLine(doc, change.from.line).markedSpans;\n        let oldLast = utils_line.isLine(doc, change.to.line) && utils_line.getLine(doc, change.to.line).markedSpans;\n        if (!oldFirst && !oldLast)\n            return null;\n        let startCh = change.from.ch, endCh = change.to.ch, isInsert = pos.cmp(change.from, change.to) == 0;\n        let first = markedSpansBefore(oldFirst, startCh, isInsert);\n        let last = markedSpansAfter(oldLast, endCh, isInsert);\n        let sameLine = change.text.length == 1, offset = misc.lst(change.text).length + (sameLine ? startCh : 0);\n        if (first) {\n            for (let i = 0; i < first.length; ++i) {\n                let span = first[i];\n                if (span.to == null) {\n                    let found = getMarkedSpanFor(last, span.marker);\n                    if (!found)\n                        span.to = startCh;\n                    else if (sameLine)\n                        span.to = found.to == null ? null : found.to + offset;\n                }\n            }\n        }\n        if (last) {\n            for (let i = 0; i < last.length; ++i) {\n                let span = last[i];\n                if (span.to != null)\n                    span.to += offset;\n                if (span.from == null) {\n                    let found = getMarkedSpanFor(first, span.marker);\n                    if (!found) {\n                        span.from = offset;\n                        if (sameLine)\n                            (first || (first = [])).push(span);\n                    }\n                } else {\n                    span.from += offset;\n                    if (sameLine)\n                        (first || (first = [])).push(span);\n                }\n            }\n        }\n        if (first)\n            first = clearEmptySpans(first);\n        if (last && last != first)\n            last = clearEmptySpans(last);\n        let newMarkers = [first];\n        if (!sameLine) {\n            let gap = change.text.length - 2, gapMarkers;\n            if (gap > 0 && first)\n                for (let i = 0; i < first.length; ++i)\n                    if (first[i].to == null)\n                        (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n            for (let i = 0; i < gap; ++i)\n                newMarkers.push(gapMarkers);\n            newMarkers.push(last);\n        }\n        return newMarkers;\n    }\n    function clearEmptySpans(spans) {\n        for (let i = 0; i < spans.length; ++i) {\n            let span = spans[i];\n            if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n                spans.splice(i--, 1);\n        }\n        if (!spans.length)\n            return null;\n        return spans;\n    }\n    function removeReadOnlyRanges(doc, from, to) {\n        let markers = null;\n        doc.iter(from.line, to.line + 1, line => {\n            if (line.markedSpans)\n                for (let i = 0; i < line.markedSpans.length; ++i) {\n                    let mark = line.markedSpans[i].marker;\n                    if (mark.readOnly && (!markers || misc.indexOf(markers, mark) == -1))\n                        (markers || (markers = [])).push(mark);\n                }\n        });\n        if (!markers)\n            return null;\n        let parts = [{\n                from: from,\n                to: to\n            }];\n        for (let i = 0; i < markers.length; ++i) {\n            let mk = markers[i], m = mk.find(0);\n            for (let j = 0; j < parts.length; ++j) {\n                let p = parts[j];\n                if (pos.cmp(p.to, m.from) < 0 || pos.cmp(p.from, m.to) > 0)\n                    continue;\n                let newParts = [\n                        j,\n                        1\n                    ], dfrom = pos.cmp(p.from, m.from), dto = pos.cmp(p.to, m.to);\n                if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n                    newParts.push({\n                        from: p.from,\n                        to: m.from\n                    });\n                if (dto > 0 || !mk.inclusiveRight && !dto)\n                    newParts.push({\n                        from: m.to,\n                        to: p.to\n                    });\n                parts.splice.apply(parts, newParts);\n                j += newParts.length - 3;\n            }\n        }\n        return parts;\n    }\n    function detachMarkedSpans(line) {\n        let spans = line.markedSpans;\n        if (!spans)\n            return;\n        for (let i = 0; i < spans.length; ++i)\n            spans[i].marker.detachLine(line);\n        line.markedSpans = null;\n    }\n    function attachMarkedSpans(line, spans) {\n        if (!spans)\n            return;\n        for (let i = 0; i < spans.length; ++i)\n            spans[i].marker.attachLine(line);\n        line.markedSpans = spans;\n    }\n    function extraLeft(marker) {\n        return marker.inclusiveLeft ? -1 : 0;\n    }\n    function extraRight(marker) {\n        return marker.inclusiveRight ? 1 : 0;\n    }\n    function compareCollapsedMarkers(a, b) {\n        let lenDiff = a.lines.length - b.lines.length;\n        if (lenDiff != 0)\n            return lenDiff;\n        let aPos = a.find(), bPos = b.find();\n        let fromCmp = pos.cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n        if (fromCmp)\n            return -fromCmp;\n        let toCmp = pos.cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n        if (toCmp)\n            return toCmp;\n        return b.id - a.id;\n    }\n    function collapsedSpanAtSide(line, start) {\n        let sps = saw_special_spans.sawCollapsedSpans && line.markedSpans, found;\n        if (sps)\n            for (let sp, i = 0; i < sps.length; ++i) {\n                sp = sps[i];\n                if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n                    found = sp.marker;\n            }\n        return found;\n    }\n    function collapsedSpanAtStart(line) {\n        return collapsedSpanAtSide(line, true);\n    }\n    function collapsedSpanAtEnd(line) {\n        return collapsedSpanAtSide(line, false);\n    }\n    function collapsedSpanAround(line, ch) {\n        let sps = saw_special_spans.sawCollapsedSpans && line.markedSpans, found;\n        if (sps)\n            for (let i = 0; i < sps.length; ++i) {\n                let sp = sps[i];\n                if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n                    found = sp.marker;\n            }\n        return found;\n    }\n    function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n        let line = utils_line.getLine(doc, lineNo);\n        let sps = saw_special_spans.sawCollapsedSpans && line.markedSpans;\n        if (sps)\n            for (let i = 0; i < sps.length; ++i) {\n                let sp = sps[i];\n                if (!sp.marker.collapsed)\n                    continue;\n                let found = sp.marker.find(0);\n                let fromCmp = pos.cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n                let toCmp = pos.cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n                if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0)\n                    continue;\n                if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? pos.cmp(found.to, from) >= 0 : pos.cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? pos.cmp(found.from, to) <= 0 : pos.cmp(found.from, to) < 0))\n                    return true;\n            }\n    }\n    function visualLine(line) {\n        let merged;\n        while (merged = collapsedSpanAtStart(line))\n            line = merged.find(-1, true).line;\n        return line;\n    }\n    function visualLineEnd(line) {\n        let merged;\n        while (merged = collapsedSpanAtEnd(line))\n            line = merged.find(1, true).line;\n        return line;\n    }\n    function visualLineContinued(line) {\n        let merged, lines;\n        while (merged = collapsedSpanAtEnd(line)) {\n            line = merged.find(1, true).line;\n            (lines || (lines = [])).push(line);\n        }\n        return lines;\n    }\n    function visualLineNo(doc, lineN) {\n        let line = utils_line.getLine(doc, lineN), vis = visualLine(line);\n        if (line == vis)\n            return lineN;\n        return utils_line.lineNo(vis);\n    }\n    function visualLineEndNo(doc, lineN) {\n        if (lineN > doc.lastLine())\n            return lineN;\n        let line = utils_line.getLine(doc, lineN), merged;\n        if (!lineIsHidden(doc, line))\n            return lineN;\n        while (merged = collapsedSpanAtEnd(line))\n            line = merged.find(1, true).line;\n        return utils_line.lineNo(line) + 1;\n    }\n    function lineIsHidden(doc, line) {\n        let sps = saw_special_spans.sawCollapsedSpans && line.markedSpans;\n        if (sps)\n            for (let sp, i = 0; i < sps.length; ++i) {\n                sp = sps[i];\n                if (!sp.marker.collapsed)\n                    continue;\n                if (sp.from == null)\n                    return true;\n                if (sp.marker.widgetNode)\n                    continue;\n                if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n                    return true;\n            }\n    }\n    function lineIsHiddenInner(doc, line, span) {\n        if (span.to == null) {\n            let end = span.marker.find(1, true);\n            return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n        }\n        if (span.marker.inclusiveRight && span.to == line.text.length)\n            return true;\n        for (let sp, i = 0; i < line.markedSpans.length; ++i) {\n            sp = line.markedSpans[i];\n            if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))\n                return true;\n        }\n    }\n    function heightAtLine(lineObj) {\n        lineObj = visualLine(lineObj);\n        let h = 0, chunk = lineObj.parent;\n        for (let i = 0; i < chunk.lines.length; ++i) {\n            let line = chunk.lines[i];\n            if (line == lineObj)\n                break;\n            else\n                h += line.height;\n        }\n        for (let p = chunk.parent; p; chunk = p, p = chunk.parent) {\n            for (let i = 0; i < p.children.length; ++i) {\n                let cur = p.children[i];\n                if (cur == chunk)\n                    break;\n                else\n                    h += cur.height;\n            }\n        }\n        return h;\n    }\n    function lineLength(line) {\n        if (line.height == 0)\n            return 0;\n        let len = line.text.length, merged, cur = line;\n        while (merged = collapsedSpanAtStart(cur)) {\n            let found = merged.find(0, true);\n            cur = found.from.line;\n            len += found.from.ch - found.to.ch;\n        }\n        cur = line;\n        while (merged = collapsedSpanAtEnd(cur)) {\n            let found = merged.find(0, true);\n            len -= cur.text.length - found.from.ch;\n            cur = found.to.line;\n            len += cur.text.length - found.to.ch;\n        }\n        return len;\n    }\n    function findMaxLine(cm) {\n        let d = cm.display, doc = cm.doc;\n        d.maxLine = utils_line.getLine(doc, doc.first);\n        d.maxLineLength = lineLength(d.maxLine);\n        d.maxLineChanged = true;\n        doc.iter(line => {\n            let len = lineLength(line);\n            if (len > d.maxLineLength) {\n                d.maxLineLength = len;\n                d.maxLine = line;\n            }\n        });\n    }\n    return {\n        MarkedSpan: MarkedSpan,\n        getMarkedSpanFor: getMarkedSpanFor,\n        removeMarkedSpan: removeMarkedSpan,\n        addMarkedSpan: addMarkedSpan,\n        stretchSpansOverChange: stretchSpansOverChange,\n        removeReadOnlyRanges: removeReadOnlyRanges,\n        detachMarkedSpans: detachMarkedSpans,\n        attachMarkedSpans: attachMarkedSpans,\n        compareCollapsedMarkers: compareCollapsedMarkers,\n        collapsedSpanAtStart: collapsedSpanAtStart,\n        collapsedSpanAtEnd: collapsedSpanAtEnd,\n        collapsedSpanAround: collapsedSpanAround,\n        conflictingCollapsedRange: conflictingCollapsedRange,\n        visualLine: visualLine,\n        visualLineEnd: visualLineEnd,\n        visualLineContinued: visualLineContinued,\n        visualLineNo: visualLineNo,\n        visualLineEndNo: visualLineEndNo,\n        lineIsHidden: lineIsHidden,\n        heightAtLine: heightAtLine,\n        lineLength: lineLength,\n        findMaxLine: findMaxLine\n    };\n});"]}