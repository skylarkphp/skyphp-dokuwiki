{"version":3,"sources":["model/Doc.js"],"names":["define","m_operations","m_line_data","m_pos","m_spans","m_utils_line","m_dom","m_feature_detection","m_misc","m_scrolling","m_changes","change_measurement","chunk","document_data","m_history","line_widget","mark_text","m_selection","selection_updates","nextDocId","Doc","text","mode","firstLine","lineSep","direction","this","BranchChunk","call","LeafChunk","Line","first","scrollTop","scrollLeft","cantEdit","cleanGeneration","modeFrontier","highlightFrontier","start","Pos","sel","simpleSelection","history","History","id","modeOption","extend","splitLines","updateDoc","from","to","setSelection","sel_dontScroll","prototype","createObj","constructor","iter","op","iterN","size","insert","at","lines","height","i","length","insertInner","remove","n","removeInner","getValue","getLines","join","lineSeparator","setValue","docMethodOp","code","top","last","makeChange","getLine","origin","full","cm","scrollToCoords","replaceRange","clipPos","getRange","getBetween","line","l","getLineHandle","isLine","getLineNumber","lineNo","getLineHandleVisualStart","visualLine","lineCount","lastLine","pos","getCursor","range","primary","head","anchor","listSelections","ranges","somethingSelected","setCursor","ch","options","setSimpleSelection","extendSelection","other","extendSelections","heads","clipPosArray","extendSelectionsBy","f","map","setSelections","out","Range","Math","min","primIndex","normalizeSelection","addSelection","slice","push","getSelection","concat","getSelections","parts","replaceSelection","collapse","dup","replaceSelections","changes","newSel","computeReplacedSel","setSelectionReplaceHistory","ensureCursorVisible","undo","makeChangeFromHistory","redo","undoSelection","redoSelection","setExtending","val","getExtending","historySize","hist","done","undone","clearHistory","maxGeneration","markClean","changeGeneration","forceSplit","lastOp","lastSelOp","lastOrigin","generation","isClean","gen","getHistory","copyHistoryArray","setHistory","histData","setGutterMarker","gutterID","value","changeLine","markers","gutterMarkers","isEmpty","clearGutter","lineInfo","handle","textClass","bgClass","wrapClass","widgets","addLineClass","where","cls","prop","classTest","test","removeLineClass","cur","found","match","end","index","addLineWidget","node","removeLineWidget","widget","clear","markText","type","setBookmark","realOpts","replacedWith","nodeType","insertLeft","clearWhenEmpty","shared","handleMouseEvents","findMarksAt","spans","markedSpans","span","marker","parent","findMarks","filter","getAllMarks","sps","posFromIndex","off","sepSize","sz","indexFromPos","coords","copy","copyHistory","doc","undoDepth","linkedDoc","sharedHist","linked","isParent","copySharedMarkers","findSharedMarkers","unlinkDoc","splice","detachSharedMarkers","splitIds","linkedDocs","iterLinkedDocs","getMode","getEditor","str","split","splitLinesAuto","setDirection","dir","order","directionChanged","eachLine"],"mappings":"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","file":"../../model/Doc.js","sourcesContent":["define([\n    '../display/operations',\n    '../line/line_data',\n    '../line/pos',\n    '../line/spans',\n    '../line/utils_line',\n    '../util/dom',\n    '../util/feature_detection',\n    '../util/misc',\n    '../display/scrolling',\n    './changes',\n    './change_measurement',\n    './chunk',\n    './document_data',\n    './history',\n    './line_widget',\n    './mark_text',\n    './selection',\n    './selection_updates'\n], function (m_operations, m_line_data, m_pos, m_spans, m_utils_line, m_dom, m_feature_detection, m_misc, m_scrolling, m_changes, change_measurement, chunk, document_data, m_history, line_widget, mark_text, m_selection, selection_updates) {\n    'use strict';\n    let nextDocId = 0;\n    let Doc = function (text, mode, firstLine, lineSep, direction) {\n        if (!(this instanceof Doc))\n            return new Doc(text, mode, firstLine, lineSep, direction);\n        if (firstLine == null)\n            firstLine = 0;\n        chunk.BranchChunk.call(this, [new chunk.LeafChunk([new m_line_data.Line('', null)])]);\n        this.first = firstLine;\n        this.scrollTop = this.scrollLeft = 0;\n        this.cantEdit = false;\n        this.cleanGeneration = 1;\n        this.modeFrontier = this.highlightFrontier = firstLine;\n        let start = m_pos.Pos(firstLine, 0);\n        this.sel = m_selection.simpleSelection(start);\n        this.history = new m_history.History(null);\n        this.id = ++nextDocId;\n        this.modeOption = mode;\n        this.lineSep = lineSep;\n        this.direction = direction == 'rtl' ? 'rtl' : 'ltr';\n        this.extend = false;\n        if (typeof text == 'string')\n            text = this.splitLines(text);\n        document_data.updateDoc(this, {\n            from: start,\n            to: start,\n            text: text\n        });\n        selection_updates.setSelection(this, m_selection.simpleSelection(start), m_misc.sel_dontScroll);\n    };\n    Doc.prototype = m_misc.createObj(chunk.BranchChunk.prototype, {\n        constructor: Doc,\n        iter: function (from, to, op) {\n            if (op)\n                this.iterN(from - this.first, to - from, op);\n            else\n                this.iterN(this.first, this.first + this.size, from);\n        },\n        insert: function (at, lines) {\n            let height = 0;\n            for (let i = 0; i < lines.length; ++i)\n                height += lines[i].height;\n            this.insertInner(at - this.first, lines, height);\n        },\n        remove: function (at, n) {\n            this.removeInner(at - this.first, n);\n        },\n        getValue: function (lineSep) {\n            let lines = m_utils_line.getLines(this, this.first, this.first + this.size);\n            if (lineSep === false)\n                return lines;\n            return lines.join(lineSep || this.lineSeparator());\n        },\n        setValue: m_operations.docMethodOp(function (code) {\n            let top = m_pos.Pos(this.first, 0), last = this.first + this.size - 1;\n            m_changes.makeChange(this, {\n                from: top,\n                to: m_pos.Pos(last, m_utils_line.getLine(this, last).text.length),\n                text: this.splitLines(code),\n                origin: 'setValue',\n                full: true\n            }, true);\n            if (this.cm)\n                m_scrolling.scrollToCoords(this.cm, 0, 0);\n            selection_updates.setSelection(this, m_selection.simpleSelection(top), m_misc.sel_dontScroll);\n        }),\n        replaceRange: function (code, from, to, origin) {\n            from = m_pos.clipPos(this, from);\n            to = to ? m_pos.clipPos(this, to) : from;\n            m_changes.replaceRange(this, code, from, to, origin);\n        },\n        getRange: function (from, to, lineSep) {\n            let lines = m_utils_line.getBetween(this, m_pos.clipPos(this, from), m_pos.clipPos(this, to));\n            if (lineSep === false)\n                return lines;\n            return lines.join(lineSep || this.lineSeparator());\n        },\n        getLine: function (line) {\n            let l = this.getLineHandle(line);\n            return l && l.text;\n        },\n        getLineHandle: function (line) {\n            if (m_utils_line.isLine(this, line))\n                return m_utils_line.getLine(this, line);\n        },\n        getLineNumber: function (line) {\n            return m_utils_line.lineNo(line);\n        },\n        getLineHandleVisualStart: function (line) {\n            if (typeof line == 'number')\n                line = m_utils_line.getLine(this, line);\n            return m_spans.visualLine(line);\n        },\n        lineCount: function () {\n            return this.size;\n        },\n        firstLine: function () {\n            return this.first;\n        },\n        lastLine: function () {\n            return this.first + this.size - 1;\n        },\n        clipPos: function (pos) {\n            return m_pos.clipPos(this, pos);\n        },\n        getCursor: function (start) {\n            let range = this.sel.primary(), pos;\n            if (start == null || start == 'head')\n                pos = range.head;\n            else if (start == 'anchor')\n                pos = range.anchor;\n            else if (start == 'end' || start == 'to' || start === false)\n                pos = range.to();\n            else\n                pos = range.from();\n            return pos;\n        },\n        listSelections: function () {\n            return this.sel.ranges;\n        },\n        somethingSelected: function () {\n            return this.sel.somethingSelected();\n        },\n        setCursor: m_operations.docMethodOp(function (line, ch, options) {\n            selection_updates.setSimpleSelection(this, m_pos.clipPos(this, typeof line == 'number' ? m_pos.Pos(line, ch || 0) : line), null, options);\n        }),\n        setSelection: m_operations.docMethodOp(function (anchor, head, options) {\n            selection_updates.setSimpleSelection(this, m_pos.clipPos(this, anchor), m_pos.clipPos(this, head || anchor), options);\n        }),\n        extendSelection: m_operations.docMethodOp(function (head, other, options) {\n            selection_updates.extendSelection(this, m_pos.clipPos(this, head), other && m_pos.clipPos(this, other), options);\n        }),\n        extendSelections: m_operations.docMethodOp(function (heads, options) {\n            selection_updates.extendSelections(this, m_pos.clipPosArray(this, heads), options);\n        }),\n        extendSelectionsBy: m_operations.docMethodOp(function (f, options) {\n            let heads = m_misc.map(this.sel.ranges, f);\n            selection_updates.extendSelections(this, m_pos.clipPosArray(this, heads), options);\n        }),\n        setSelections: m_operations.docMethodOp(function (ranges, primary, options) {\n            if (!ranges.length)\n                return;\n            let out = [];\n            for (let i = 0; i < ranges.length; i++)\n                out[i] = new m_selection.Range(m_pos.clipPos(this, ranges[i].anchor), m_pos.clipPos(this, ranges[i].head));\n            if (primary == null)\n                primary = Math.min(ranges.length - 1, this.sel.primIndex);\n            selection_updates.setSelection(this, m_selection.normalizeSelection(this.cm, out, primary), options);\n        }),\n        addSelection: m_operations.docMethodOp(function (anchor, head, options) {\n            let ranges = this.sel.ranges.slice(0);\n            ranges.push(new m_selection.Range(m_pos.clipPos(this, anchor), m_pos.clipPos(this, head || anchor)));\n            selection_updates.setSelection(this, m_selection.normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n        }),\n        getSelection: function (lineSep) {\n            let ranges = this.sel.ranges, lines;\n            for (let i = 0; i < ranges.length; i++) {\n                let sel = m_utils_line.getBetween(this, ranges[i].from(), ranges[i].to());\n                lines = lines ? lines.concat(sel) : sel;\n            }\n            if (lineSep === false)\n                return lines;\n            else\n                return lines.join(lineSep || this.lineSeparator());\n        },\n        getSelections: function (lineSep) {\n            let parts = [], ranges = this.sel.ranges;\n            for (let i = 0; i < ranges.length; i++) {\n                let sel = m_utils_line.getBetween(this, ranges[i].from(), ranges[i].to());\n                if (lineSep !== false)\n                    sel = sel.join(lineSep || this.lineSeparator());\n                parts[i] = sel;\n            }\n            return parts;\n        },\n        replaceSelection: function (code, collapse, origin) {\n            let dup = [];\n            for (let i = 0; i < this.sel.ranges.length; i++)\n                dup[i] = code;\n            this.replaceSelections(dup, collapse, origin || '+input');\n        },\n        replaceSelections: m_operations.docMethodOp(function (code, collapse, origin) {\n            let changes = [], sel = this.sel;\n            for (let i = 0; i < sel.ranges.length; i++) {\n                let range = sel.ranges[i];\n                changes[i] = {\n                    from: range.from(),\n                    to: range.to(),\n                    text: this.splitLines(code[i]),\n                    origin: origin\n                };\n            }\n            let newSel = collapse && collapse != 'end' && change_measurement.computeReplacedSel(this, changes, collapse);\n            for (let i = changes.length - 1; i >= 0; i--)\n                m_changes.makeChange(this, changes[i]);\n            if (newSel)\n                selection_updates.setSelectionReplaceHistory(this, newSel);\n            else if (this.cm)\n                m_scrolling.ensureCursorVisible(this.cm);\n        }),\n        undo: m_operations.docMethodOp(function () {\n            m_changes.makeChangeFromHistory(this, 'undo');\n        }),\n        redo: m_operations.docMethodOp(function () {\n            m_changes.makeChangeFromHistory(this, 'redo');\n        }),\n        undoSelection: m_operations.docMethodOp(function () {\n            m_changes.makeChangeFromHistory(this, 'undo', true);\n        }),\n        redoSelection: m_operations.docMethodOp(function () {\n            m_changes.makeChangeFromHistory(this, 'redo', true);\n        }),\n        setExtending: function (val) {\n            this.extend = val;\n        },\n        getExtending: function () {\n            return this.extend;\n        },\n        historySize: function () {\n            let hist = this.history, done = 0, undone = 0;\n            for (let i = 0; i < hist.done.length; i++)\n                if (!hist.done[i].ranges)\n                    ++done;\n            for (let i = 0; i < hist.undone.length; i++)\n                if (!hist.undone[i].ranges)\n                    ++undone;\n            return {\n                undo: done,\n                redo: undone\n            };\n        },\n        clearHistory: function () {\n            this.history = new m_history.History(this.history.maxGeneration);\n        },\n        markClean: function () {\n            this.cleanGeneration = this.changeGeneration(true);\n        },\n        changeGeneration: function (forceSplit) {\n            if (forceSplit)\n                this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n            return this.history.generation;\n        },\n        isClean: function (gen) {\n            return this.history.generation == (gen || this.cleanGeneration);\n        },\n        getHistory: function () {\n            return {\n                done: m_history.copyHistoryArray(this.history.done),\n                undone: m_history.copyHistoryArray(this.history.undone)\n            };\n        },\n        setHistory: function (histData) {\n            let hist = this.history = new m_history.History(this.history.maxGeneration);\n            hist.done = m_history.copyHistoryArray(histData.done.slice(0), null, true);\n            hist.undone = m_history.copyHistoryArray(histData.undone.slice(0), null, true);\n        },\n        setGutterMarker: m_operations.docMethodOp(function (line, gutterID, value) {\n            return m_changes.changeLine(this, line, 'gutter', line => {\n                let markers = line.gutterMarkers || (line.gutterMarkers = {});\n                markers[gutterID] = value;\n                if (!value && m_misc.isEmpty(markers))\n                    line.gutterMarkers = null;\n                return true;\n            });\n        }),\n        clearGutter: m_operations.docMethodOp(function (gutterID) {\n            this.iter(line => {\n                if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n                    m_changes.changeLine(this, line, 'gutter', () => {\n                        line.gutterMarkers[gutterID] = null;\n                        if (m_misc.isEmpty(line.gutterMarkers))\n                            line.gutterMarkers = null;\n                        return true;\n                    });\n                }\n            });\n        }),\n        lineInfo: function (line) {\n            let n;\n            if (typeof line == 'number') {\n                if (!m_utils_line.isLine(this, line))\n                    return null;\n                n = line;\n                line = m_utils_line.getLine(this, line);\n                if (!line)\n                    return null;\n            } else {\n                n = m_utils_line.lineNo(line);\n                if (n == null)\n                    return null;\n            }\n            return {\n                line: n,\n                handle: line,\n                text: line.text,\n                gutterMarkers: line.gutterMarkers,\n                textClass: line.textClass,\n                bgClass: line.bgClass,\n                wrapClass: line.wrapClass,\n                widgets: line.widgets\n            };\n        },\n        addLineClass: m_operations.docMethodOp(function (handle, where, cls) {\n            return m_changes.changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', line => {\n                let prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';\n                if (!line[prop])\n                    line[prop] = cls;\n                else if (m_dom.classTest(cls).test(line[prop]))\n                    return false;\n                else\n                    line[prop] += ' ' + cls;\n                return true;\n            });\n        }),\n        removeLineClass: m_operations.docMethodOp(function (handle, where, cls) {\n            return m_changes.changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', line => {\n                let prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';\n                let cur = line[prop];\n                if (!cur)\n                    return false;\n                else if (cls == null)\n                    line[prop] = null;\n                else {\n                    let found = cur.match(m_dom.classTest(cls));\n                    if (!found)\n                        return false;\n                    let end = found.index + found[0].length;\n                    line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? '' : ' ') + cur.slice(end) || null;\n                }\n                return true;\n            });\n        }),\n        addLineWidget: m_operations.docMethodOp(function (handle, node, options) {\n            return line_widget.addLineWidget(this, handle, node, options);\n        }),\n        removeLineWidget: function (widget) {\n            widget.clear();\n        },\n        markText: function (from, to, options) {\n            return mark_text.markText(this, m_pos.clipPos(this, from), m_pos.clipPos(this, to), options, options && options.type || 'range');\n        },\n        setBookmark: function (pos, options) {\n            let realOpts = {\n                replacedWith: options && (options.nodeType == null ? options.widget : options),\n                insertLeft: options && options.insertLeft,\n                clearWhenEmpty: false,\n                shared: options && options.shared,\n                handleMouseEvents: options && options.handleMouseEvents\n            };\n            pos = m_pos.clipPos(this, pos);\n            return mark_text.markText(this, pos, pos, realOpts, 'bookmark');\n        },\n        findMarksAt: function (pos) {\n            pos = m_pos.clipPos(this, pos);\n            let markers = [], spans = m_utils_line.getLine(this, pos.line).markedSpans;\n            if (spans)\n                for (let i = 0; i < spans.length; ++i) {\n                    let span = spans[i];\n                    if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))\n                        markers.push(span.marker.parent || span.marker);\n                }\n            return markers;\n        },\n        findMarks: function (from, to, filter) {\n            from = m_pos.clipPos(this, from);\n            to = m_pos.clipPos(this, to);\n            let found = [], lineNo = from.line;\n            this.iter(from.line, to.line + 1, line => {\n                let spans = line.markedSpans;\n                if (spans)\n                    for (let i = 0; i < spans.length; i++) {\n                        let span = spans[i];\n                        if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker)))\n                            found.push(span.marker.parent || span.marker);\n                    }\n                ++lineNo;\n            });\n            return found;\n        },\n        getAllMarks: function () {\n            let markers = [];\n            this.iter(line => {\n                let sps = line.markedSpans;\n                if (sps)\n                    for (let i = 0; i < sps.length; ++i)\n                        if (sps[i].from != null)\n                            markers.push(sps[i].marker);\n            });\n            return markers;\n        },\n        posFromIndex: function (off) {\n            let ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n            this.iter(line => {\n                let sz = line.text.length + sepSize;\n                if (sz > off) {\n                    ch = off;\n                    return true;\n                }\n                off -= sz;\n                ++lineNo;\n            });\n            return m_pos.clipPos(this, m_pos.Pos(lineNo, ch));\n        },\n        indexFromPos: function (coords) {\n            coords = m_pos.clipPos(this, coords);\n            let index = coords.ch;\n            if (coords.line < this.first || coords.ch < 0)\n                return 0;\n            let sepSize = this.lineSeparator().length;\n            this.iter(this.first, coords.line, line => {\n                index += line.text.length + sepSize;\n            });\n            return index;\n        },\n        copy: function (copyHistory) {\n            let doc = new Doc(m_utils_line.getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);\n            doc.scrollTop = this.scrollTop;\n            doc.scrollLeft = this.scrollLeft;\n            doc.sel = this.sel;\n            doc.extend = false;\n            if (copyHistory) {\n                doc.history.undoDepth = this.history.undoDepth;\n                doc.setHistory(this.getHistory());\n            }\n            return doc;\n        },\n        linkedDoc: function (options) {\n            if (!options)\n                options = {};\n            let from = this.first, to = this.first + this.size;\n            if (options.from != null && options.from > from)\n                from = options.from;\n            if (options.to != null && options.to < to)\n                to = options.to;\n            let copy = new Doc(m_utils_line.getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n            if (options.sharedHist)\n                copy.history = this.history;\n            (this.linked || (this.linked = [])).push({\n                doc: copy,\n                sharedHist: options.sharedHist\n            });\n            copy.linked = [{\n                    doc: this,\n                    isParent: true,\n                    sharedHist: options.sharedHist\n                }];\n            line_widget.copySharedMarkers(copy, line_widget.findSharedMarkers(this));\n            return copy;\n        },\n        unlinkDoc: function (other) {\n            //if (other instanceof CodeMirror) // modified by lwf\n            if (other.doc)\n                other = other.doc;\n            if (this.linked)\n                for (let i = 0; i < this.linked.length; ++i) {\n                    let link = this.linked[i];\n                    if (link.doc != other)\n                        continue;\n                    this.linked.splice(i, 1);\n                    other.unlinkDoc(this);\n                    line_widget.detachSharedMarkers(line_widget.findSharedMarkers(this));\n                    break;\n                }\n            if (other.history == this.history) {\n                let splitIds = [other.id];\n                document_data.linkedDocs(other, doc => splitIds.push(doc.id), true);\n                other.history = new m_history.History(null);\n                other.history.done = m_history.copyHistoryArray(this.history.done, splitIds);\n                other.history.undone = m_history.copyHistoryArray(this.history.undone, splitIds);\n            }\n        },\n        iterLinkedDocs: function (f) {\n            document_data.linkedDocs(this, f);\n        },\n        getMode: function () {\n            return this.mode;\n        },\n        getEditor: function () {\n            return this.cm;\n        },\n        splitLines: function (str) {\n            if (this.lineSep)\n                return str.split(this.lineSep);\n            return m_feature_detection.splitLinesAuto(str);\n        },\n        lineSeparator: function () {\n            return this.lineSep || '\\n';\n        },\n        setDirection: m_operations.docMethodOp(function (dir) {\n            if (dir != 'rtl')\n                dir = 'ltr';\n            if (dir == this.direction)\n                return;\n            this.direction = dir;\n            this.iter(line => line.order = null);\n            if (this.cm)\n                document_data.directionChanged(this.cm);\n        })\n    });\n    Doc.prototype.eachLine = Doc.prototype.iter;\n    return Doc;\n});"]}