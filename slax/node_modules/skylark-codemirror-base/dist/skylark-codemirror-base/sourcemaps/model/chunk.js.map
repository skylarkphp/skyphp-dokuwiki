{"version":3,"sources":["model/chunk.js"],"names":["define","m_line_data","b","c","LeafChunk","lines","this","parent","height","i","length","BranchChunk","children","size","ch","chunkSize","prototype","[object Object]","at","n","e","line","cleanUpLine","signalLater","splice","push","apply","slice","concat","op","child","sz","rm","Math","min","oldHeight","removeInner","collapse","insertInner","remaining","pos","leaf","maybeSpill","me","sibling","myIndex","indexOf","copy","used","iterN"],"mappings":"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","file":"../../model/chunk.js","sourcesContent":["define([\n    '../line/line_data',\n    '../util/misc',\n    '../util/operation_group'\n], function (m_line_data, b, c) {\n    'use strict';\n    function LeafChunk(lines) {\n        this.lines = lines;\n        this.parent = null;\n        let height = 0;\n        for (let i = 0; i < lines.length; ++i) {\n            lines[i].parent = this;\n            height += lines[i].height;\n        }\n        this.height = height;\n    }\n    LeafChunk.prototype = {\n        chunkSize() {\n            return this.lines.length;\n        },\n        removeInner(at, n) {\n            for (let i = at, e = at + n; i < e; ++i) {\n                let line = this.lines[i];\n                this.height -= line.height;\n                m_line_data.cleanUpLine(line);\n                c.signalLater(line, 'delete');\n            }\n            this.lines.splice(at, n);\n        },\n        collapse(lines) {\n            lines.push.apply(lines, this.lines);\n        },\n        insertInner(at, lines, height) {\n            this.height += height;\n            this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n            for (let i = 0; i < lines.length; ++i)\n                lines[i].parent = this;\n        },\n        iterN(at, n, op) {\n            for (let e = at + n; at < e; ++at)\n                if (op(this.lines[at]))\n                    return true;\n        }\n    };\n    function BranchChunk(children) {\n        this.children = children;\n        let size = 0, height = 0;\n        for (let i = 0; i < children.length; ++i) {\n            let ch = children[i];\n            size += ch.chunkSize();\n            height += ch.height;\n            ch.parent = this;\n        }\n        this.size = size;\n        this.height = height;\n        this.parent = null;\n    }\n    BranchChunk.prototype = {\n        chunkSize() {\n            return this.size;\n        },\n        removeInner(at, n) {\n            this.size -= n;\n            for (let i = 0; i < this.children.length; ++i) {\n                let child = this.children[i], sz = child.chunkSize();\n                if (at < sz) {\n                    let rm = Math.min(n, sz - at), oldHeight = child.height;\n                    child.removeInner(at, rm);\n                    this.height -= oldHeight - child.height;\n                    if (sz == rm) {\n                        this.children.splice(i--, 1);\n                        child.parent = null;\n                    }\n                    if ((n -= rm) == 0)\n                        break;\n                    at = 0;\n                } else\n                    at -= sz;\n            }\n            if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n                let lines = [];\n                this.collapse(lines);\n                this.children = [new LeafChunk(lines)];\n                this.children[0].parent = this;\n            }\n        },\n        collapse(lines) {\n            for (let i = 0; i < this.children.length; ++i)\n                this.children[i].collapse(lines);\n        },\n        insertInner(at, lines, height) {\n            this.size += lines.length;\n            this.height += height;\n            for (let i = 0; i < this.children.length; ++i) {\n                let child = this.children[i], sz = child.chunkSize();\n                if (at <= sz) {\n                    child.insertInner(at, lines, height);\n                    if (child.lines && child.lines.length > 50) {\n                        let remaining = child.lines.length % 25 + 25;\n                        for (let pos = remaining; pos < child.lines.length;) {\n                            let leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n                            child.height -= leaf.height;\n                            this.children.splice(++i, 0, leaf);\n                            leaf.parent = this;\n                        }\n                        child.lines = child.lines.slice(0, remaining);\n                        this.maybeSpill();\n                    }\n                    break;\n                }\n                at -= sz;\n            }\n        },\n        maybeSpill() {\n            if (this.children.length <= 10)\n                return;\n            let me = this;\n            do {\n                let spilled = me.children.splice(me.children.length - 5, 5);\n                let sibling = new BranchChunk(spilled);\n                if (!me.parent) {\n                    let copy = new BranchChunk(me.children);\n                    copy.parent = me;\n                    me.children = [\n                        copy,\n                        sibling\n                    ];\n                    me = copy;\n                } else {\n                    me.size -= sibling.size;\n                    me.height -= sibling.height;\n                    let myIndex = b.indexOf(me.parent.children, me);\n                    me.parent.children.splice(myIndex + 1, 0, sibling);\n                }\n                sibling.parent = me.parent;\n            } while (me.children.length > 10);\n            me.parent.maybeSpill();\n        },\n        iterN(at, n, op) {\n            for (let i = 0; i < this.children.length; ++i) {\n                let child = this.children[i], sz = child.chunkSize();\n                if (at < sz) {\n                    let used = Math.min(n, sz - at);\n                    if (child.iterN(at, used, op))\n                        return true;\n                    if ((n -= used) == 0)\n                        break;\n                    at = 0;\n                } else\n                    at -= sz;\n            }\n        }\n    };\n    return {\n        LeafChunk: LeafChunk,\n        BranchChunk: BranchChunk\n    };\n});"]}