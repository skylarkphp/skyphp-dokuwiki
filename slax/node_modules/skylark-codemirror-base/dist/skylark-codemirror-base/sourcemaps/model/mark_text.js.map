{"version":3,"sources":["model/mark_text.js"],"names":["define","dom","m_event","operations","m_pos","utils_line","position_measurement","saw_special_spans","spans","misc","operation_group","widgets","view_tracking","document_data","m_history","selection_updates","nextMarkerId","TextMarker","[object Object]","doc","type","this","lines","id","explicitlyCleared","cm","withOp","curOp","startOperation","hasHandler","found","find","signalLater","from","to","min","max","i","length","line","span","getMarkedSpanFor","markedSpans","collapsed","regLineChange","lineNo","removeMarkedSpan","lineIsHidden","updateLineHeight","textHeight","display","options","lineWrapping","visual","visualLine","len","lineLength","maxLineLength","maxLine","maxLineChanged","regChange","atomic","cantEdit","reCheckSelection","endOperation","parent","clear","side","lineObj","Pos","pos","widget","runInOp","lineN","view","findViewForLine","clearLineMeasurementCacheFor","selectionChanged","forceUpdate","updateMaxLine","height","oldHeight","dHeight","widgetHeight","op","maybeHiddenMarkers","indexOf","maybeUnhiddenMarkers","push","splice","markText","shared","copyObj","markers","primary","widgetNode","linkedDocs","cloneNode","clipPos","linked","isParent","lst","SharedTextMarker","markTextShared","operation","marker","diff","cmp","clearWhenEmpty","replacedWith","eltP","handleMouseEvents","setAttribute","insertLeft","conflictingCollapsedRange","Error","seeCollapsedSpans","addToHistory","addChangeToHistory","origin","sel","NaN","curLine","iter","addMarkedSpan","MarkedSpan","ch","clearOnEnter","on","readOnly","seeReadOnlySpans","history","done","undone","clearHistory","className","startStyle","endStyle","css","attributes","title","eventMixin","findSharedMarkers","findMarks","first","lastLine","m","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","d","j","subMarker"],"mappings":"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","file":"../../model/mark_text.js","sourcesContent":["define([\n    '../util/dom',\n    '../util/event',\n    '../display/operations',\n    '../line/pos',\n    '../line/utils_line',\n    '../measurement/position_measurement',\n    '../line/saw_special_spans',\n    '../line/spans',\n    '../util/misc',\n    '../util/operation_group',\n    '../measurement/widgets',\n    '../display/view_tracking',\n    './document_data',\n    './history',\n    './selection_updates'\n], function (dom, m_event, operations, m_pos, utils_line, position_measurement, saw_special_spans, spans, misc, operation_group, widgets, view_tracking, document_data, m_history, selection_updates) {\n    'use strict';\n    let nextMarkerId = 0;\n    class TextMarker {\n        constructor(doc, type) {\n            this.lines = [];\n            this.type = type;\n            this.doc = doc;\n            this.id = ++nextMarkerId;\n        }\n        clear() {\n            if (this.explicitlyCleared)\n                return;\n            let cm = this.doc.cm, withOp = cm && !cm.curOp;\n            if (withOp)\n                operations.startOperation(cm);\n            if (m_event.hasHandler(this, 'clear')) {\n                let found = this.find();\n                if (found)\n                    operation_group.signalLater(this, 'clear', found.from, found.to);\n            }\n            let min = null, max = null;\n            for (let i = 0; i < this.lines.length; ++i) {\n                let line = this.lines[i];\n                let span = spans.getMarkedSpanFor(line.markedSpans, this);\n                if (cm && !this.collapsed)\n                    view_tracking.regLineChange(cm, utils_line.lineNo(line), 'text');\n                else if (cm) {\n                    if (span.to != null)\n                        max = utils_line.lineNo(line);\n                    if (span.from != null)\n                        min = utils_line.lineNo(line);\n                }\n                line.markedSpans = spans.removeMarkedSpan(line.markedSpans, span);\n                if (span.from == null && this.collapsed && !spans.lineIsHidden(this.doc, line) && cm)\n                    utils_line.updateLineHeight(line, position_measurement.textHeight(cm.display));\n            }\n            if (cm && this.collapsed && !cm.options.lineWrapping)\n                for (let i = 0; i < this.lines.length; ++i) {\n                    let visual = spans.visualLine(this.lines[i]), len = spans.lineLength(visual);\n                    if (len > cm.display.maxLineLength) {\n                        cm.display.maxLine = visual;\n                        cm.display.maxLineLength = len;\n                        cm.display.maxLineChanged = true;\n                    }\n                }\n            if (min != null && cm && this.collapsed)\n                view_tracking.regChange(cm, min, max + 1);\n            this.lines.length = 0;\n            this.explicitlyCleared = true;\n            if (this.atomic && this.doc.cantEdit) {\n                this.doc.cantEdit = false;\n                if (cm)\n                    selection_updates.reCheckSelection(cm.doc);\n            }\n            if (cm)\n                operation_group.signalLater(cm, 'markerCleared', cm, this, min, max);\n            if (withOp)\n                operations.endOperation(cm);\n            if (this.parent)\n                this.parent.clear();\n        }\n        find(side, lineObj) {\n            if (side == null && this.type == 'bookmark')\n                side = 1;\n            let from, to;\n            for (let i = 0; i < this.lines.length; ++i) {\n                let line = this.lines[i];\n                let span = spans.getMarkedSpanFor(line.markedSpans, this);\n                if (span.from != null) {\n                    from = m_pos.Pos(lineObj ? line : utils_line.lineNo(line), span.from);\n                    if (side == -1)\n                        return from;\n                }\n                if (span.to != null) {\n                    to = m_pos.Pos(lineObj ? line : utils_line.lineNo(line), span.to);\n                    if (side == 1)\n                        return to;\n                }\n            }\n            return from && {\n                from: from,\n                to: to\n            };\n        }\n        changed() {\n            let pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n            if (!pos || !cm)\n                return;\n            operations.runInOp(cm, () => {\n                let line = pos.line, lineN = utils_line.lineNo(pos.line);\n                let view = position_measurement.findViewForLine(cm, lineN);\n                if (view) {\n                    position_measurement.clearLineMeasurementCacheFor(view);\n                    cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n                }\n                cm.curOp.updateMaxLine = true;\n                if (!spans.lineIsHidden(widget.doc, line) && widget.height != null) {\n                    let oldHeight = widget.height;\n                    widget.height = null;\n                    let dHeight = widgets.widgetHeight(widget) - oldHeight;\n                    if (dHeight)\n                        utils_line.updateLineHeight(line, line.height + dHeight);\n                }\n                operation_group.signalLater(cm, 'markerChanged', cm, this);\n            });\n        }\n        attachLine(line) {\n            if (!this.lines.length && this.doc.cm) {\n                let op = this.doc.cm.curOp;\n                if (!op.maybeHiddenMarkers || misc.indexOf(op.maybeHiddenMarkers, this) == -1)\n                    (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n            }\n            this.lines.push(line);\n        }\n        detachLine(line) {\n            this.lines.splice(misc.indexOf(this.lines, line), 1);\n            if (!this.lines.length && this.doc.cm) {\n                let op = this.doc.cm.curOp;\n                (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n            }\n        }\n    }\n    m_event.eventMixin(TextMarker);\n    function markText(doc, from, to, options, type) {\n        if (options && options.shared)\n            return markTextShared(doc, from, to, options, type);\n        if (doc.cm && !doc.cm.curOp)\n            return operations.operation(doc.cm, markText)(doc, from, to, options, type);\n        let marker = new TextMarker(doc, type), diff = m_pos.cmp(from, to);\n        if (options)\n            misc.copyObj(options, marker, false);\n        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n            return marker;\n        if (marker.replacedWith) {\n            marker.collapsed = true;\n            marker.widgetNode = dom.eltP('span', [marker.replacedWith], 'CodeMirror-widget');\n            if (!options.handleMouseEvents)\n                marker.widgetNode.setAttribute('cm-ignore-events', 'true');\n            if (options.insertLeft)\n                marker.widgetNode.insertLeft = true;\n        }\n        if (marker.collapsed) {\n            if (spans.conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && spans.conflictingCollapsedRange(doc, to.line, from, to, marker))\n                throw new Error('Inserting collapsed marker partially overlapping an existing one');\n            saw_special_spans.seeCollapsedSpans();\n        }\n        if (marker.addToHistory)\n            m_history.addChangeToHistory(doc, {\n                from: from,\n                to: to,\n                origin: 'markText'\n            }, doc.sel, NaN);\n        let curLine = from.line, cm = doc.cm, updateMaxLine;\n        doc.iter(curLine, to.line + 1, line => {\n            if (cm && marker.collapsed && !cm.options.lineWrapping && spans.visualLine(line) == cm.display.maxLine)\n                updateMaxLine = true;\n            if (marker.collapsed && curLine != from.line)\n                utils_line.updateLineHeight(line, 0);\n            spans.addMarkedSpan(line, new spans.MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));\n            ++curLine;\n        });\n        if (marker.collapsed)\n            doc.iter(from.line, to.line + 1, line => {\n                if (spans.lineIsHidden(doc, line))\n                    utils_line.updateLineHeight(line, 0);\n            });\n        if (marker.clearOnEnter)\n            m_event.on(marker, 'beforeCursorEnter', () => marker.clear());\n        if (marker.readOnly) {\n            saw_special_spans.seeReadOnlySpans();\n            if (doc.history.done.length || doc.history.undone.length)\n                doc.clearHistory();\n        }\n        if (marker.collapsed) {\n            marker.id = ++nextMarkerId;\n            marker.atomic = true;\n        }\n        if (cm) {\n            if (updateMaxLine)\n                cm.curOp.updateMaxLine = true;\n            if (marker.collapsed)\n                view_tracking.regChange(cm, from.line, to.line + 1);\n            else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title)\n                for (let i = from.line; i <= to.line; i++)\n                    view_tracking.regLineChange(cm, i, 'text');\n            if (marker.atomic)\n                selection_updates.reCheckSelection(cm.doc);\n            operation_group.signalLater(cm, 'markerAdded', cm, marker);\n        }\n        return marker;\n    }\n    class SharedTextMarker {\n        constructor(markers, primary) {\n            this.markers = markers;\n            this.primary = primary;\n            for (let i = 0; i < markers.length; ++i)\n                markers[i].parent = this;\n        }\n        clear() {\n            if (this.explicitlyCleared)\n                return;\n            this.explicitlyCleared = true;\n            for (let i = 0; i < this.markers.length; ++i)\n                this.markers[i].clear();\n            operation_group.signalLater(this, 'clear');\n        }\n        find(side, lineObj) {\n            return this.primary.find(side, lineObj);\n        }\n    }\n    m_event.eventMixin(SharedTextMarker);\n    function markTextShared(doc, from, to, options, type) {\n        options = misc.copyObj(options);\n        options.shared = false;\n        let markers = [markText(doc, from, to, options, type)], primary = markers[0];\n        let widget = options.widgetNode;\n        document_data.linkedDocs(doc, doc => {\n            if (widget)\n                options.widgetNode = widget.cloneNode(true);\n            markers.push(markText(doc, m_pos.clipPos(doc, from), m_pos.clipPos(doc, to), options, type));\n            for (let i = 0; i < doc.linked.length; ++i)\n                if (doc.linked[i].isParent)\n                    return;\n            primary = misc.lst(markers);\n        });\n        return new SharedTextMarker(markers, primary);\n    }\n    function findSharedMarkers(doc) {\n        return doc.findMarks(m_pos.Pos(doc.first, 0), doc.clipPos(m_pos.Pos(doc.lastLine())), m => m.parent);\n    }\n    function copySharedMarkers(doc, markers) {\n        for (let i = 0; i < markers.length; i++) {\n            let marker = markers[i], pos = marker.find();\n            let mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n            if (m_pos.cmp(mFrom, mTo)) {\n                let subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n                marker.markers.push(subMark);\n                subMark.parent = marker;\n            }\n        }\n    }\n    function detachSharedMarkers(markers) {\n        for (let i = 0; i < markers.length; i++) {\n            let marker = markers[i], linked = [marker.primary.doc];\n            document_data.linkedDocs(marker.primary.doc, d => linked.push(d));\n            for (let j = 0; j < marker.markers.length; j++) {\n                let subMarker = marker.markers[j];\n                if (misc.indexOf(linked, subMarker.doc) == -1) {\n                    subMarker.parent = null;\n                    marker.markers.splice(j--, 1);\n                }\n            }\n        }\n    }\n    return {\n        TextMarker: TextMarker,\n        markText: markText,\n        SharedTextMarker: SharedTextMarker,\n        findSharedMarkers: findSharedMarkers,\n        copySharedMarkers: copySharedMarkers,\n        detachSharedMarkers: detachSharedMarkers\n    };\n});"]}