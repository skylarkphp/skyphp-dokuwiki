{"version":3,"sources":["util/operation_group.js"],"names":["define","a","operationGroup","orphanDelayedCallbacks","fireOrphanDelayed","delayed","i","length","pushOperation","op","ops","push","ownsGroup","delayedCallbacks","finishOperation","endCb","group","callbacks","call","j","cursorActivityHandlers","cursorActivityCalled","cm","fireCallbacksForOps","signalLater","emitter","type","arr","getHandlers","list","args","Array","prototype","slice","arguments","setTimeout","apply"],"mappings":";;;;;;;AAAAA,QAAQ,WAAY,SAAUC,GAC1B,aACA,IAAIC,EAAiB,KAmCrB,IAAIC,EAAyB,KAiB7B,SAASC,IACL,IAAIC,EAAUF,EACdA,EAAyB,KACzB,IAAK,IAAIG,EAAI,EAAGA,EAAID,EAAQE,SAAUD,EAClCD,EAAQC,KAEhB,OACIE,cA1DJ,SAAuBC,GACfP,EACAA,EAAeQ,IAAIC,KAAKF,GAExBA,EAAGG,UAAYV,GACXQ,KAAMD,GACNI,sBAqDRC,gBApCJ,SAAyBL,EAAIM,GACzB,IAAIC,EAAQP,EAAGG,UACf,GAAKI,EAEL,KAjBJ,SAA6BA,GACzB,IAAIC,EAAYD,EAAMH,iBAAkBP,EAAI,EAC5C,EAAG,CACC,KAAOA,EAAIW,EAAUV,OAAQD,IACzBW,EAAUX,GAAGY,KAAK,MACtB,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAMN,IAAIH,OAAQY,IAAK,CACvC,IAAIV,EAAKO,EAAMN,IAAIS,GACnB,GAAIV,EAAGW,uBACH,KAAOX,EAAGY,qBAAuBZ,EAAGW,uBAAuBb,QACvDE,EAAGW,uBAAuBX,EAAGY,wBAAwBH,KAAK,KAAMT,EAAGa,WAE1EhB,EAAIW,EAAUV,QAOnBgB,CAAoBP,GACtB,QACEd,EAAiB,KACjBa,EAAMC,KA6BVQ,YAzBJ,SAAqBC,EAASC,GAC1B,IAAIC,EAAM1B,EAAE2B,YAAYH,EAASC,GACjC,IAAKC,EAAIpB,OACL,OACJ,IAAqDsB,EAAjDC,EAAOC,MAAMC,UAAUC,MAAMf,KAAKgB,UAAW,GAC7ChC,EACA2B,EAAO3B,EAAeW,iBACfV,EACP0B,EAAO1B,GAEP0B,EAAO1B,KACPgC,WAAW/B,EAAmB,IAElC,IAAK,IAAIE,EAAI,EAAGA,EAAIqB,EAAIpB,SAAUD,EAC9BuB,EAAKlB,KAAK,IAAMgB,EAAIrB,GAAG8B,MAAM,KAAMN","file":"../../util/operation_group.js","sourcesContent":["define(['./event'], function (a) {\n    'use strict';\n    let operationGroup = null;\n    function pushOperation(op) {\n        if (operationGroup) {\n            operationGroup.ops.push(op);\n        } else {\n            op.ownsGroup = operationGroup = {\n                ops: [op],\n                delayedCallbacks: []\n            };\n        }\n    }\n    function fireCallbacksForOps(group) {\n        let callbacks = group.delayedCallbacks, i = 0;\n        do {\n            for (; i < callbacks.length; i++)\n                callbacks[i].call(null);\n            for (let j = 0; j < group.ops.length; j++) {\n                let op = group.ops[j];\n                if (op.cursorActivityHandlers)\n                    while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n                        op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n            }\n        } while (i < callbacks.length);\n    }\n    function finishOperation(op, endCb) {\n        let group = op.ownsGroup;\n        if (!group)\n            return;\n        try {\n            fireCallbacksForOps(group);\n        } finally {\n            operationGroup = null;\n            endCb(group);\n        }\n    }\n    let orphanDelayedCallbacks = null;\n    function signalLater(emitter, type) {\n        let arr = a.getHandlers(emitter, type);\n        if (!arr.length)\n            return;\n        let args = Array.prototype.slice.call(arguments, 2), list;\n        if (operationGroup) {\n            list = operationGroup.delayedCallbacks;\n        } else if (orphanDelayedCallbacks) {\n            list = orphanDelayedCallbacks;\n        } else {\n            list = orphanDelayedCallbacks = [];\n            setTimeout(fireOrphanDelayed, 0);\n        }\n        for (let i = 0; i < arr.length; ++i)\n            list.push(() => arr[i].apply(null, args));\n    }\n    function fireOrphanDelayed() {\n        let delayed = orphanDelayedCallbacks;\n        orphanDelayedCallbacks = null;\n        for (let i = 0; i < delayed.length; ++i)\n            delayed[i]();\n    }\n    return {\n        pushOperation: pushOperation,\n        finishOperation: finishOperation,\n        signalLater: signalLater\n    };\n});"]}