{"version":3,"sources":["skylark-domx-finder.js"],"names":["define","skylark","langx","browser","noder","local","filter","Array","prototype","slice","nativeMatchesSelector","matchesSelector","parsed","separatorIndex","combinatorIndex","reversed","from","cache","reverseCache","reUnescape","parse","expression","isReversed","Slick","replace","currentCache","expressions","raw","reverse","this","regexp","parser","length","reverseCombinator","combinator","test","i","exp","last","parts","tag","j","cexp","push","escapeRegExp","string","RegExp","rawMatch","separator","combinatorChildren","tagName","id","className","attributeKey","attributeOperator","attributeQuote","attributeValue","pseudoMarker","pseudoClass","pseudoQuote","pseudoClassQuotedValue","pseudoClassValue","currentSeparator","currentParsed","classList","classes","value","pseudos","key","type","indexOf","attributes","operator","apply","rinputs","rheader","parseSelector","button","elem","name","nodeName","toLowerCase","checked","elm","contains","idx","nodes","text","$","disabled","enabled","eq","even","focus","document","activeElement","href","tabindex","focusable","first","gt","has","sel","find","header","hidden","input","lt","not","matches","odd","parent","parentNode","selected","tabbable","tabIndex","hasTabindex","element","visible","offsetWidth","empty","hasChildNodes","createInputPseudo","createButtonPseudo","forEach","item","isArrayFilter","radio","checkbox","file","password","image","submit","reset","ancestors","node","selector","root","ret","rootIsSelector","isString","nodeType","isArrayLike","inArray","children","childNodes","descendants","call","querySelectorAll","matchError","query","descendant","querySelector","body","firstChild","nextSibling","lastChild","previousSibling","match","isPlainObject","check","adjacent","nextSiblings","previousSiblings","siblings","divide","cond","nativeSelector","customPseudos","JSON","stringify","part","undefined","toUpperCase","arrayFilte","cls","pseudo","getAttribute","hasAttribute","currentExpression","simpleExpCounter","filterSingle","matchs","Error","uniq","concat","combine","bit","node1","op","prev","next","divided","single","currentBit","founds","found","currentItems","map","finder","mixin","ancestor","byId","doc","getElementById","closest","findAll","attach","main"],"mappings":"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","file":"../skylark-domx-finder.js","sourcesContent":["define('skylark-domx-finder/finder',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-browser\",\r\n    \"skylark-domx-noder\"\r\n], function(skylark, langx, browser, noder) {\r\n    var local = {},\r\n        filter = Array.prototype.filter,\r\n        slice = Array.prototype.slice,\r\n        nativeMatchesSelector = browser.matchesSelector;\r\n\r\n    /*\r\n    ---\r\n    name: Slick.Parser\r\n    description: Standalone CSS3 Selector parser\r\n    provides: Slick.Parser\r\n    ...\r\n    */\r\n    ;\r\n    (function() {\r\n\r\n        var parsed,\r\n            separatorIndex,\r\n            combinatorIndex,\r\n            reversed,\r\n            cache = {},\r\n            reverseCache = {},\r\n            reUnescape = /\\\\/g;\r\n\r\n        var parse = function(expression, isReversed) {\r\n            if (expression == null) return null;\r\n            if (expression.Slick === true) return expression;\r\n            expression = ('' + expression).replace(/^\\s+|\\s+$/g, '');\r\n            reversed = !!isReversed;\r\n            var currentCache = (reversed) ? reverseCache : cache;\r\n            if (currentCache[expression]) return currentCache[expression];\r\n            parsed = {\r\n                Slick: true,\r\n                expressions: [],\r\n                raw: expression,\r\n                reverse: function() {\r\n                    return parse(this.raw, true);\r\n                }\r\n            };\r\n            separatorIndex = -1;\r\n            while (expression != (expression = expression.replace(regexp, parser)));\r\n            parsed.length = parsed.expressions.length;\r\n            return currentCache[parsed.raw] = (reversed) ? reverse(parsed) : parsed;\r\n        };\r\n\r\n        var reverseCombinator = function(combinator) {\r\n            if (combinator === '!') return ' ';\r\n            else if (combinator === ' ') return '!';\r\n            else if ((/^!/).test(combinator)) return combinator.replace(/^!/, '');\r\n            else return '!' + combinator;\r\n        };\r\n\r\n        var reverse = function(expression) {\r\n            var expressions = expression.expressions;\r\n            for (var i = 0; i < expressions.length; i++) {\r\n                var exp = expressions[i];\r\n                var last = {\r\n                    parts: [],\r\n                    tag: '*',\r\n                    combinator: reverseCombinator(exp[0].combinator)\r\n                };\r\n\r\n                for (var j = 0; j < exp.length; j++) {\r\n                    var cexp = exp[j];\r\n                    if (!cexp.reverseCombinator) cexp.reverseCombinator = ' ';\r\n                    cexp.combinator = cexp.reverseCombinator;\r\n                    delete cexp.reverseCombinator;\r\n                }\r\n\r\n                exp.reverse().push(last);\r\n            }\r\n            return expression;\r\n        };\r\n\r\n        var escapeRegExp = (function() {\r\n            // Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License\r\n            var from = /(?=[\\-\\[\\]{}()*+?.\\\\\\^$|,#\\s])/g,\r\n                to = '\\\\';\r\n            return function(string) {\r\n                return string.replace(from, to)\r\n            }\r\n        }())\r\n\r\n        var regexp = new RegExp(\r\n            \"^(?:\\\\s*(,)\\\\s*|\\\\s*(<combinator>+)\\\\s*|(\\\\s+)|(<unicode>+|\\\\*)|\\\\#(<unicode>+)|\\\\.(<unicode>+)|\\\\[\\\\s*(<unicode1>+)(?:\\\\s*([*^$!~|]?=)(?:\\\\s*(?:([\\\"']?)(.*?)\\\\9)))?\\\\s*\\\\](?!\\\\])|(:+)(<unicode>+)(?:\\\\((?:(?:([\\\"'])([^\\\\13]*)\\\\13)|((?:\\\\([^)]+\\\\)|[^()]*)+))\\\\))?)\"\r\n            .replace(/<combinator>/, '[' + escapeRegExp(\">+~`!@$%^&={}\\\\;</\") + ']')\r\n            .replace(/<unicode>/g, '(?:[\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])')\r\n            .replace(/<unicode1>/g, '(?:[:\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])')\r\n        );\r\n\r\n        function parser(\r\n            rawMatch,\r\n\r\n            separator,\r\n            combinator,\r\n            combinatorChildren,\r\n\r\n            tagName,\r\n            id,\r\n            className,\r\n\r\n            attributeKey,\r\n            attributeOperator,\r\n            attributeQuote,\r\n            attributeValue,\r\n\r\n            pseudoMarker,\r\n            pseudoClass,\r\n            pseudoQuote,\r\n            pseudoClassQuotedValue,\r\n            pseudoClassValue\r\n        ) {\r\n            if (separator || separatorIndex === -1) {\r\n                parsed.expressions[++separatorIndex] = [];\r\n                combinatorIndex = -1;\r\n                if (separator) return '';\r\n            }\r\n\r\n            if (combinator || combinatorChildren || combinatorIndex === -1) {\r\n                combinator = combinator || ' ';\r\n                var currentSeparator = parsed.expressions[separatorIndex];\r\n                if (reversed && currentSeparator[combinatorIndex])\r\n                    currentSeparator[combinatorIndex].reverseCombinator = reverseCombinator(combinator);\r\n                currentSeparator[++combinatorIndex] = {\r\n                    combinator: combinator,\r\n                    tag: '*'\r\n                };\r\n            }\r\n\r\n            var currentParsed = parsed.expressions[separatorIndex][combinatorIndex];\r\n\r\n            if (tagName) {\r\n                currentParsed.tag = tagName.replace(reUnescape, '');\r\n\r\n            } else if (id) {\r\n                currentParsed.id = id.replace(reUnescape, '');\r\n\r\n            } else if (className) {\r\n                className = className.replace(reUnescape, '');\r\n\r\n                if (!currentParsed.classList) currentParsed.classList = [];\r\n                if (!currentParsed.classes) currentParsed.classes = [];\r\n                currentParsed.classList.push(className);\r\n                currentParsed.classes.push({\r\n                    value: className,\r\n                    regexp: new RegExp('(^|\\\\s)' + escapeRegExp(className) + '(\\\\s|$)')\r\n                });\r\n\r\n            } else if (pseudoClass) {\r\n                pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;\r\n                pseudoClassValue = pseudoClassValue ? pseudoClassValue.replace(reUnescape, '') : null;\r\n\r\n                if (!currentParsed.pseudos) currentParsed.pseudos = [];\r\n                currentParsed.pseudos.push({\r\n                    key: pseudoClass.replace(reUnescape, ''),\r\n                    value: pseudoClassValue,\r\n                    type: pseudoMarker.length == 1 ? 'class' : 'element'\r\n                });\r\n\r\n            } else if (attributeKey) {\r\n                attributeKey = attributeKey.replace(reUnescape, '');\r\n                attributeValue = (attributeValue || '').replace(reUnescape, '');\r\n\r\n                var test, regexp;\r\n\r\n                switch (attributeOperator) {\r\n                    case '^=':\r\n                        regexp = new RegExp('^' + escapeRegExp(attributeValue));\r\n                        break;\r\n                    case '$=':\r\n                        regexp = new RegExp(escapeRegExp(attributeValue) + '$');\r\n                        break;\r\n                    case '~=':\r\n                        regexp = new RegExp('(^|\\\\s)' + escapeRegExp(attributeValue) + '(\\\\s|$)');\r\n                        break;\r\n                    case '|=':\r\n                        regexp = new RegExp('^' + escapeRegExp(attributeValue) + '(-|$)');\r\n                        break;\r\n                    case '=':\r\n                        test = function(value) {\r\n                            return attributeValue == value;\r\n                        };\r\n                        break;\r\n                    case '*=':\r\n                        test = function(value) {\r\n                            return value && value.indexOf(attributeValue) > -1;\r\n                        };\r\n                        break;\r\n                    case '!=':\r\n                        test = function(value) {\r\n                            return attributeValue != value;\r\n                        };\r\n                        break;\r\n                    default:\r\n                        test = function(value) {\r\n                            return !!value;\r\n                        };\r\n                }\r\n\r\n                if (attributeValue == '' && (/^[*$^]=$/).test(attributeOperator)) test = function() {\r\n                    return false;\r\n                };\r\n\r\n                if (!test) test = function(value) {\r\n                    return value && regexp.test(value);\r\n                };\r\n\r\n                if (!currentParsed.attributes) currentParsed.attributes = [];\r\n                currentParsed.attributes.push({\r\n                    key: attributeKey,\r\n                    operator: attributeOperator,\r\n                    value: attributeValue,\r\n                    test: test\r\n                });\r\n\r\n            }\r\n\r\n            return '';\r\n        };\r\n\r\n        // Slick NS\r\n\r\n        var Slick = (this.Slick || {});\r\n\r\n        Slick.parse = function(expression) {\r\n            return parse(expression);\r\n        };\r\n\r\n        Slick.escapeRegExp = escapeRegExp;\r\n\r\n        if (!this.Slick) this.Slick = Slick;\r\n\r\n    }).apply(local);\r\n\r\n\r\n    var simpleClassSelectorRE = /^\\.([\\w-]*)$/,\r\n        simpleIdSelectorRE = /^#([\\w-]*)$/,\r\n        rinputs = /^(?:input|select|textarea|button)$/i,\r\n        rheader = /^h\\d$/i,\r\n        slice = Array.prototype.slice;\r\n\r\n\r\n    local.parseSelector = local.Slick.parse;\r\n\r\n\r\n    var pseudos = local.pseudos = {\r\n        // custom pseudos\r\n        \"button\": function(elem) {\r\n            var name = elem.nodeName.toLowerCase();\r\n            return name === \"input\" && elem.type === \"button\" || name === \"button\";\r\n        },\r\n\r\n        'checked': function(elm) {\r\n            return !!elm.checked;\r\n        },\r\n\r\n        'contains': function(elm, idx, nodes, text) {\r\n            if ($(this).text().indexOf(text) > -1) return this\r\n        },\r\n\r\n        'disabled': function(elm) {\r\n            return !!elm.disabled;\r\n        },\r\n\r\n        'enabled': function(elm) {\r\n            return !elm.disabled;\r\n        },\r\n\r\n        'eq': function(elm, idx, nodes, value) {\r\n            return (idx == value);\r\n        },\r\n\r\n        'even': function(elm, idx, nodes, value) {\r\n            return (idx % 2) === 0;\r\n        },\r\n\r\n        'focus': function(elm) {\r\n            return document.activeElement === elm && (elm.href || elm.type || elm.tabindex);\r\n        },\r\n\r\n        'focusable': function( elm ) {\r\n            return noder.focusable(elm, elm.tabindex != null );\r\n        },\r\n\r\n        'first': function(elm, idx) {\r\n            return (idx === 0);\r\n        },\r\n\r\n        'gt': function(elm, idx, nodes, value) {\r\n            return (idx > value);\r\n        },\r\n\r\n        'has': function(elm, idx, nodes, sel) {\r\n            return find(elm, sel);\r\n        },\r\n\r\n        // Element/input types\r\n        \"header\": function(elem) {\r\n            return rheader.test(elem.nodeName);\r\n        },\r\n\r\n        'hidden': function(elm) {\r\n            return !local.pseudos[\"visible\"](elm);\r\n        },\r\n\r\n        \"input\": function(elem) {\r\n            return rinputs.test(elem.nodeName);\r\n        },\r\n\r\n        'last': function(elm, idx, nodes) {\r\n            return (idx === nodes.length - 1);\r\n        },\r\n\r\n        'lt': function(elm, idx, nodes, value) {\r\n            return (idx < value);\r\n        },\r\n\r\n        'not': function(elm, idx, nodes, sel) {\r\n            return !matches(elm, sel);\r\n        },\r\n\r\n        'odd': function(elm, idx, nodes, value) {\r\n            return (idx % 2) === 1;\r\n        },\r\n\r\n        /*   \r\n         * Get the parent of each element in the current set of matched elements.\r\n         * @param {Object} elm\r\n         */\r\n        'parent': function(elm) {\r\n            return !!elm.parentNode;\r\n        },\r\n\r\n        'selected': function(elm) {\r\n            return !!elm.selected;\r\n        },\r\n\r\n        'tabbable': function(elm) {\r\n            var tabIndex = elm.tabindex,\r\n                hasTabindex = tabIndex != null;\r\n            return ( !hasTabindex || tabIndex >= 0 ) && noder.focusable( element, hasTabindex );\r\n        },\r\n\r\n        'text': function(elm) {\r\n            return elm.type === \"text\";\r\n        },\r\n\r\n        'visible': function(elm) {\r\n            return elm.offsetWidth && elm.offsetWidth\r\n        },\r\n        'empty': function(elm) {\r\n            return !elm.hasChildNodes();\r\n        }\r\n    };\r\n\r\n    [\"first\", \"eq\", \"last\"].forEach(function(item) {\r\n        pseudos[item].isArrayFilter = true;\r\n    });\r\n\r\n\r\n\r\n    pseudos[\"nth\"] = pseudos[\"eq\"];\r\n\r\n    function createInputPseudo(type) {\r\n        return function(elem) {\r\n            var name = elem.nodeName.toLowerCase();\r\n            return name === \"input\" && elem.type === type;\r\n        };\r\n    }\r\n\r\n    function createButtonPseudo(type) {\r\n        return function(elem) {\r\n            var name = elem.nodeName.toLowerCase();\r\n            return (name === \"input\" || name === \"button\") && elem.type === type;\r\n        };\r\n    }\r\n\r\n    // Add button/input type pseudos\r\n    for (i in {\r\n        radio: true,\r\n        checkbox: true,\r\n        file: true,\r\n        password: true,\r\n        image: true\r\n    }) {\r\n        pseudos[i] = createInputPseudo(i);\r\n    }\r\n    for (i in {\r\n        submit: true,\r\n        reset: true\r\n    }) {\r\n        pseudos[i] = createButtonPseudo(i);\r\n    }\r\n\r\n\r\n    local.divide = function(cond) {\r\n        var nativeSelector = \"\",\r\n            customPseudos = [],\r\n            tag,\r\n            id,\r\n            classes,\r\n            attributes,\r\n            pseudos;\r\n\r\n\r\n        if (id = cond.id) {\r\n            nativeSelector += (\"#\" + id);\r\n        }\r\n        if (classes = cond.classes) {\r\n            for (var i = classes.length; i--;) {\r\n                nativeSelector += (\".\" + classes[i].value);\r\n            }\r\n        }\r\n        if (attributes = cond.attributes) {\r\n            for (var i = 0; i < attributes.length; i++) {\r\n                if (attributes[i].operator) {\r\n                    nativeSelector += (\"[\" + attributes[i].key + attributes[i].operator + JSON.stringify(attributes[i].value) + \"]\");\r\n                } else {\r\n                    nativeSelector += (\"[\" + attributes[i].key + \"]\");\r\n                }\r\n            }\r\n        }\r\n        if (pseudos = cond.pseudos) {\r\n            for (i = pseudos.length; i--;) {\r\n                part = pseudos[i];\r\n                if (this.pseudos[part.key]) {\r\n                    customPseudos.push(part);\r\n                } else {\r\n                    if (part.value !== undefined) {\r\n                        nativeSelector += (\":\" + part.key + \"(\" + JSON.stringify(part))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (tag = cond.tag) {\r\n            if (tag !== \"*\") {\r\n                nativeSelector = tag.toUpperCase() + nativeSelector;\r\n            }\r\n        }\r\n\r\n        if (!nativeSelector) {\r\n            nativeSelector = \"*\";\r\n        }\r\n\r\n        return {\r\n            nativeSelector: nativeSelector,\r\n            customPseudos: customPseudos\r\n        }\r\n\r\n    };\r\n\r\n    local.check = function(node, cond, idx, nodes, arrayFilte) {\r\n        var tag,\r\n            id,\r\n            classes,\r\n            attributes,\r\n            pseudos,\r\n\r\n            i, part, cls, pseudo;\r\n\r\n        if (!arrayFilte) {\r\n            if (tag = cond.tag) {\r\n                var nodeName = node.nodeName.toUpperCase();\r\n                if (tag == '*') {\r\n                    if (nodeName < '@') return false; // Fix for comment nodes and closed nodes\r\n                } else {\r\n                    if (nodeName != (tag || \"\").toUpperCase()) return false;\r\n                }\r\n            }\r\n\r\n            if (id = cond.id) {\r\n                if (node.getAttribute('id') != id) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n\r\n            if (classes = cond.classes) {\r\n                for (i = classes.length; i--;) {\r\n                    cls = node.getAttribute('class');\r\n                    if (!(cls && classes[i].regexp.test(cls))) return false;\r\n                }\r\n            }\r\n\r\n            if (attributes = cond.attributes) {\r\n                for (i = attributes.length; i--;) {\r\n                    part = attributes[i];\r\n                    if (part.operator ? !part.test(node.getAttribute(part.key)) : !node.hasAttribute(part.key)) return false;\r\n                }\r\n            }\r\n\r\n        }\r\n        if (pseudos = cond.pseudos) {\r\n            for (i = pseudos.length; i--;) {\r\n                part = pseudos[i];\r\n                if (pseudo = this.pseudos[part.key]) {\r\n                    if ((arrayFilte && pseudo.isArrayFilter) || (!arrayFilte && !pseudo.isArrayFilter)) {\r\n                        if (!pseudo(node, idx, nodes, part.value)) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (!arrayFilte && !nativeMatchesSelector.call(node, part.key)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    local.match = function(node, selector) {\r\n\r\n        var parsed;\r\n\r\n        if (langx.isString(selector)) {\r\n            parsed = local.Slick.parse(selector);\r\n        } else {\r\n            parsed = selector;\r\n        }\r\n\r\n        if (!parsed) {\r\n            return true;\r\n        }\r\n\r\n        // simple (single) selectors\r\n        var expressions = parsed.expressions,\r\n            simpleExpCounter = 0,\r\n            i,\r\n            currentExpression;\r\n        for (i = 0;\r\n            (currentExpression = expressions[i]); i++) {\r\n            if (currentExpression.length == 1) {\r\n                var exp = currentExpression[0];\r\n                if (this.check(node, exp)) {\r\n                    return true;\r\n                }\r\n                simpleExpCounter++;\r\n            }\r\n        }\r\n\r\n        if (simpleExpCounter == parsed.length) {\r\n            return false;\r\n        }\r\n\r\n        var nodes = this.query(document, parsed),\r\n            item;\r\n        for (i = 0; item = nodes[i++];) {\r\n            if (item === node) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n\r\n    local.filterSingle = function(nodes, exp) {\r\n        var matchs = filter.call(nodes, function(node, idx) {\r\n            return local.check(node, exp, idx, nodes, false);\r\n        });\r\n\r\n        matchs = filter.call(matchs, function(node, idx) {\r\n            return local.check(node, exp, idx, matchs, true);\r\n        });\r\n        return matchs;\r\n    };\r\n\r\n    local.filter = function(nodes, selector) {\r\n        var parsed;\r\n\r\n        if (langx.isString(selector)) {\r\n            parsed = local.Slick.parse(selector);\r\n        } else {\r\n            return local.filterSingle(nodes, selector);\r\n        }\r\n\r\n        // simple (single) selectors\r\n        var expressions = parsed.expressions,\r\n            i,\r\n            currentExpression,\r\n            ret = [];\r\n        for (i = 0;\r\n            (currentExpression = expressions[i]); i++) {\r\n            if (currentExpression.length == 1) {\r\n                var exp = currentExpression[0];\r\n\r\n                var matchs = local.filterSingle(nodes, exp);\r\n\r\n                ret = langx.uniq(ret.concat(matchs));\r\n            } else {\r\n                throw new Error(\"not supported selector:\" + selector);\r\n            }\r\n        }\r\n\r\n        return ret;\r\n\r\n    };\r\n\r\n    local.combine = function(elm, bit) {\r\n        var op = bit.combinator,\r\n            cond = bit,\r\n            node1,\r\n            nodes = [];\r\n\r\n        switch (op) {\r\n            case '>': // direct children\r\n                nodes = children(elm, cond);\r\n                break;\r\n            case '+': // next sibling\r\n                node1 = nextSibling(elm, cond, true);\r\n                if (node1) {\r\n                    nodes.push(node1);\r\n                }\r\n                break;\r\n            case '^': // first child\r\n                node1 = firstChild(elm, cond, true);\r\n                if (node1) {\r\n                    nodes.push(node1);\r\n                }\r\n                break;\r\n            case '~': // next siblings\r\n                nodes = nextSiblings(elm, cond);\r\n                break;\r\n            case '++': // next sibling and previous sibling\r\n                var prev = previousSibling(elm, cond, true),\r\n                    next = nextSibling(elm, cond, true);\r\n                if (prev) {\r\n                    nodes.push(prev);\r\n                }\r\n                if (next) {\r\n                    nodes.push(next);\r\n                }\r\n                break;\r\n            case '~~': // next siblings and previous siblings\r\n                nodes = siblings(elm, cond);\r\n                break;\r\n            case '!': // all parent nodes up to document\r\n                nodes = ancestors(elm, cond);\r\n                break;\r\n            case '!>': // direct parent (one level)\r\n                node1 = parent(elm, cond);\r\n                if (node1) {\r\n                    nodes.push(node1);\r\n                }\r\n                break;\r\n            case '!+': // previous sibling\r\n                nodes = previousSibling(elm, cond, true);\r\n                break;\r\n            case '!^': // last child\r\n                node1 = lastChild(elm, cond, true);\r\n                if (node1) {\r\n                    nodes.push(node1);\r\n                }\r\n                break;\r\n            case '!~': // previous siblings\r\n                nodes = previousSiblings(elm, cond);\r\n                break;\r\n            default:\r\n                var divided = this.divide(bit);\r\n                nodes = slice.call(elm.querySelectorAll(divided.nativeSelector));\r\n                if (divided.customPseudos) {\r\n                    for (var i = divided.customPseudos.length - 1; i >= 0; i--) {\r\n                        nodes = filter.call(nodes, function(item, idx) {\r\n                            return local.check(item, {\r\n                                pseudos: [divided.customPseudos[i]]\r\n                            }, idx, nodes, false)\r\n                        });\r\n\r\n                        nodes = filter.call(nodes, function(item, idx) {\r\n                            return local.check(item, {\r\n                                pseudos: [divided.customPseudos[i]]\r\n                            }, idx, nodes, true)\r\n                        });\r\n                    }\r\n                }\r\n                break;\r\n\r\n        }\r\n        return nodes;\r\n    }\r\n\r\n    local.query = function(node, selector, single) {\r\n\r\n\r\n        var parsed = this.Slick.parse(selector);\r\n\r\n        var\r\n            founds = [],\r\n            currentExpression, currentBit,\r\n            expressions = parsed.expressions;\r\n\r\n        for (var i = 0;\r\n            (currentExpression = expressions[i]); i++) {\r\n            var currentItems = [node],\r\n                found;\r\n            for (var j = 0;\r\n                (currentBit = currentExpression[j]); j++) {\r\n                found = langx.map(currentItems, function(item, i) {\r\n                    return local.combine(item, currentBit)\r\n                });\r\n                if (found) {\r\n                    currentItems = found;\r\n                }\r\n            }\r\n            if (found) {\r\n                founds = founds.concat(found);\r\n            }\r\n        }\r\n\r\n        return founds;\r\n    }\r\n\r\n    /*\r\n     * Get the nearest ancestor of the specified element,optional matched by a selector.\r\n     * @param {HTMLElement} node\r\n     * @param {String Optional } selector\r\n     * @param {Object} root\r\n     */\r\n    function ancestor(node, selector, root) {\r\n        var rootIsSelector = root && langx.isString(root);\r\n        while (node = node.parentNode) {\r\n            if (matches(node, selector)) {\r\n                return node;\r\n            }\r\n            if (root) {\r\n                if (rootIsSelector) {\r\n                    if (matches(node, root)) {\r\n                        break;\r\n                    }\r\n                } else if (node == root) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /*\r\n     * Get the ancestors of the specitied element , optionally filtered by a selector.\r\n     * @param {HTMLElement} node\r\n     * @param {String Optional } selector\r\n     * @param {Object} root\r\n     */\r\n    function ancestors(node, selector, root) {\r\n        var ret = [],\r\n            rootIsSelector = root && langx.isString(root);\r\n        while ((node = node.parentNode) && (node.nodeType !== 9)) {\r\n            if (root) {\r\n                if (rootIsSelector) {\r\n                    if (matches(node, root)) {\r\n                        break;\r\n                    }\r\n                } else if (langx.isArrayLike(root)) {\r\n                    if (langx.inArray(node,root)>-1) {\r\n                        break;\r\n                    }\r\n                } else if (node == root) {\r\n                    break;\r\n                }\r\n            }\r\n            if (!selector || matches(node, selector)) {\r\n              ret.push(node); \r\n            }\r\n        }\r\n\r\n        //if (selector) {\r\n        //    ret = local.filter(ret, selector);\r\n        //}\r\n        return ret;\r\n    }\r\n\r\n\r\n    /*\r\n     * Returns a element by its ID.\r\n     * @param {string} id\r\n     */\r\n    function byId(id, doc) {\r\n        doc = doc || noder.doc();\r\n        return doc.getElementById(id);\r\n    }\r\n\r\n    /*\r\n     * Get the children of the specified element , optionally filtered by a selector.\r\n     * @param {string} node\r\n     * @param {String optionlly} selector\r\n     */\r\n    function children(node, selector) {\r\n        var childNodes = node.childNodes,\r\n            ret = [];\r\n        for (var i = 0; i < childNodes.length; i++) {\r\n            var node = childNodes[i];\r\n            if (node.nodeType == 1) {\r\n                ret.push(node);\r\n            }\r\n        }\r\n        if (selector) {\r\n            ret = local.filter(ret, selector);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    function closest(node, selector) {\r\n        while (node && !(matches(node, selector))) {\r\n            node = node.parentNode;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    /*\r\n     * Get the decendant of the specified element , optionally filtered by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function descendants(elm, selector) {\r\n        // Selector\r\n        try {\r\n            return slice.call(elm.querySelectorAll(selector));\r\n        } catch (matchError) {\r\n            //console.log(matchError);\r\n        }\r\n        return local.query(elm, selector);\r\n    }\r\n\r\n    /*\r\n     * Get the nearest decendent of the specified element,optional matched by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function descendant(elm, selector) {\r\n        // Selector\r\n        try {\r\n            return elm.querySelector(selector);\r\n        } catch (matchError) {\r\n            //console.log(matchError);\r\n        }\r\n        var nodes = local.query(elm, selector);\r\n        if (nodes.length > 0) {\r\n            return nodes[0];\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the descendants of each element in the current set of matched elements, filtered by a selector, jQuery object, or element.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function find(elm, selector) {\r\n        if (!selector) {\r\n            selector = elm;\r\n            elm = document.body;\r\n        }\r\n        if (matches(elm, selector)) {\r\n            return elm;\r\n        } else {\r\n            return descendant(elm, selector);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the findAll of the specified element , optionally filtered by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function findAll(elm, selector) {\r\n        if (!selector) {\r\n            selector = elm;\r\n            elm = document.body;\r\n        }\r\n        return descendants(elm, selector);\r\n    }\r\n\r\n    /*\r\n     * Get the first child of the specified element , optionally filtered by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     * @param {String} first\r\n     */\r\n    function firstChild(elm, selector, first) {\r\n        var childNodes = elm.childNodes,\r\n            node = childNodes[0];\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    return node;\r\n                }\r\n                if (first) {\r\n                    break;\r\n                }\r\n            }\r\n            node = node.nextSibling;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /*\r\n     * Get the last child of the specified element , optionally filtered by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     * @param {String } last\r\n     */\r\n    function lastChild(elm, selector, last) {\r\n        var childNodes = elm.childNodes,\r\n            node = childNodes[childNodes.length - 1];\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    return node;\r\n                }\r\n                if (last) {\r\n                    break;\r\n                }\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /*\r\n     * Check the specified element against a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function matches(elm, selector) {\r\n        if (!selector || !elm || elm.nodeType !== 1) {\r\n            return false\r\n        }\r\n\r\n        if (langx.isString(selector)) {\r\n            try {\r\n                return nativeMatchesSelector.call(elm, selector.replace(/\\[([^=]+)=\\s*([^'\"\\]]+?)\\s*\\]/g, '[$1=\"$2\"]'));\r\n            } catch (matchError) {\r\n                //console.log(matchError);\r\n            }\r\n            return local.match(elm, selector);\r\n        } else if (langx.isArrayLike(selector)) {\r\n            return langx.inArray(elm, selector) > -1;\r\n        } else if (langx.isPlainObject(selector)) {\r\n            return local.check(elm, selector);\r\n        } else {\r\n            return elm === selector;\r\n        }\r\n\r\n    }\r\n\r\n    /*\r\n     * Get the nearest next sibing of the specitied element , optional matched by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     * @param {Boolean Optional} adjacent\r\n     */\r\n    function nextSibling(elm, selector, adjacent) {\r\n        var node = elm.nextSibling;\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    return node;\r\n                }\r\n                if (adjacent) {\r\n                    break;\r\n                }\r\n            }\r\n            node = node.nextSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /*\r\n     * Get the next siblings of the specified element , optional filtered by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function nextSiblings(elm, selector) {\r\n        var node = elm.nextSibling,\r\n            ret = [];\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    ret.push(node);\r\n                }\r\n            }\r\n            node = node.nextSibling;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * Get the parent element of the specified element. if a selector is provided, it retrieves the parent element only if it matches that selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function parent(elm, selector) {\r\n        var node = elm.parentNode;\r\n        if (node && (!selector || matches(node, selector))) {\r\n            return node;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /*\r\n     * Get hte nearest previous sibling of the specified element ,optional matched by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     * @param {Boolean Optional } adjacent\r\n     */\r\n    function previousSibling(elm, selector, adjacent) {\r\n        var node = elm.previousSibling;\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    return node;\r\n                }\r\n                if (adjacent) {\r\n                    break;\r\n                }\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /*\r\n     * Get all preceding siblings of each element in the set of matched elements, optionally filtered by a selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function previousSiblings(elm, selector) {\r\n        var node = elm.previousSibling,\r\n            ret = [];\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    ret.push(node);\r\n                }\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * Selects all sibling elements that follow after the prev element, have the same parent, and match the filtering siblings selector.\r\n     * @param {HTMLElement} elm\r\n     * @param {String optionlly} selector\r\n     */\r\n    function siblings(elm, selector) {\r\n        var node = elm.parentNode.firstChild,\r\n            ret = [];\r\n        while (node) {\r\n            if (node.nodeType == 1 && node !== elm) {\r\n                if (!selector || matches(node, selector)) {\r\n                    ret.push(node);\r\n                }\r\n            }\r\n            node = node.nextSibling;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    var finder = function() {\r\n        return finder;\r\n    };\r\n\r\n    langx.mixin(finder, {\r\n\r\n        ancestor: ancestor,\r\n\r\n        ancestors: ancestors,\r\n\r\n        byId: byId,\r\n\r\n        children: children,\r\n\r\n        closest: closest,\r\n\r\n        descendant: descendant,\r\n\r\n        descendants: descendants,\r\n\r\n        find: find,\r\n\r\n        findAll: findAll,\r\n\r\n        firstChild: firstChild,\r\n\r\n        lastChild: lastChild,\r\n\r\n        matches: matches,\r\n\r\n        nextSibling: nextSibling,\r\n\r\n        nextSiblings: nextSiblings,\r\n\r\n        parent: parent,\r\n\r\n        previousSibling,\r\n\r\n        previousSiblings,\r\n\r\n        pseudos: local.pseudos,\r\n\r\n        siblings: siblings\r\n    });\r\n\r\n    return skylark.attach(\"domx.finder\", finder);\r\n});\ndefine('skylark-domx-finder/main',[\r\n\t\"./finder\"\r\n],function(finder){\r\n\r\n\treturn finder;\r\n});\ndefine('skylark-domx-finder', ['skylark-domx-finder/main'], function (main) { return main; });\n\n"]}