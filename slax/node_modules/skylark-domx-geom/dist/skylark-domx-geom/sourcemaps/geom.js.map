{"version":3,"sources":["geom.js"],"names":["define","skylark","langx","noder","styler","cachedScrollbarWidth","rootNodeRE","px","toPixel","offsetParent","borderExtents","elm","isWindow","left","top","right","bottom","s","getComputedStyle","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","boundingPosition","coords","undefined","test","nodeName","getBoundingClientRect","parent","parentOffset","mex","marginExtents","pbex","relativePosition","this","boundingRect","size","window","document","documentElement","body","innerHeight","innerWidth","height","width","clientSize","dimension","clientWidth","clientHeight","isBorderBox","css","props","bex","pex","paddingExtents","getDocumentSize","doc","max","Math","scrollWidth","offsetWidth","scrollHeight","offsetHeight","marginLeft","marginTop","marginRight","marginBottom","paddingLeft","paddingTop","paddingRight","paddingBottom","pagePosition","obj","w","ownerDocument","defaultView","pageXOffset","pageYOffset","offset","isDefined","scrollTop","scrollLeft","relativeRect","value","nodeType","scrollingElement","hasScrollLeft","scrollTo","scrollY","hasScrollTop","scrollX","isDocument","viewportSize","win","geom","mixin","contentRect","cs","hasScrollbar","inview","cushion","r","o","calibrate","vsize","marginRect","me","marginSize","pageRect","round","scrollbarWidth","w1","w2","div","createFragment","innerDiv","childNodes","append","remove","scrollIntoView","align","x","y","parentWidth","parentHeight","parentElm","parentNode","pos","rootElm","offsetLeft","offsetTop","getOffset","scrollBy","testAxis","result","attach"],"mappings":"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","file":"../geom.js","sourcesContent":["define([\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-styler\"\r\n], function(skylark, langx, noder, styler) {\r\n  'use strict'\r\n\r\n    var rootNodeRE = /^(?:body|html)$/i,\r\n        px = langx.toPixel,\r\n        offsetParent = noder.offsetParent,\r\n        cachedScrollbarWidth;\r\n\r\n    function scrollbarWidth() {\r\n        if (cachedScrollbarWidth !== undefined) {\r\n            return cachedScrollbarWidth;\r\n        }\r\n        var w1, w2,\r\n            div = noder.createFragment(\"<div style=\" +\r\n                \"'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>\" +\r\n                \"<div style='height:300px;width:auto;'></div></div>\")[0],\r\n            innerDiv = div.childNodes[0];\r\n\r\n        noder.append(document.body, div);\r\n\r\n        w1 = innerDiv.offsetWidth;\r\n\r\n        styler.css(div, \"overflow\", \"scroll\");\r\n\r\n        w2 = innerDiv.offsetWidth;\r\n\r\n        if (w1 === w2) {\r\n            w2 = div[0].clientWidth;\r\n        }\r\n\r\n        noder.remove(div);\r\n\r\n        return (cachedScrollbarWidth = w1 - w2);\r\n    }\r\n\r\n\r\n    function hasScrollbar() {\r\n        return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight);\r\n    }\r\n\r\n    /*\r\n     * Get the widths of each border of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function borderExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.borderLeftWidth, elm),\r\n            top: px(s.borderTopWidth, elm),\r\n            right: px(s.borderRightWidth, elm),\r\n            bottom: px(s.borderBottomWidth, elm)\r\n        }\r\n    }\r\n\r\n    //viewport coordinate\r\n    /*\r\n     * Get or set the viewport position of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function boundingPosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            return rootNodeRE.test(elm.nodeName) ? { top: 0, left: 0 } : elm.getBoundingClientRect();\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top,\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the viewport rect of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function boundingRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            if (elm == window || elm == document.documentElement || elm == document.body){\r\n                return {\r\n                    top : 0,\r\n                    left : 0,\r\n                    bottom : window.innerHeight,\r\n                    right : window.innerWidth,\r\n                    height : window.innerHeight,\r\n                    width : window.innerWidth\r\n                };\r\n            } else if (elm.getBoundingClientRect) {\r\n                return elm.getBoundingClientRect();\r\n            }\r\n        } else {\r\n            boundingPosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the height of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function clientHeight(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).height;\r\n        } else {\r\n            return clientSize(elm, {\r\n                height: value\r\n            });\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the size of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} dimension\r\n     */\r\n    function clientSize(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            return {\r\n                width: elm.clientWidth,\r\n                height: elm.clientHeight\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width - pex.left - pex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height - pex.top - pex.bottom;\r\n                }\r\n            } else {\r\n                var bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width + bex.left + bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height + bex.top + bex.bottom;\r\n                }\r\n\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n        return {\r\n            width: elm.clientWidth,\r\n            height: elm.clientHeight\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get or set the width of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} dimension\r\n     */\r\n    function clientWidth(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).width;\r\n        } else {\r\n            clientSize(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the rect of the specified element content box.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function contentRect(elm) {\r\n        var cs = clientSize(elm),\r\n            pex = paddingExtents(elm);\r\n\r\n\r\n        //// On Opera, offsetLeft includes the parent's border\r\n        //if(has(\"opera\")){\r\n        //    pe.l += be.l;\r\n        //    pe.t += be.t;\r\n        //}\r\n        return {\r\n            left: pex.left,\r\n            top: pex.top,\r\n            width: cs.width - pex.left - pex.right,\r\n            height: cs.height - pex.top - pex.bottom\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get the document size.\r\n     * @param {HTMLDocument} doc\r\n     */\r\n    function getDocumentSize(doc) {\r\n        var documentElement = doc.documentElement,\r\n            body = doc.body,\r\n            max = Math.max,\r\n            scrollWidth = max(documentElement.scrollWidth, body.scrollWidth),\r\n            clientWidth = max(documentElement.clientWidth, body.clientWidth),\r\n            offsetWidth = max(documentElement.offsetWidth, body.offsetWidth),\r\n            scrollHeight = max(documentElement.scrollHeight, body.scrollHeight),\r\n            clientHeight = max(documentElement.clientHeight, body.clientHeight),\r\n            offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);\r\n\r\n        return {\r\n            width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,\r\n            height: scrollHeight < offsetHeight ? clientHeight : scrollHeight\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get the document size.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function height(elm, value) {\r\n        if (value == undefined) {\r\n            return size(elm).height;\r\n        } else {\r\n            size(elm, {\r\n                height: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    function inview(elm, cushion) {\r\n        function calibrate(coords, cushion) {\r\n            var o = {};\r\n            cushion = +cushion || 0;\r\n            o.width = (o.right = coords.right + cushion) - (o.left = coords.left - cushion);\r\n            o.height = (o.bottom = coords.bottom + cushion) - (o.top = coords.top - cushion);\r\n            return o;\r\n        }\r\n\r\n        var r = calibrate(boundingRect(elm), cushion),\r\n            vsize = viewportSize();\r\n\r\n        return !!r && r.bottom >= 0 && r.right >= 0 && r.top <= vsize.height && r.left <= vsize.width;\r\n    }\r\n\r\n\r\n    /*\r\n     * Get the widths of each margin of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function marginExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.marginLeft),\r\n            top: px(s.marginTop),\r\n            right: px(s.marginRight),\r\n            bottom: px(s.marginBottom),\r\n        }\r\n    }\r\n\r\n\r\n    function marginRect(elm) {\r\n        var obj = relativeRect(elm),\r\n            me = marginExtents(elm);\r\n\r\n        return {\r\n            left: obj.left,\r\n            top: obj.top,\r\n            width: obj.width + me.left + me.right,\r\n            height: obj.height + me.top + me.bottom\r\n        };\r\n    }\r\n\r\n\r\n    function marginSize(elm) {\r\n        var obj = size(elm),\r\n            me = marginExtents(elm);\r\n\r\n        return {\r\n            width: obj.width + me.left + me.right,\r\n            height: obj.height + me.top + me.bottom\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get the widths of each padding of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function paddingExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.paddingLeft),\r\n            top: px(s.paddingTop),\r\n            right: px(s.paddingRight),\r\n            bottom: px(s.paddingBottom),\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the document position of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    //coordinate to the document\r\n    function pagePosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect(),\r\n                w = elm.ownerDocument.defaultView;\r\n            return {\r\n                left: obj.left + w.pageXOffset,\r\n                top: obj.top + w.pageYOffset\r\n            }\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = pagePosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top,\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the document rect of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function pageRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect(),\r\n                w = elm.ownerDocument.defaultView;\r\n            return {\r\n                left: obj.left + w.pageXOffset,\r\n                top: obj.top + w.pageYOffset,\r\n                width: Math.round(obj.width),\r\n                height: Math.round(obj.height)\r\n            }\r\n        } else {\r\n            pagePosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the position of the specified element border box , relative to parent element.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    // coordinate relative to it's parent\r\n    function relativePosition(elm, coords) {\r\n        if (coords == undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingPosition(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left - mex.left\r\n            }\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm);\r\n\r\n            var props = {\r\n                top: coords.top,\r\n                left: coords.left\r\n            };\r\n\r\n            if (langx.isDefined(props.top)) {\r\n                props.top = props.top + (scrollTop(parent) || 0);\r\n            }\r\n\r\n            if (langx.isDefined(props.left)) {\r\n                props.left = props.left + (scrollLeft(parent) || 0);\r\n            } \r\n\r\n\r\n            if (styler.css(elm, \"position\") == \"static\") {\r\n                props['position'] = \"relative\";\r\n            }\r\n\r\n\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the rect of the specified element border box , relatived to parent element.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function relativeRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingRect(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top, // - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left, // - mex.left,\r\n                width: offset.width,\r\n                height: offset.height\r\n            }\r\n        } else {\r\n            relativePosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Scroll the specified element into view.\r\n     * @param {HTMLElement} elm\r\n     * @param {} align\r\n     */\r\n    function scrollIntoView(elm, align) {\r\n        function getOffset(elm, rootElm) {\r\n            var x, y, parent = elm;\r\n\r\n            x = y = 0;\r\n            while (parent && parent != rootElm && parent.nodeType) {\r\n                x += parent.offsetLeft || 0;\r\n                y += parent.offsetTop || 0;\r\n                parent = parent.offsetParent;\r\n            }\r\n\r\n            return { x: x, y: y };\r\n        }\r\n\r\n        var parentElm = elm.parentNode;\r\n        var x, y, width, height, parentWidth, parentHeight;\r\n        var pos = getOffset(elm, parentElm);\r\n\r\n        x = pos.x;\r\n        y = pos.y;\r\n        width = elm.offsetWidth;\r\n        height = elm.offsetHeight;\r\n        parentWidth = parentElm.clientWidth;\r\n        parentHeight = parentElm.clientHeight;\r\n\r\n        if (align == \"end\") {\r\n            x -= parentWidth - width;\r\n            y -= parentHeight - height;\r\n        } else if (align == \"center\") {\r\n            x -= (parentWidth / 2) - (width / 2);\r\n            y -= (parentHeight / 2) - (height / 2);\r\n        }\r\n\r\n        parentElm.scrollLeft = x;\r\n        parentElm.scrollTop = y;\r\n\r\n        return this;\r\n    }\r\n    /*\r\n     * Get or set the current horizontal position of the scroll bar for the specified element.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function scrollLeft(elm, value) {\r\n        if (elm.nodeType === 9) {\r\n            elm = elm.defaultView;\r\n        } else if (elm == document.body) {\r\n            elm = document.scrollingElement  || document.documentElement;\r\n        }\r\n        var hasScrollLeft = \"scrollLeft\" in elm;\r\n        if (value === undefined) {\r\n            return hasScrollLeft ? elm.scrollLeft : elm.pageXOffset\r\n        } else {\r\n            if (hasScrollLeft) {\r\n                elm.scrollLeft = value;\r\n            } else {\r\n                elm.scrollTo(value, elm.scrollY);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Get or the current vertical position of the scroll bar for the specified element.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function scrollTop(elm, value) {\r\n        if (elm.nodeType === 9) {\r\n            elm = elm.defaultView;\r\n        } else if (elm == document.body) {\r\n            elm = document.scrollingElement  || document.documentElement;\r\n        }\r\n\r\n        var hasScrollTop = \"scrollTop\" in elm;\r\n\r\n        if (value === undefined) {\r\n            return hasScrollTop ? elm.scrollTop : elm.pageYOffset\r\n        } else {\r\n            if (hasScrollTop) {\r\n                elm.scrollTop = value;\r\n            } else {\r\n                elm.scrollTo(elm.scrollX, value);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function scrollBy(elm, x, y) {\r\n        elm.scrollLeft += x;\r\n        elm.scrollTop += y;\r\n    }\r\n\r\n\r\n    /*\r\n     * Get or set the size of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject}dimension\r\n     */\r\n    function size(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            if (langx.isWindow(elm)) {\r\n                return {\r\n                    width: elm.innerWidth,\r\n                    height: elm.innerHeight\r\n                }\r\n\r\n            } else if (langx.isDocument(elm)) {\r\n                return getDocumentSize(document);\r\n            } else {\r\n                return {\r\n                    width: elm.offsetWidth,\r\n                    height: elm.offsetHeight\r\n                }\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm),\r\n                    bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined && props.width !== \"\" && props.width !== null) {\r\n                    props.width = props.width - pex.left - pex.right - bex.left - bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined && props.height !== \"\" && props.height !== null) {\r\n                    props.height = props.height - pex.top - pex.bottom - bex.top - bex.bottom;\r\n                }\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n    function viewportSize(win) {\r\n        win = win || window;\r\n\r\n        return boundingRect(win);\r\n    }\r\n\r\n    /*\r\n     * Get or set the size of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function width(elm, value) {\r\n        if (value == undefined) {\r\n            return size(elm).width;\r\n        } else {\r\n            size(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function testAxis(elm) {\r\n       \r\n        var top = elm.offsetTop;\r\n        var left = elm.offsetLeft;\r\n        var width = elm.offsetWidth;\r\n        var height = elm.offsetHeight;\r\n\r\n        while(elm.offsetParent) {\r\n            elm = elm.offsetParent;\r\n            top += elm.offsetTop;\r\n            left += elm.offsetLeft;\r\n        }\r\n\r\n        var result = {x: 0, y: 0};\r\n\r\n        //Over the top of the window\r\n        if(top < window.pageYOffset) {\r\n            result.y = top - window.pageYOffset;\r\n        }\r\n        //Bellow the window\r\n        else if((top + height) > (window.pageYOffset + window.innerHeight))\r\n        {\r\n            result.y = (top + height) - (window.pageYOffset + window.innerHeight);\r\n        }\r\n\r\n        //Left to the window\r\n        if(left < window.pageXOffset) {\r\n            result.x = left - window.pageXOffset;\r\n        }\r\n        //Right to the window\r\n        else if((left + width) > (window.pageXOffset + window.innerWidth))\r\n        {\r\n            result.x = (left + width) - (window.pageXOffset + window.innerWidth);\r\n        }\r\n\r\n        return result;\r\n    };    \r\n\r\n    function geom() {\r\n        return geom;\r\n    }\r\n\r\n    langx.mixin(geom, {\r\n        borderExtents: borderExtents,\r\n        //viewport coordinate\r\n        boundingPosition: boundingPosition,\r\n\r\n        boundingRect: boundingRect,\r\n\r\n        clientHeight: clientHeight,\r\n\r\n        clientSize: clientSize,\r\n\r\n        clientWidth: clientWidth,\r\n\r\n        contentRect: contentRect,\r\n\r\n        getDocumentSize: getDocumentSize,\r\n\r\n        hasScrollbar,\r\n\r\n        height: height,\r\n\r\n        inview,\r\n\r\n        marginExtents: marginExtents,\r\n\r\n        marginRect: marginRect,\r\n\r\n        marginSize: marginSize,\r\n\r\n        offsetParent: offsetParent,\r\n\r\n        paddingExtents: paddingExtents,\r\n\r\n        //coordinate to the document\r\n        pagePosition: pagePosition,\r\n\r\n        pageRect: pageRect,\r\n\r\n        // coordinate relative to it's parent\r\n        relativePosition: relativePosition,\r\n\r\n        relativeRect: relativeRect,\r\n\r\n        scrollbarWidth: scrollbarWidth,\r\n\r\n        scrollIntoView: scrollIntoView,\r\n\r\n        scrollLeft: scrollLeft,\r\n\r\n        scrollTop: scrollTop,\r\n\r\n        scrollBy,\r\n            \r\n        size: size,\r\n\r\n        testAxis,\r\n\r\n        viewportSize,\r\n\r\n        width: width\r\n    });\r\n\r\n\r\n\r\n    return skylark.attach(\"domx.geom\", geom);\r\n});"]}