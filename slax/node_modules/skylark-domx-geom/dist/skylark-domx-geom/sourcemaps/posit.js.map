{"version":3,"sources":["posit.js"],"names":["define","langx","noder","styler","geom","max","Math","abs","rhorizontal","rvertical","roffset","rposition","rpercent","getOffsets","offsets","width","height","parseFloat","test","parseCss","element","property","parseInt","css","positions","fit","left","position","data","newOverRight","within","withinOffset","isWindow","scrollLeft","offset","outerWidth","collisionPosLeft","collisionPosition","marginLeft","overLeft","overRight","collisionWidth","top","newOverBottom","scrollTop","outerHeight","collisionPosTop","marginTop","overTop","overBottom","collisionHeight","flip","newOverLeft","offsetLeft","myOffset","my","elemWidth","atOffset","at","targetWidth","newOverTop","offsetTop","elemHeight","targetHeight","flipfit","apply","this","arguments","posit","elm","options","targetOffset","basePosition","dimensions","withinElement","isDocument","hasOffset","msize","raw","target","extend","of","window","nodeType","marginSize","pagePosition","scrollInfo","overflowX","overflowY","hasOverflowX","scrollWidth","scrollHeight","scrollbarWidth","getScrollInfo","collision","split","size","preventDefault","pageY","pageX","each","horizontalOffset","verticalOffset","pos","length","concat","exec","elem","using","i","dir","props","right","bottom","feedback","horizontal","vertical","important","call"],"mappings":"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","file":"../posit.js","sourcesContent":["define([\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-styler\",\r\n    \"./geom\"\r\n],function(langx,noder,styler,geom){\r\n  'use strict'\r\n\r\n    var max = Math.max,\r\n        abs = Math.abs,\r\n        rhorizontal = /left|center|right/,\r\n        rvertical = /top|center|bottom/,\r\n        roffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\r\n        rposition = /^\\w+/,\r\n        rpercent = /%$/;\r\n\r\n    function getOffsets( offsets, width, height ) {\r\n        return [\r\n            parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\r\n            parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\r\n        ];\r\n    }\r\n\r\n    function parseCss( element, property ) {\r\n        return parseInt( styler.css( element, property ), 10 ) || 0;\r\n    }\r\n\r\n    function getDimensions( raw ) {\r\n        if ( raw.nodeType === 9 ) {\r\n            return {\r\n                size: size(raw),\r\n                offset: { top: 0, left: 0 }\r\n            };\r\n        }\r\n        if ( noder.isWindow( raw ) ) {\r\n            return {\r\n                size: geom.size(raw),\r\n                offset: { \r\n                    top: geom.scrollTop(raw), \r\n                    left: geom.scrollLeft(raw) \r\n                }\r\n            };\r\n        }\r\n        if ( raw.preventDefault ) {\r\n            return {\r\n                size : {\r\n                    width: 0,\r\n                    height: 0\r\n                },\r\n                offset: { \r\n                    top: raw.pageY, \r\n                    left: raw.pageX \r\n                }\r\n            };\r\n        }\r\n        return {\r\n            size: geom.size(raw),\r\n            offset: geom.pagePosition(raw)\r\n        };\r\n    }\r\n\r\n    function getScrollInfo( within ) {\r\n        var overflowX = within.isWindow || within.isDocument ? \"\" :\r\n                styler.css(within.element,\"overflow-x\" ),\r\n            overflowY = within.isWindow || within.isDocument ? \"\" :\r\n                styler.css(within.element,\"overflow-y\" ),\r\n            hasOverflowX = overflowX === \"scroll\" ||\r\n                ( overflowX === \"auto\" && within.width < geom.scrollWidth(within.element) ),\r\n            hasOverflowY = overflowY === \"scroll\" ||\r\n                ( overflowY === \"auto\" && within.height < geom.scrollHeight(within.element));\r\n        return {\r\n            width: hasOverflowY ? geom.scrollbarWidth() : 0,\r\n            height: hasOverflowX ? geom.scrollbarWidth() : 0\r\n        };\r\n    }\r\n\r\n    function getWithinInfo( element ) {\r\n        var withinElement = element || window,\r\n            isWindow = noder.isWindow( withinElement),\r\n            isDocument = !!withinElement && withinElement.nodeType === 9,\r\n            hasOffset = !isWindow && !isDocument,\r\n            msize = geom.marginSize(withinElement);\r\n        return {\r\n            element: withinElement,\r\n            isWindow: isWindow,\r\n            isDocument: isDocument,\r\n            offset: hasOffset ? geom.pagePosition(element) : { left: 0, top: 0 },\r\n            scrollLeft: geom.scrollLeft(withinElement),\r\n            scrollTop: geom.scrollTop(withinElement),\r\n            width: msize.width,\r\n            height: msize.height\r\n        };\r\n    }\r\n\r\n    function posit(elm,options ) {\r\n        // Make a copy, we don't want to modify arguments\r\n        options = langx.extend( {}, options );\r\n\r\n        var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\r\n            target = options.of,\r\n            within = getWithinInfo( options.within ),\r\n            scrollInfo = getScrollInfo( within ),\r\n            collision = ( options.collision || \"flip\" ).split( \" \" ),\r\n            offsets = {};\r\n\r\n        dimensions = getDimensions( target );\r\n        if ( target.preventDefault ) {\r\n\r\n            // Force left top to allow flipping\r\n            options.at = \"left top\";\r\n        }\r\n        targetWidth = dimensions.size.width;\r\n        targetHeight = dimensions.size.height;\r\n        targetOffset = dimensions.offset;\r\n\r\n        // Clone to reuse original targetOffset later\r\n        basePosition = langx.extend( {}, targetOffset );\r\n\r\n        // Force my and at to have valid horizontal and vertical positions\r\n        // if a value is missing or invalid, it will be converted to center\r\n        langx.each( [ \"my\", \"at\" ], function() {\r\n            var pos = ( options[ this ] || \"\" ).split( \" \" ),\r\n                horizontalOffset,\r\n                verticalOffset;\r\n\r\n            if ( pos.length === 1 ) {\r\n                pos = rhorizontal.test( pos[ 0 ] ) ?\r\n                    pos.concat( [ \"center\" ] ) :\r\n                    rvertical.test( pos[ 0 ] ) ?\r\n                        [ \"center\" ].concat( pos ) :\r\n                        [ \"center\", \"center\" ];\r\n            }\r\n            pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\r\n            pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\r\n\r\n            // Calculate offsets\r\n            horizontalOffset = roffset.exec( pos[ 0 ] );\r\n            verticalOffset = roffset.exec( pos[ 1 ] );\r\n            offsets[ this ] = [\r\n                horizontalOffset ? horizontalOffset[ 0 ] : 0,\r\n                verticalOffset ? verticalOffset[ 0 ] : 0\r\n            ];\r\n\r\n            // Reduce to just the positions without the offsets\r\n            options[ this ] = [\r\n                rposition.exec( pos[ 0 ] )[ 0 ],\r\n                rposition.exec( pos[ 1 ] )[ 0 ]\r\n            ];\r\n        } );\r\n\r\n        // Normalize collision option\r\n        if ( collision.length === 1 ) {\r\n            collision[ 1 ] = collision[ 0 ];\r\n        }\r\n\r\n        if ( options.at[ 0 ] === \"right\" ) {\r\n            basePosition.left += targetWidth;\r\n        } else if ( options.at[ 0 ] === \"center\" ) {\r\n            basePosition.left += targetWidth / 2;\r\n        }\r\n\r\n        if ( options.at[ 1 ] === \"bottom\" ) {\r\n            basePosition.top += targetHeight;\r\n        } else if ( options.at[ 1 ] === \"center\" ) {\r\n            basePosition.top += targetHeight / 2;\r\n        }\r\n\r\n        atOffset = getOffsets( offsets.at, targetWidth, targetHeight );\r\n        basePosition.left += atOffset[ 0 ];\r\n        basePosition.top += atOffset[ 1 ];\r\n\r\n        return ( function(elem) {\r\n            var collisionPosition, using,\r\n                msize = geom.marginSize(elem),\r\n                elemWidth = msize.width,\r\n                elemHeight = msize.height,\r\n                marginLeft = parseCss( elem, \"marginLeft\" ),\r\n                marginTop = parseCss( elem, \"marginTop\" ),\r\n                collisionWidth = elemWidth + marginLeft + parseCss( elem, \"marginRight\" ) +\r\n                    scrollInfo.width,\r\n                collisionHeight = elemHeight + marginTop + parseCss( elem, \"marginBottom\" ) +\r\n                    scrollInfo.height,\r\n                position = langx.extend( {}, basePosition ),\r\n                myOffset = getOffsets( offsets.my, msize.width, msize.height);\r\n\r\n            if ( options.my[ 0 ] === \"right\" ) {\r\n                position.left -= elemWidth;\r\n            } else if ( options.my[ 0 ] === \"center\" ) {\r\n                position.left -= elemWidth / 2;\r\n            }\r\n\r\n            if ( options.my[ 1 ] === \"bottom\" ) {\r\n                position.top -= elemHeight;\r\n            } else if ( options.my[ 1 ] === \"center\" ) {\r\n                position.top -= elemHeight / 2;\r\n            }\r\n\r\n            position.left += myOffset[ 0 ];\r\n            position.top += myOffset[ 1 ];\r\n\r\n            collisionPosition = {\r\n                marginLeft: marginLeft,\r\n                marginTop: marginTop\r\n            };\r\n\r\n            langx.each( [ \"left\", \"top\" ], function( i, dir ) {\r\n                if ( positions[ collision[ i ] ] ) {\r\n                    positions[ collision[ i ] ][ dir ]( position, {\r\n                        targetWidth: targetWidth,\r\n                        targetHeight: targetHeight,\r\n                        elemWidth: elemWidth,\r\n                        elemHeight: elemHeight,\r\n                        collisionPosition: collisionPosition,\r\n                        collisionWidth: collisionWidth,\r\n                        collisionHeight: collisionHeight,\r\n                        offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\r\n                        my: options.my,\r\n                        at: options.at,\r\n                        within: within,\r\n                        elem: elem\r\n                    } );\r\n                }\r\n            } );\r\n\r\n            if ( options.using ) {\r\n\r\n                // Adds feedback as second argument to using callback, if present\r\n                using = function( props ) {\r\n                    var left = targetOffset.left - position.left,\r\n                        right = left + targetWidth - elemWidth,\r\n                        top = targetOffset.top - position.top,\r\n                        bottom = top + targetHeight - elemHeight,\r\n                        feedback = {\r\n                            target: {\r\n                                element: target,\r\n                                left: targetOffset.left,\r\n                                top: targetOffset.top,\r\n                                width: targetWidth,\r\n                                height: targetHeight\r\n                            },\r\n                            element: {\r\n                                element: elem,\r\n                                left: position.left,\r\n                                top: position.top,\r\n                                width: elemWidth,\r\n                                height: elemHeight\r\n                            },\r\n                            horizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\r\n                            vertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\r\n                        };\r\n                    if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\r\n                        feedback.horizontal = \"center\";\r\n                    }\r\n                    if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\r\n                        feedback.vertical = \"middle\";\r\n                    }\r\n                    if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\r\n                        feedback.important = \"horizontal\";\r\n                    } else {\r\n                        feedback.important = \"vertical\";\r\n                    }\r\n                    options.using.call( this, props, feedback );\r\n                };\r\n            }\r\n\r\n            geom.pagePosition(elem, langx.extend( position, { using: using } ));\r\n        })(elm);\r\n    }\r\n\r\n    var positions = {\r\n        fit: {\r\n            left: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                    outerWidth = within.width,\r\n                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                    overLeft = withinOffset - collisionPosLeft,\r\n                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\r\n                    newOverRight;\r\n\r\n                // Element is wider than within\r\n                if ( data.collisionWidth > outerWidth ) {\r\n\r\n                    // Element is initially over the left side of within\r\n                    if ( overLeft > 0 && overRight <= 0 ) {\r\n                        newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -\r\n                            withinOffset;\r\n                        position.left += overLeft - newOverRight;\r\n\r\n                    // Element is initially over right side of within\r\n                    } else if ( overRight > 0 && overLeft <= 0 ) {\r\n                        position.left = withinOffset;\r\n\r\n                    // Element is initially over both left and right sides of within\r\n                    } else {\r\n                        if ( overLeft > overRight ) {\r\n                            position.left = withinOffset + outerWidth - data.collisionWidth;\r\n                        } else {\r\n                            position.left = withinOffset;\r\n                        }\r\n                    }\r\n\r\n                // Too far left -> align with left edge\r\n                } else if ( overLeft > 0 ) {\r\n                    position.left += overLeft;\r\n\r\n                // Too far right -> align with right edge\r\n                } else if ( overRight > 0 ) {\r\n                    position.left -= overRight;\r\n\r\n                // Adjust based on position and margin\r\n                } else {\r\n                    position.left = max( position.left - collisionPosLeft, position.left );\r\n                }\r\n            },\r\n            top: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\r\n                    outerHeight = data.within.height,\r\n                    collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                    overTop = withinOffset - collisionPosTop,\r\n                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\r\n                    newOverBottom;\r\n\r\n                // Element is taller than within\r\n                if ( data.collisionHeight > outerHeight ) {\r\n\r\n                    // Element is initially over the top of within\r\n                    if ( overTop > 0 && overBottom <= 0 ) {\r\n                        newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -\r\n                            withinOffset;\r\n                        position.top += overTop - newOverBottom;\r\n\r\n                    // Element is initially over bottom of within\r\n                    } else if ( overBottom > 0 && overTop <= 0 ) {\r\n                        position.top = withinOffset;\r\n\r\n                    // Element is initially over both top and bottom of within\r\n                    } else {\r\n                        if ( overTop > overBottom ) {\r\n                            position.top = withinOffset + outerHeight - data.collisionHeight;\r\n                        } else {\r\n                            position.top = withinOffset;\r\n                        }\r\n                    }\r\n\r\n                // Too far up -> align with top\r\n                } else if ( overTop > 0 ) {\r\n                    position.top += overTop;\r\n\r\n                // Too far down -> align with bottom edge\r\n                } else if ( overBottom > 0 ) {\r\n                    position.top -= overBottom;\r\n\r\n                // Adjust based on position and margin\r\n                } else {\r\n                    position.top = max( position.top - collisionPosTop, position.top );\r\n                }\r\n            }\r\n        },\r\n        flip: {\r\n            left: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.offset.left + within.scrollLeft,\r\n                    outerWidth = within.width,\r\n                    offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                    overLeft = collisionPosLeft - offsetLeft,\r\n                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\r\n                    myOffset = data.my[ 0 ] === \"left\" ?\r\n                        -data.elemWidth :\r\n                        data.my[ 0 ] === \"right\" ?\r\n                            data.elemWidth :\r\n                            0,\r\n                    atOffset = data.at[ 0 ] === \"left\" ?\r\n                        data.targetWidth :\r\n                        data.at[ 0 ] === \"right\" ?\r\n                            -data.targetWidth :\r\n                            0,\r\n                    offset = -2 * data.offset[ 0 ],\r\n                    newOverRight,\r\n                    newOverLeft;\r\n\r\n                if ( overLeft < 0 ) {\r\n                    newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -\r\n                        outerWidth - withinOffset;\r\n                    if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\r\n                        position.left += myOffset + atOffset + offset;\r\n                    }\r\n                } else if ( overRight > 0 ) {\r\n                    newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +\r\n                        atOffset + offset - offsetLeft;\r\n                    if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\r\n                        position.left += myOffset + atOffset + offset;\r\n                    }\r\n                }\r\n            },\r\n            top: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.offset.top + within.scrollTop,\r\n                    outerHeight = within.height,\r\n                    offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\r\n                    collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                    overTop = collisionPosTop - offsetTop,\r\n                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\r\n                    top = data.my[ 1 ] === \"top\",\r\n                    myOffset = top ?\r\n                        -data.elemHeight :\r\n                        data.my[ 1 ] === \"bottom\" ?\r\n                            data.elemHeight :\r\n                            0,\r\n                    atOffset = data.at[ 1 ] === \"top\" ?\r\n                        data.targetHeight :\r\n                        data.at[ 1 ] === \"bottom\" ?\r\n                            -data.targetHeight :\r\n                            0,\r\n                    offset = -2 * data.offset[ 1 ],\r\n                    newOverTop,\r\n                    newOverBottom;\r\n                if ( overTop < 0 ) {\r\n                    newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -\r\n                        outerHeight - withinOffset;\r\n                    if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {\r\n                        position.top += myOffset + atOffset + offset;\r\n                    }\r\n                } else if ( overBottom > 0 ) {\r\n                    newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +\r\n                        offset - offsetTop;\r\n                    if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {\r\n                        position.top += myOffset + atOffset + offset;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        flipfit: {\r\n            left: function() {\r\n                positions.flip.left.apply( this, arguments );\r\n                positions.fit.left.apply( this, arguments );\r\n            },\r\n            top: function() {\r\n                positions.flip.top.apply( this, arguments );\r\n                positions.fit.top.apply( this, arguments );\r\n            }\r\n        }\r\n    };\r\n\r\n    return geom.posit = posit;\r\n});"]}