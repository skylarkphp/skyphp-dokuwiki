{"version":3,"sources":["chunked-stream.js"],"names":["define","streams","Stream","ChunkedStream","inherit","klassName","numChunks","numChunksLoaded","_construct","str","length","bytes","Uint8Array","n","charCodeAt","DecodeStream","prototype","call","this","dict","stream","getMissingChunks","chunks","chunk","loadedChunks","push","getBaseStreams","allChunksLoaded","_","onReceiveData","begin","end","byteLength","assert","chunkSize","set","beginChunk","Math","floor","endChunk","onReceiveInitialData","data","initialDataLength","i","ensureRange","MissingDataException","nextEmptyChunk","hasChunk","getByte","pos","getBytes","strEnd","subarray","peekBytes","getByteRange","skip","reset","start","moveStart","makeSubStream","ChunkedStreamSubstream","Object","create","missingChunks","subStream"],"mappings":"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","file":"../chunked-stream.js","sourcesContent":["define([\r\n    \"./streams\",\r\n    \"./_stream\"\r\n], function(streams,Stream) {\r\n\r\n\r\n    var ChunkedStream = Stream.inherit({\r\n        klassName : \"ChunkedStream\",\r\n\r\n        \"numChunks\": 0,\r\n        \"numChunksLoaded\": 0,\r\n\r\n        _construct : function(str) {\r\n            var length = str.length;\r\n            var bytes = new Uint8Array(length);\r\n            for (var n = 0; n < length; ++n)\r\n                bytes[n] = str.charCodeAt(n);\r\n            DecodeStream.prototype._construct.call(bytes);          \r\n            this.dict = stream.dict;\r\n        },\r\n\r\n        \"numChunks\": function() {\r\n\r\n        },\r\n\r\n\r\n        getMissingChunks: function ChunkedStream_getMissingChunks() {\r\n            var chunks = [];\r\n            for (var chunk = 0, n = this.numChunks; chunk < n; ++chunk) {\r\n                if (!(chunk in this.loadedChunks)) {\r\n                    chunks.push(chunk);\r\n                }\r\n            }\r\n            return chunks;\r\n        },\r\n\r\n        getBaseStreams: function ChunkedStream_getBaseStreams() {\r\n            return [this];\r\n        },\r\n\r\n        allChunksLoaded: function ChunkedStream_allChunksLoaded() {\r\n            var _ = this._;\r\n            return _.numChunksLoaded === _.numChunks;\r\n        },\r\n\r\n        onReceiveData: function(begin, chunk) {\r\n            var end = begin + chunk.byteLength;\r\n\r\n            assert(begin % this.chunkSize === 0, 'Bad begin offset: ' + begin);\r\n            // Using this.length is inaccurate here since this.start can be moved\r\n            // See ChunkedStream.moveStart()\r\n            var length = this.bytes.length;\r\n            assert(end % this.chunkSize === 0 || end === length,\r\n                'Bad end offset: ' + end);\r\n\r\n            this.bytes.set(new Uint8Array(chunk), begin);\r\n            var chunkSize = this.chunkSize;\r\n            var beginChunk = Math.floor(begin / chunkSize);\r\n            var endChunk = Math.floor((end - 1) / chunkSize) + 1;\r\n\r\n            for (var chunk = beginChunk; chunk < endChunk; ++chunk) {\r\n                if (!(chunk in this.loadedChunks)) {\r\n                    this.loadedChunks[chunk] = true;\r\n                    ++this.numChunksLoaded;\r\n                }\r\n            }\r\n        },\r\n\r\n        onReceiveInitialData: function(data) {\r\n            this.bytes.set(data);\r\n            this.initialDataLength = data.length;\r\n            var endChunk = this.end === data.length ?\r\n                this.numChunks : Math.floor(data.length / this.chunkSize);\r\n            for (var i = 0; i < endChunk; i++) {\r\n                this.loadedChunks[i] = true;\r\n                ++this.numChunksLoaded;\r\n            }\r\n        },\r\n\r\n        ensureRange: function ChunkedStream_ensureRange(begin, end) {\r\n            if (begin >= end) {\r\n                return;\r\n            }\r\n\r\n            if (end <= this.initialDataLength) {\r\n                return;\r\n            }\r\n\r\n            var chunkSize = this.chunkSize;\r\n            var beginChunk = Math.floor(begin / chunkSize);\r\n            var endChunk = Math.floor((end - 1) / chunkSize) + 1;\r\n            for (var chunk = beginChunk; chunk < endChunk; ++chunk) {\r\n                if (!(chunk in this.loadedChunks)) {\r\n                    throw new MissingDataException(begin, end);\r\n                }\r\n            }\r\n        },\r\n\r\n        nextEmptyChunk: function ChunkedStream_nextEmptyChunk(beginChunk) {\r\n            for (var chunk = beginChunk, n = this.numChunks; chunk < n; ++chunk) {\r\n                if (!(chunk in this.loadedChunks)) {\r\n                    return chunk;\r\n                }\r\n            }\r\n            // Wrap around to beginning\r\n            for (var chunk = 0; chunk < beginChunk; ++chunk) {\r\n                if (!(chunk in this.loadedChunks)) {\r\n                    return chunk;\r\n                }\r\n            }\r\n            return null;\r\n        },\r\n\r\n        hasChunk: function ChunkedStream_hasChunk(chunk) {\r\n            return chunk in this._.loadedChunks;\r\n        },\r\n\r\n        getByte: function ChunkedStream_getByte() {\r\n            var pos = this.pos;\r\n            if (pos >= this.end) {\r\n                return -1;\r\n            }\r\n            this.ensureRange(pos, pos + 1);\r\n            return this.bytes[this.pos++];\r\n        },\r\n\r\n        // returns subarray of original buffer\r\n        // should only be read\r\n        getBytes: function ChunkedStream_getBytes(length) {\r\n            var bytes = this.bytes;\r\n            var pos = this.pos;\r\n            var strEnd = this.end;\r\n\r\n            if (!length) {\r\n                this.ensureRange(pos, strEnd);\r\n                return bytes.subarray(pos, strEnd);\r\n            }\r\n\r\n            var end = pos + length;\r\n            if (end > strEnd)\r\n                end = strEnd;\r\n            this.ensureRange(pos, end);\r\n\r\n            this.pos = end;\r\n            return bytes.subarray(pos, end);\r\n        },\r\n\r\n        peekBytes: function ChunkedStream_peekBytes(length) {\r\n            var bytes = this.getBytes(length);\r\n            this.pos -= bytes.length;\r\n            return bytes;\r\n        },\r\n\r\n        getByteRange: function ChunkedStream_getBytes(begin, end) {\r\n            this.ensureRange(begin, end);\r\n            return this.bytes.subarray(begin, end);\r\n        },\r\n\r\n        skip: function ChunkedStream_skip(n) {\r\n            if (!n)\r\n                n = 1;\r\n            this.pos += n;\r\n        },\r\n\r\n        reset: function ChunkedStream_reset() {\r\n            this.pos = this.start;\r\n        },\r\n\r\n        moveStart: function ChunkedStream_moveStart() {\r\n            this.start = this.pos;\r\n        },\r\n\r\n        makeSubStream: function ChunkedStream_makeSubStream(start, length, dict) {\r\n            function ChunkedStreamSubstream() {}\r\n            ChunkedStreamSubstream.prototype = Object.create(this);\r\n            ChunkedStreamSubstream.prototype.getMissingChunks = function() {\r\n                var chunkSize = this.chunkSize;\r\n                var beginChunk = Math.floor(this.start / chunkSize);\r\n                var endChunk = Math.floor((this.end - 1) / chunkSize) + 1;\r\n                var missingChunks = [];\r\n                for (var chunk = beginChunk; chunk < endChunk; ++chunk) {\r\n                    if (!(chunk in this.loadedChunks)) {\r\n                        missingChunks.push(chunk);\r\n                    }\r\n                }\r\n                return missingChunks;\r\n            };\r\n            var subStream = new ChunkedStreamSubstream();\r\n            subStream.pos = subStream.start = start;\r\n            subStream.end = start + length || this.end;\r\n            subStream.dict = dict;\r\n            return subStream;\r\n        }\r\n    });\r\n\r\n    return streams.ChunkedStream = ChunkedStream;\r\n\r\n});\r\n"]}