{"version":3,"sources":["predictor-stream.js"],"names":["define","streams","DecodeStream","PredictorStream","inherit","klassName","_construct","str","maybeLength","params","primitives","isDict","predictor","this","get","Error","readBlock","readBlockTiff","readBlockPng","dict","colors","bits","columns","pixBytes","rowBytes","call","bufferLength","buffer","ensureBuffer","rawBytes","getBytes","eof","length","i","inbuf","outbuf","inbits","outbits","pos","c","bytesPerPixel","sum","compArray","Uint8Array","bitMask","j","k","kk","getByte","prevRow","subarray","up","upLeft","left","p","pa","pb","pc"],"mappings":"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","file":"../predictor-stream.js","sourcesContent":["define([\r\n    \"./streams\",\r\n    \"./decode-stream\"\r\n], function(streams, DecodeStream) {\r\n\r\n\r\n    var PredictorStream = DecodeStream.inherit({\r\n        klassName : \"PredictorStream\",\r\n\r\n        _construct : function (str, maybeLength, params) {\r\n            if (!primitives.isDict(params)) {\r\n                return str;\r\n            }\r\n            var predictor = this.predictor = params.get('Predictor') || 1;\r\n            if (predictor <= 1) {\r\n                return str;\r\n            }\r\n            if (predictor !== 2 && (predictor < 10 || predictor > 15)) {\r\n                //throw new util.FormatError(`Unsupported predictor: ${ predictor }`);\r\n                throw new Error(`Unsupported predictor: ${ predictor }`);\r\n            }\r\n            if (predictor === 2) {\r\n                this.readBlock = this.readBlockTiff;\r\n            } else {\r\n                this.readBlock = this.readBlockPng;\r\n            }\r\n            this.str = str;\r\n            this.dict = str.dict;\r\n            var colors = this.colors = params.get('Colors') || 1;\r\n            var bits = this.bits = params.get('BitsPerComponent') || 8;\r\n            var columns = this.columns = params.get('Columns') || 1;\r\n            this.pixBytes = colors * bits + 7 >> 3;\r\n            this.rowBytes = columns * colors * bits + 7 >> 3;\r\n            DecodeStream.call(this, maybeLength);\r\n            return this;\r\n        },\r\n\r\n        readBlockTiff : function predictorStreamReadBlockTiff() {\r\n            var rowBytes = this.rowBytes;\r\n            var bufferLength = this.bufferLength;\r\n            var buffer = this.ensureBuffer(bufferLength + rowBytes);\r\n            var bits = this.bits;\r\n            var colors = this.colors;\r\n            var rawBytes = this.str.getBytes(rowBytes);\r\n            this.eof = !rawBytes.length;\r\n            if (this.eof) {\r\n                return;\r\n            }\r\n            var inbuf = 0, outbuf = 0;\r\n            var inbits = 0, outbits = 0;\r\n            var pos = bufferLength;\r\n            var i;\r\n            if (bits === 1 && colors === 1) {\r\n                for (i = 0; i < rowBytes; ++i) {\r\n                    var c = rawBytes[i] ^ inbuf;\r\n                    c ^= c >> 1;\r\n                    c ^= c >> 2;\r\n                    c ^= c >> 4;\r\n                    inbuf = (c & 1) << 7;\r\n                    buffer[pos++] = c;\r\n                }\r\n            } else if (bits === 8) {\r\n                for (i = 0; i < colors; ++i) {\r\n                    buffer[pos++] = rawBytes[i];\r\n                }\r\n                for (; i < rowBytes; ++i) {\r\n                    buffer[pos] = buffer[pos - colors] + rawBytes[i];\r\n                    pos++;\r\n                }\r\n            } else if (bits === 16) {\r\n                var bytesPerPixel = colors * 2;\r\n                for (i = 0; i < bytesPerPixel; ++i) {\r\n                    buffer[pos++] = rawBytes[i];\r\n                }\r\n                for (; i < rowBytes; i += 2) {\r\n                    var sum = ((rawBytes[i] & 255) << 8) + (rawBytes[i + 1] & 255) + ((buffer[pos - bytesPerPixel] & 255) << 8) + (buffer[pos - bytesPerPixel + 1] & 255);\r\n                    buffer[pos++] = sum >> 8 & 255;\r\n                    buffer[pos++] = sum & 255;\r\n                }\r\n            } else {\r\n                var compArray = new Uint8Array(colors + 1);\r\n                var bitMask = (1 << bits) - 1;\r\n                var j = 0, k = bufferLength;\r\n                var columns = this.columns;\r\n                for (i = 0; i < columns; ++i) {\r\n                    for (var kk = 0; kk < colors; ++kk) {\r\n                        if (inbits < bits) {\r\n                            inbuf = inbuf << 8 | rawBytes[j++] & 255;\r\n                            inbits += 8;\r\n                        }\r\n                        compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;\r\n                        inbits -= bits;\r\n                        outbuf = outbuf << bits | compArray[kk];\r\n                        outbits += bits;\r\n                        if (outbits >= 8) {\r\n                            buffer[k++] = outbuf >> outbits - 8 & 255;\r\n                            outbits -= 8;\r\n                        }\r\n                    }\r\n                }\r\n                if (outbits > 0) {\r\n                    buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);\r\n                }\r\n            }\r\n            this.bufferLength += rowBytes;\r\n        },\r\n\r\n        readBlockPng : function predictorStreamReadBlockPng() {\r\n            var rowBytes = this.rowBytes;\r\n            var pixBytes = this.pixBytes;\r\n            var predictor = this.str.getByte();\r\n            var rawBytes = this.str.getBytes(rowBytes);\r\n            this.eof = !rawBytes.length;\r\n            if (this.eof) {\r\n                return;\r\n            }\r\n            var bufferLength = this.bufferLength;\r\n            var buffer = this.ensureBuffer(bufferLength + rowBytes);\r\n            var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);\r\n            if (prevRow.length === 0) {\r\n                prevRow = new Uint8Array(rowBytes);\r\n            }\r\n            var i, j = bufferLength, up, c;\r\n            switch (predictor) {\r\n            case 0:\r\n                for (i = 0; i < rowBytes; ++i) {\r\n                    buffer[j++] = rawBytes[i];\r\n                }\r\n                break;\r\n            case 1:\r\n                for (i = 0; i < pixBytes; ++i) {\r\n                    buffer[j++] = rawBytes[i];\r\n                }\r\n                for (; i < rowBytes; ++i) {\r\n                    buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 255;\r\n                    j++;\r\n                }\r\n                break;\r\n            case 2:\r\n                for (i = 0; i < rowBytes; ++i) {\r\n                    buffer[j++] = prevRow[i] + rawBytes[i] & 255;\r\n                }\r\n                break;\r\n            case 3:\r\n                for (i = 0; i < pixBytes; ++i) {\r\n                    buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];\r\n                }\r\n                for (; i < rowBytes; ++i) {\r\n                    buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 255;\r\n                    j++;\r\n                }\r\n                break;\r\n            case 4:\r\n                for (i = 0; i < pixBytes; ++i) {\r\n                    up = prevRow[i];\r\n                    c = rawBytes[i];\r\n                    buffer[j++] = up + c;\r\n                }\r\n                for (; i < rowBytes; ++i) {\r\n                    up = prevRow[i];\r\n                    var upLeft = prevRow[i - pixBytes];\r\n                    var left = buffer[j - pixBytes];\r\n                    var p = left + up - upLeft;\r\n                    var pa = p - left;\r\n                    if (pa < 0) {\r\n                        pa = -pa;\r\n                    }\r\n                    var pb = p - up;\r\n                    if (pb < 0) {\r\n                        pb = -pb;\r\n                    }\r\n                    var pc = p - upLeft;\r\n                    if (pc < 0) {\r\n                        pc = -pc;\r\n                    }\r\n                    c = rawBytes[i];\r\n                    if (pa <= pb && pa <= pc) {\r\n                        buffer[j++] = left + c;\r\n                    } else if (pb <= pc) {\r\n                        buffer[j++] = up + c;\r\n                    } else {\r\n                        buffer[j++] = upLeft + c;\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                //throw new util.FormatError(`Unsupported predictor: ${ predictor }`);\r\n                throw new Error(`Unsupported predictor: ${ predictor }`);\r\n            }\r\n            this.bufferLength += rowBytes;\r\n        }\r\n    });\r\n\r\n    return streams.PredictorStream = PredictorStream;\r\n});\r\n"]}