{"version":3,"sources":["skylark-langx-aspect.js"],"names":["define","skylark","undefined","nextId","aspect","type","target","methodName","advice","receiveArguments","dispatcher","existing","executionId","args","arguments","before","apply","this","next","around","results","after","id","newResults","call","signal","previous","advised","remove","advise","attach","main"],"mappings":";;;;;;;+zBAAAA,EAAA,+BACA,oBACA,SAAAC,GAEA,IAAAC,EAAAC,EAAA,EAqEA,SAAAC,EAAAC,GACA,OAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAC,EAAAL,EAAAC,GACAI,GAAAA,EAAAL,QAAAA,IAEAA,EAAAC,GAAAG,EAAA,WA5EA,IA6EA,IAAAE,EAAAT,EA/EAU,EAAAC,UACAC,EAAAL,EAAAK,OACAA,GACAF,EAAAE,EAAAP,OAAAQ,MAAAC,KAAAJ,IAAAA,EACAE,EAAAA,EAAAG,KAGA,GAAAR,EAAAS,OACA,IAAAC,EAAAV,EAAAS,OAAAX,OAAAS,KAAAJ,GAIA,IADA,IAAAQ,EAAAX,EAAAW,MACAA,GAAAA,EAAAC,GAAAV,GAAA,CACA,GAAAS,EAAAZ,iBAAA,CACA,IAAAc,EAAAF,EAAAb,OAAAQ,MAAAC,KAAAJ,GAEAO,EAAAG,IAAArB,EAAAkB,EAAAG,OAEAH,EAAAC,EAAAb,OAAAgB,KAAAP,KAAAG,EAAAP,GAEAQ,EAAAA,EAAAH,KAEA,OAAAE,GAEAT,IACAD,EAAAS,QAAAX,OAAA,SAAAF,EAAAO,GACA,OAAAF,EAAAK,MAAAV,EAAAO,MAGAH,EAAAJ,OAAAA,GAEA,IAAAc,EA1BA,SAAAV,EAAAL,EAAAG,EAAAC,GACA,IAEAgB,EAFAC,EAAAhB,EAAAL,GACAc,EAAA,UAAAd,EAEA,GAAAc,EAAA,CACA,IAAAQ,EAAAnB,EAAA,WACA,OAAAkB,EAAAlB,OAAAS,KAAAH,aAEAW,GACAG,OAAA,WACAD,IACAA,EAAAjB,EAAAF,EAAA,OAGAA,OAAA,SAAAF,EAAAO,GACA,OAAAc,EACAA,EAAAX,MAAAV,EAAAO,GACAa,EAAAlB,OAAAF,EAAAO,UAKAY,GACAG,OAAA,WACA,GAAAH,EAAAjB,OAAA,CACA,IAAAkB,EAAAD,EAAAC,SACAR,EAAAO,EAAAP,KACAA,GAAAQ,GAGAA,EACAA,EAAAR,KAAAA,EAEAR,EAAAL,GAAAa,EAEAA,IACAA,EAAAQ,SAAAA,WARAhB,EAAAL,GAaAK,EAAAF,EAAAiB,EAAAjB,OAAA,OAGAc,GAAAnB,IACAK,OAAAA,EACAC,iBAAAA,GAGA,GAAAiB,IAAAP,EACA,GAAA,SAAAd,EAAA,CAGA,KAAAqB,EAAAR,OAAAQ,EAAAA,EAAAR,QACAQ,EAAAR,KAAAO,EACAA,EAAAC,SAAAA,MACA,UAAArB,IAEAK,EAAAL,GAAAoB,EACAA,EAAAP,KAAAQ,EACAA,EAAAA,SAAAD,QAIAf,EAAAL,GAAAoB,EAEA,OAAAA,EAxCAI,CAAAnB,GAAAC,EAAAN,EAAAG,EAAAC,GAEA,OADAD,EAAA,KACAY,GAIA,OAAAnB,EAAA6B,OAAA,gBACAT,MAAAjB,EAAA,SAEAe,OAAAf,EAAA,UAEAW,OAAAX,EAAA,cAGAJ,EAAA,6BACA,YACA,SAAAI,GACA,OAAAA,IAEAJ,EAAA,wBAAA,6BAAA,SAAA+B,GAAA,OAAAA","file":"../skylark-langx-aspect.js","sourcesContent":["define('skylark-langx-aspect/aspect',[\r\n    \"skylark-langx-ns\"\r\n],function(skylark){\r\n\r\n  var undefined, nextId = 0;\r\n    function advise(dispatcher, type, advice, receiveArguments){\r\n        var previous = dispatcher[type];\r\n        var around = type == \"around\";\r\n        var signal;\r\n        if(around){\r\n            var advised = advice(function(){\r\n                return previous.advice(this, arguments);\r\n            });\r\n            signal = {\r\n                remove: function(){\r\n                    if(advised){\r\n                        advised = dispatcher = advice = null;\r\n                    }\r\n                },\r\n                advice: function(target, args){\r\n                    return advised ?\r\n                        advised.apply(target, args) :  // called the advised function\r\n                        previous.advice(target, args); // cancelled, skip to next one\r\n                }\r\n            };\r\n        }else{\r\n            // create the remove handler\r\n            signal = {\r\n                remove: function(){\r\n                    if(signal.advice){\r\n                        var previous = signal.previous;\r\n                        var next = signal.next;\r\n                        if(!next && !previous){\r\n                            delete dispatcher[type];\r\n                        }else{\r\n                            if(previous){\r\n                                previous.next = next;\r\n                            }else{\r\n                                dispatcher[type] = next;\r\n                            }\r\n                            if(next){\r\n                                next.previous = previous;\r\n                            }\r\n                        }\r\n\r\n                        // remove the advice to signal that this signal has been removed\r\n                        dispatcher = advice = signal.advice = null;\r\n                    }\r\n                },\r\n                id: nextId++,\r\n                advice: advice,\r\n                receiveArguments: receiveArguments\r\n            };\r\n        }\r\n        if(previous && !around){\r\n            if(type == \"after\"){\r\n                // add the listener to the end of the list\r\n                // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\r\n                while(previous.next && (previous = previous.next)){}\r\n                previous.next = signal;\r\n                signal.previous = previous;\r\n            }else if(type == \"before\"){\r\n                // add to beginning\r\n                dispatcher[type] = signal;\r\n                signal.next = previous;\r\n                previous.previous = signal;\r\n            }\r\n        }else{\r\n            // around or first one just replaces\r\n            dispatcher[type] = signal;\r\n        }\r\n        return signal;\r\n    }\r\n    function aspect(type){\r\n        return function(target, methodName, advice, receiveArguments){\r\n            var existing = target[methodName], dispatcher;\r\n            if(!existing || existing.target != target){\r\n                // no dispatcher in place\r\n                target[methodName] = dispatcher = function(){\r\n                    var executionId = nextId;\r\n                    // before advice\r\n                    var args = arguments;\r\n                    var before = dispatcher.before;\r\n                    while(before){\r\n                        args = before.advice.apply(this, args) || args;\r\n                        before = before.next;\r\n                    }\r\n                    // around advice\r\n                    if(dispatcher.around){\r\n                        var results = dispatcher.around.advice(this, args);\r\n                    }\r\n                    // after advice\r\n                    var after = dispatcher.after;\r\n                    while(after && after.id < executionId){\r\n                        if(after.receiveArguments){\r\n                            var newResults = after.advice.apply(this, args);\r\n                            // change the return value only if a new value was returned\r\n                            results = newResults === undefined ? results : newResults;\r\n                        }else{\r\n                            results = after.advice.call(this, results, args);\r\n                        }\r\n                        after = after.next;\r\n                    }\r\n                    return results;\r\n                };\r\n                if(existing){\r\n                    dispatcher.around = {advice: function(target, args){\r\n                        return existing.apply(target, args);\r\n                    }};\r\n                }\r\n                dispatcher.target = target;\r\n            }\r\n            var results = advise((dispatcher || existing), type, advice, receiveArguments);\r\n            advice = null;\r\n            return results;\r\n        };\r\n    }\r\n\r\n    return skylark.attach(\"langx.aspect\",{\r\n        after: aspect(\"after\"),\r\n \r\n        around: aspect(\"around\"),\r\n        \r\n        before: aspect(\"before\")\r\n    });\r\n});\ndefine('skylark-langx-aspect/main',[\r\n\t\"./aspect\"\r\n],function(aspect){\r\n\treturn aspect;\r\n});\ndefine('skylark-langx-aspect', ['skylark-langx-aspect/main'], function (main) { return main; });\n\n"]}