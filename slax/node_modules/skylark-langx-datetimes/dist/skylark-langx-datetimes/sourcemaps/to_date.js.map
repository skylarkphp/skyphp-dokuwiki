{"version":3,"sources":["to_date.js"],"names":["define","types","datetimes","pdfDateStringRegex","toDate","input","isString","RegExp","matches","exec","year","parseInt","month","day","hour","minute","second","universalTimeRelation","offsetHour","offsetMinute","Date","UTC"],"mappings":";;;;;;;AAAAA,QACC,sBACG,eACF,SAASC,EAAMC,GAyBhB,IAAIC,EAmEH,OAAOD,EAAUE,OAjElB,SAAgBC,GACb,IAAKA,IAAUJ,EAAMK,SAASD,GAC5B,OAAO,KAIJF,IACHA,EAAqB,IAAII,OACvB,6FAkBJ,MAAMC,EAAUL,EAAmBM,KAAKJ,GACxC,IAAKG,EACH,OAAO,KAKT,MAAME,EAAOC,SAASH,EAAQ,GAAI,IAClC,IAAII,EAAQD,SAASH,EAAQ,GAAI,IACjCI,EAAQA,GAAS,GAAKA,GAAS,GAAKA,EAAQ,EAAI,EAChD,IAAIC,EAAMF,SAASH,EAAQ,GAAI,IAC/BK,EAAMA,GAAO,GAAKA,GAAO,GAAKA,EAAM,EACpC,IAAIC,EAAOH,SAASH,EAAQ,GAAI,IAChCM,EAAOA,GAAQ,GAAKA,GAAQ,GAAKA,EAAO,EACxC,IAAIC,EAASJ,SAASH,EAAQ,GAAI,IAClCO,EAASA,GAAU,GAAKA,GAAU,GAAKA,EAAS,EAChD,IAAIC,EAASL,SAASH,EAAQ,GAAI,IAClCQ,EAASA,GAAU,GAAKA,GAAU,GAAKA,EAAS,EAChD,MAAMC,EAAwBT,EAAQ,IAAM,IAC5C,IAAIU,EAAaP,SAASH,EAAQ,GAAI,IACtCU,EAAaA,GAAc,GAAKA,GAAc,GAAKA,EAAa,EAChE,IAAIC,EAAeR,SAASH,EAAQ,GAAI,KAAO,EAe/C,OAdAW,EAAeA,GAAgB,GAAKA,GAAgB,GAAKA,EAAe,EAM1C,MAA1BF,GACFH,GAAQI,EACRH,GAAUI,GACyB,MAA1BF,IACTH,GAAQI,EACRH,GAAUI,GAGL,IAAIC,KAAKA,KAAKC,IAAIX,EAAME,EAAOC,EAAKC,EAAMC,EAAQC","file":"../to_date.js","sourcesContent":["define([\r\n\t\"skylark-langx-types\",\r\n    \"./datetimes\"\r\n],function(types,datetimes){\r\n\r\n//original :pdf.js-2.7.750/src/display/display_utils.js\r\n\r\n  /**\r\nclass PDFDateString {\r\n   * Convert a PDF date string to a JavaScript `Date` object.\r\n   *\r\n   * The PDF date string format is described in section 7.9.4 of the official\r\n   * PDF 32000-1:2008 specification. However, in the PDF 1.7 reference (sixth\r\n   * edition) Adobe describes the same format including a trailing apostrophe.\r\n   * This syntax in incorrect, but Adobe Acrobat creates PDF files that contain\r\n   * them. We ignore all apostrophes as they are not necessary for date parsing.\r\n   *\r\n   * Moreover, Adobe Acrobat doesn't handle changing the date to universal time\r\n   * and doesn't use the user's time zone (effectively ignoring the HH' and mm'\r\n   * parts of the date string).\r\n   *\r\n   * @param {string} input\r\n   * @returns {Date|null}\r\n   *\r\n  static toDateObject(input) {\r\n   **/\r\n\r\n\r\n\tlet pdfDateStringRegex;\r\n\r\n\tfunction toDate(input) {\r\n    if (!input || !types.isString(input)) {\r\n      return null;\r\n    }\r\n\r\n    // Lazily initialize the regular expression.\r\n    if (!pdfDateStringRegex) {\r\n      pdfDateStringRegex = new RegExp(\r\n        \"^D:\" + // Prefix (required)\r\n          \"(\\\\d{4})\" + // Year (required)\r\n          \"(\\\\d{2})?\" + // Month (optional)\r\n          \"(\\\\d{2})?\" + // Day (optional)\r\n          \"(\\\\d{2})?\" + // Hour (optional)\r\n          \"(\\\\d{2})?\" + // Minute (optional)\r\n          \"(\\\\d{2})?\" + // Second (optional)\r\n          \"([Z|+|-])?\" + // Universal time relation (optional)\r\n          \"(\\\\d{2})?\" + // Offset hour (optional)\r\n          \"'?\" + // Splitting apostrophe (optional)\r\n          \"(\\\\d{2})?\" + // Offset minute (optional)\r\n          \"'?\" // Trailing apostrophe (optional)\r\n      );\r\n    }\r\n\r\n    // Optional fields that don't satisfy the requirements from the regular\r\n    // expression (such as incorrect digit counts or numbers that are out of\r\n    // range) will fall back the defaults from the specification.\r\n    const matches = pdfDateStringRegex.exec(input);\r\n    if (!matches) {\r\n      return null;\r\n    }\r\n\r\n    // JavaScript's `Date` object expects the month to be between 0 and 11\r\n    // instead of 1 and 12, so we have to correct for that.\r\n    const year = parseInt(matches[1], 10);\r\n    let month = parseInt(matches[2], 10);\r\n    month = month >= 1 && month <= 12 ? month - 1 : 0;\r\n    let day = parseInt(matches[3], 10);\r\n    day = day >= 1 && day <= 31 ? day : 1;\r\n    let hour = parseInt(matches[4], 10);\r\n    hour = hour >= 0 && hour <= 23 ? hour : 0;\r\n    let minute = parseInt(matches[5], 10);\r\n    minute = minute >= 0 && minute <= 59 ? minute : 0;\r\n    let second = parseInt(matches[6], 10);\r\n    second = second >= 0 && second <= 59 ? second : 0;\r\n    const universalTimeRelation = matches[7] || \"Z\";\r\n    let offsetHour = parseInt(matches[8], 10);\r\n    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\r\n    let offsetMinute = parseInt(matches[9], 10) || 0;\r\n    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\r\n\r\n    // Universal time relation 'Z' means that the local time is equal to the\r\n    // universal time, whereas the relations '+'/'-' indicate that the local\r\n    // time is later respectively earlier than the universal time. Every date\r\n    // is normalized to universal time.\r\n    if (universalTimeRelation === \"-\") {\r\n      hour += offsetHour;\r\n      minute += offsetMinute;\r\n    } else if (universalTimeRelation === \"+\") {\r\n      hour -= offsetHour;\r\n      minute -= offsetMinute;\r\n    }\r\n\r\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\r\n  }\r\n\r\n  return datetimes.toDate = toDate;\r\n\r\n});"]}