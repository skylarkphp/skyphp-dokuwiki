{"version":3,"sources":["plane.js"],"names":["define","klass","numerics","Matrix3","Vector3","_vector1","_vector2","_normalMatrix","Plane","klassName","set","normal","constant","this","copy","setComponents","x","y","z","w","setFromNormalAndCoplanarPoint","point","dot","setFromCoplanarPoints","a","b","c","subVectors","cross","normalize","clone","constructor","plane","inverseNormalLength","length","multiplyScalar","negate","distanceToPoint","distanceToSphere","sphere","center","radius","projectPoint","target","undefined","console","warn","add","intersectLine","line","direction","delta","denominator","start","t","intersectsLine","startSign","endSign","end","intersectsBox","box","intersectsPlane","intersectsSphere","coplanarPoint","applyMatrix4","matrix","optionalNormalMatrix","normalMatrix","getNormalMatrix","referencePoint","applyMatrix3","translate","offset","equals","_construct"],"mappings":"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","file":"../plane.js","sourcesContent":["define([\r\n\t\"skylark-langx-klass\",\r\n\t\"./numerics\",\r\n\t\"./matrix3\",\r\n\t\"./vector3\"\r\n] ,function(\r\n\tklass,\r\n\tnumerics,\r\n\tMatrix3,\r\n\tVector3\r\n) {\r\n\r\n\r\n\tvar _vector1 = new Vector3();\r\n\tvar _vector2 = new Vector3();\r\n\tvar _normalMatrix = new Matrix3();\r\n\r\n\tvar Plane = klass({\r\n\t\t\"klassName\" : \"Plane\",\r\n\r\n\t\tset: function ( normal, constant ) {\r\n\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = constant;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetComponents: function ( x, y, z, w ) {\r\n\r\n\t\t\tthis.normal.set( x, y, z );\r\n\t\t\tthis.constant = w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = - point.dot( this.normal );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromCoplanarPoints: function ( a, b, c ) {\r\n\r\n\t\t\tvar normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\r\n\r\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclone: function () {\r\n\r\n\t\t\treturn new this.constructor().copy( this );\r\n\r\n\t\t},\r\n\r\n\t\tcopy: function ( plane ) {\r\n\r\n\t\t\tthis.normal.copy( plane.normal );\r\n\t\t\tthis.constant = plane.constant;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tnormalize: function () {\r\n\r\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\t\tthis.constant *= inverseNormalLength;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tnegate: function () {\r\n\r\n\t\t\tthis.constant *= - 1;\r\n\t\t\tthis.normal.negate();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tdistanceToPoint: function ( point ) {\r\n\r\n\t\t\treturn this.normal.dot( point ) + this.constant;\r\n\r\n\t\t},\r\n\r\n\t\tdistanceToSphere: function ( sphere ) {\r\n\r\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n\t\t},\r\n\r\n\t\tprojectPoint: function ( point, target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsPlane: .projectPoint() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\r\n\r\n\t\t},\r\n\r\n\t\tintersectLine: function ( line, target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsPlane: .intersectLine() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar direction = line.delta( _vector1 );\r\n\r\n\t\t\tvar denominator = this.normal.dot( direction );\r\n\r\n\t\t\tif ( denominator === 0 ) {\r\n\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\r\n\r\n\t\t\t\t\treturn target.copy( line.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n\t\t\tif ( t < 0 || t > 1 ) {\r\n\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n\t\t},\r\n\r\n\t\tintersectsLine: function ( line ) {\r\n\r\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n\t\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\t\tvar endSign = this.distanceToPoint( line.end );\r\n\r\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n\t\t},\r\n\r\n\t\tintersectsBox: function ( box ) {\r\n\r\n\t\t\treturn box.intersectsPlane( this );\r\n\r\n\t\t},\r\n\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\t\treturn sphere.intersectsPlane( this );\r\n\r\n\t\t},\r\n\r\n\t\tcoplanarPoint: function ( target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsPlane: .coplanarPoint() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n\t\t},\r\n\r\n\t\tapplyMatrix4: function ( matrix, optionalNormalMatrix ) {\r\n\r\n\t\t\tvar normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\r\n\r\n\t\t\tvar referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\r\n\r\n\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\tthis.constant = - referencePoint.dot( normal );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\ttranslate: function ( offset ) {\r\n\r\n\t\t\tthis.constant -= offset.dot( this.normal );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tequals: function ( plane ) {\r\n\r\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\r\n\r\n\t\t},\r\n\r\n\r\n\t\t\"_construct\" : function( normal, constant ) {\r\n\r\n\t\t\t// normal is assumed to be normalized\r\n\r\n\t\t\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\r\n\t\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\r\n\t\t}\r\n\r\n\t});\r\n\r\n\r\n\treturn numerics.Plane = Plane;\r\n});"]}