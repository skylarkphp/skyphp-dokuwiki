{"version":3,"sources":["is-equal.js"],"names":["define","types","objects","eq","deepEq","isFunction","SymbolProto","Symbol","prototype","a","b","aStack","bStack","type","className","toString","call","valueOf","areArrays","aCtor","constructor","bCtor","length","push","key","keys","Object","undefined","pop","isEqual"],"mappings":";;;;;;;AAAAA,QACC,sBACA,aACC,SAASC,EAAMC,GACb,IAIIC,EAAIC,EAJJC,EAAaJ,EAAMI,WAKnBC,EAAgC,oBAAXC,OAAyBA,OAAOC,UAAY,KA+GrE,OA7GAL,EAAK,SAASM,EAAGC,EAAGC,EAAQC,GAGxB,GAAIH,IAAMC,EAAG,OAAa,IAAND,GAAW,EAAIA,GAAM,EAAIC,EAE7C,GAAS,MAALD,GAAkB,MAALC,EAAW,OAAO,EAEnC,GAAID,GAAMA,EAAG,OAAOC,GAAMA,EAE1B,IAAIG,SAAcJ,EAClB,OAAa,aAATI,GAAgC,WAATA,GAAiC,iBAALH,IAChDN,EAAOK,EAAGC,EAAGC,EAAQC,IAIhCR,EAAS,SAASK,EAAGC,EAAGC,EAAQC,GAK5B,IAAIE,EAAYC,SAASC,KAAKP,GAC9B,GAAIK,IAAcC,SAASC,KAAKN,GAAI,OAAO,EAC3C,OAAQI,GAEJ,IAAK,kBAEL,IAAK,kBAGD,MAAO,GAAKL,GAAM,GAAKC,EAC3B,IAAK,kBAGD,OAAKD,IAAOA,GAAWC,IAAOA,EAEhB,IAAND,EAAU,GAAKA,GAAM,EAAIC,GAAKD,IAAOC,EACjD,IAAK,gBACL,IAAK,mBAID,OAAQD,IAAOC,EACnB,IAAK,kBACD,OAAOJ,EAAYW,QAAQD,KAAKP,KAAOH,EAAYW,QAAQD,KAAKN,GAGxE,IAAIQ,EAA0B,mBAAdJ,EAChB,IAAKI,EAAW,CACZ,GAAgB,iBAALT,GAA6B,iBAALC,EAAe,OAAO,EAGzD,IAAIS,EAAQV,EAAEW,YAAaC,EAAQX,EAAEU,YACrC,GAAID,IAAUE,KAAWhB,EAAWc,IAAUA,aAAiBA,GAC5Cd,EAAWgB,IAAUA,aAAiBA,IACvC,gBAAiBZ,GAAK,gBAAiBC,EACrD,OAAO,EAQfC,EAASA,MACTC,EAASA,MAET,IADA,IAAIU,EAASX,EAAOW,OACbA,KAGH,GAAIX,EAAOW,KAAYb,EAAG,OAAOG,EAAOU,KAAYZ,EAQxD,GAJAC,EAAOY,KAAKd,GACZG,EAAOW,KAAKb,GAGRQ,EAAW,CAGX,IADAI,EAASb,EAAEa,UACIZ,EAAEY,OAAQ,OAAO,EAEhC,KAAOA,KACH,IAAKnB,EAAGM,EAAEa,GAASZ,EAAEY,GAASX,EAAQC,GAAS,OAAO,MAEvD,CAEH,IAA2BY,EAAvBC,EAAOC,OAAOD,KAAKhB,GAGvB,GAFAa,EAASG,EAAKH,OAEVI,OAAOD,KAAKf,GAAGY,SAAWA,EAAQ,OAAO,EAC7C,KAAOA,KAGH,QAAeK,IAATjB,EADNc,EAAMC,EAAKH,MACiBnB,EAAGM,EAAEe,GAAMd,EAAEc,GAAMb,EAAQC,GAAU,OAAO,EAMhF,OAFAD,EAAOiB,MACPhB,EAAOgB,OACA,GASJ1B,EAAQ2B,QAJf,SAAiBpB,EAAGC,GAChB,OAAOP,EAAGM,EAAGC","file":"../is-equal.js","sourcesContent":["define([\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n    var isFunction = types.isFunction;\r\n\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    var eq, deepEq;\r\n    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\r\n\r\n    eq = function(a, b, aStack, bStack) {\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) return a !== 0 || 1 / a === 1 / b;\r\n        // `null` or `undefined` only equal to itself (strict comparison).\r\n        if (a == null || b == null) return false;\r\n        // `NaN`s are equivalent, but non-reflexive.\r\n        if (a !== a) return b !== b;\r\n        // Exhaust primitive checks\r\n        var type = typeof a;\r\n        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\r\n        return deepEq(a, b, aStack, bStack);\r\n    };\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    deepEq = function(a, b, aStack, bStack) {\r\n        // Unwrap any wrapped objects.\r\n        //if (a instanceof _) a = a._wrapped;\r\n        //if (b instanceof _) b = b._wrapped;\r\n        // Compare `[[Class]]` names.\r\n        var className = toString.call(a);\r\n        if (className !== toString.call(b)) return false;\r\n        switch (className) {\r\n            // Strings, numbers, regular expressions, dates, and booleans are compared by value.\r\n            case '[object RegExp]':\r\n            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return '' + a === '' + b;\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive.\r\n                // Object(NaN) is equivalent to NaN.\r\n                if (+a !== +a) return +b !== +b;\r\n                // An `egal` comparison is performed for other numeric values.\r\n                return +a === 0 ? 1 / +a === 1 / b : +a === +b;\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a === +b;\r\n            case '[object Symbol]':\r\n                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\r\n        }\r\n\r\n        var areArrays = className === '[object Array]';\r\n        if (!areArrays) {\r\n            if (typeof a != 'object' || typeof b != 'object') return false;\r\n            // Objects with different constructors are not equivalent, but `Object`s or `Array`s\r\n            // from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&\r\n                               isFunction(bCtor) && bCtor instanceof bCtor)\r\n                          && ('constructor' in a && 'constructor' in b)) {\r\n                return false;\r\n            }\r\n        }\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n\r\n        // Initializing stack of traversed objects.\r\n        // It's done here since we only need them for objects and arrays comparison.\r\n        aStack = aStack || [];\r\n        bStack = bStack || [];\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] === a) return bStack[length] === b;\r\n        }\r\n\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n\r\n        // Recursively compare objects and arrays.\r\n        if (areArrays) {\r\n            // Compare array lengths to determine if a deep comparison is necessary.\r\n            length = a.length;\r\n            if (length !== b.length) return false;\r\n            // Deep compare the contents, ignoring non-numeric properties.\r\n            while (length--) {\r\n                if (!eq(a[length], b[length], aStack, bStack)) return false;\r\n            }\r\n        } else {\r\n            // Deep compare objects.\r\n            var keys = Object.keys(a), key;\r\n            length = keys.length;\r\n            // Ensure that both objects contain the same number of properties before comparing deep equality.\r\n            if (Object.keys(b).length !== length) return false;\r\n            while (length--) {\r\n                // Deep compare each member\r\n                key = keys[length];\r\n                if (!(b[key]!==undefined && eq(a[key], b[key], aStack, bStack))) return false;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n        return true;\r\n    };\r\n\r\n\r\n   // Perform a deep comparison to check if two objects are equal.\r\n    function isEqual(a, b) {\r\n        return eq(a, b);\r\n    }\r\n\r\n    return objects.isEqual = isEqual;\r\n\t\r\n});"]}