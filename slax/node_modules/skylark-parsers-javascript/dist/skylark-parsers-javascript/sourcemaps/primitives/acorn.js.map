{"version":3,"sources":["primitives/acorn.js"],"names":["define","exports","reservedWords","3","5","6","strict","strictBind","ecma5AndLessKeywords","keywords","keywordRelationalOperator","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","RegExp","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","code","set","pos","i","length","isIdentifierStart","astral","test","String","fromCharCode","isIdentifierChar","TokenType","label","conf","this","keyword","beforeExpr","startsExpr","isLoop","isAssign","prefix","postfix","binop","updateContext","name","prec","keywords$1","kw","options","types","num","regexp","string","eof","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","arrow","template","invalidTemplate","ellipsis","backQuote","dollarBraceL","eq","assign","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","starstar","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","lineBreak","lineBreakG","source","isNewLine","ecma2019String","nonASCIIwhitespace","skipWhiteSpace","ref","Object","prototype","hasOwnProperty","toString","has","obj","propName","call","isArray","Array","Position","line","col","column","offset","n","SourceLocation","p","start","end","sourceFile","getLineInfo","input","cur","lastIndex","match","exec","index","defaultOptions","ecmaVersion","sourceType","onInsertedSemicolon","onTrailingComma","allowReserved","allowReturnOutsideFunction","allowImportExportEverywhere","allowAwaitOutsideFunction","allowHashBang","locations","onToken","onComment","ranges","program","directSourceFile","preserveParens","plugins","getOptions","opts","opt","tokens","token","push","array","block","text","startLoc","endLoc","comment","type","value","loc","range","pushComment","keywordRegexp","words","replace","Parser","startPos","reserved","v","reservedStrict","reservedWordsStrict","reservedWordsStrictBind","containsEsc","loadPlugins","lineStart","lastIndexOf","curLine","slice","split","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","context","initialContext","exprAllowed","inModule","strictDirective","potentialArrowAt","inFunction","inGenerator","inAsync","yieldPos","awaitPos","labels","skipLineComment","scopeStack","enterFunctionScope","regexpState","isKeyword","word","isReservedWord","extend","f","pluginConfigs","plugin","Error","parse","node","startNode","nextToken","parseTopLevel","pp","literal","DestructuringErrors","shorthandAssign","trailingComma","parenthesizedAssign","parenthesizedBind","doubleProto","eat","next","isContextual","eatContextual","expectContextual","unexpected","canInsertSemicolon","insertSemicolon","semicolon","afterTrailingComma","tokType","notNext","expect","raise","checkPatternErrors","refDestructuringErrors","raiseRecoverable","parens","checkExpressionErrors","andThrow","checkYieldAwaitInDefaultParams","isSimpleAssignTarget","expr","expression","pp$1","body","stmt","parseStatement","adaptDirectivePrologue","finishNode","loopLabel","kind","switchLabel","isLet","skip","nextCh","charCodeAt","ident","isAsyncFunction","charAt","declaration","topLevel","starttype","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseFunctionStatement","parseClass","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","parseImport","parseExport","maybeName","parseExpression","parseLabeledStatement","parseExpressionStatement","isBreak","parseIdent","lab","pop","parseParenExpression","awaitAt","enterLexicalScope","parseFor","init$1","parseVar","declarations","init","await","parseForIn","toAssignable","checkLVal","isAsync","parseFunction","consequent","alternate","argument","discriminant","cases","sawDefault","isCase","exitLexicalScope","empty","handler","clause","param","parseBindingAtom","finalizer","object","i$1","list","label$1","statementStart","generator","async","createNewLexicalScope","update","id","left","right","parseMaybeAssign","isFor","decl","parseVarId","isStatement","allowExpressionBody","initFunction","oldInGen","oldInAsync","oldYieldPos","oldAwaitPos","oldInFunc","parseFunctionParams","parseFunctionBody","params","parseBindingList","parseClassId","parseClassSuper","classBody","hadConstructor","member","parseClassMember","this$1","method","tryContextual","k","noLineBreak","key","computed","startNodeAt","static","isGenerator","parsePropertyName","parseClassMethod","parseMethod","superClass","parseExprSubscripts","parseExprAtom","checkExport","fNode","cNode","shouldParseExportStatement","checkVariableExport","specifiers","parseExportSpecifiers","spec","checkUnreserved","local","checkPatternExport","pat","properties","prop","list$1","elements","elt","decls","nodes","first","exported","parseImportSpecifiers","node$1","node$2","imported","statements","isDirectiveCandidate","directive","raw","statement","pp$2","isBinding","toAssignableList","operator","exprList","last","parseSpread","parseRestBinding","parseObj","close","allowEmpty","allowTrailingComma","elts","rest","parseBindingListItem","elem","parseMaybeDefault","bindingType","checkClashes","canDeclareVarName","canDeclareLexicalName","declareVarName","declareLexicalName","pp$3","checkPropClash","propHash","shorthand","proto","other","get","noIn","expressions","afterLeftParse","parseYield","ownDestructuringErrors","oldParenAssign","oldTrailingComma","parseMaybeConditional","parseExprOps","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","logical","op","buildBinary","sawUnary","parseAwait","skipArrowSubscripts","result","parseSubscripts","base","noCalls","maybeAsyncArrow","property","parseExprList","parseArrowExpression","callee","arguments","tag","quasi","parseTemplate","isTagged","canBeArrow","parseLiteral","regex","pattern","flags","parseParenAndDistinguishExpression","parseNew","val","spreadStart","innerStartPos","innerStartLoc","lastIsComma","parseParenItem","innerEndPos","innerEndLoc","parseParenArrowList","finishNodeAt","par","item","empty$1","meta","parseTemplateElement","cooked","tail","curElt","quasis","isAsyncProp","isPattern","parseProperty","parsePropertyValue","paramCount","isArrowFunction","isExpression","oldStrict","useStrict","checkParams","nonSimple","isSimpleParamList","oldLabels","exitFunctionScope","allowDuplicates","nameHash","indexOf","liberal","delegate","pp$4","message","err","SyntaxError","raisedAt","pp$5","target","sources","len","var","lexical","childVar","parentLexical","parentScope","childScope","currentScope","Node","parser","pp$6","TokContext","isExpr","preserveSpace","override","types$1","b_stat","b_expr","b_tmpl","p_stat","p_expr","q_tmpl","tryReadTemplateToken","f_stat","f_expr","f_expr_gen","f_gen","pp$7","braceIsBlock","prevType","parent","curContext","inGeneratorContext","out","statementParens","allowed","data","$LONE","General_Category","Script","apply","gc","sc","Script_Extensions","scx","pp$9","RegExpValidationState","validFlags","switchU","switchN","lastIntValue","lastStringValue","lastAssertionIsQuantifiable","numCapturingParens","maxBackReference","groupNames","backReferenceNames","codePointToString$1","ch","isSyntaxCharacter","isControlLetter","isUnicodePropertyNameCharacter","isUnicodePropertyValueCharacter","isDecimalDigit","isHexDigit","hexToInt","isOctalDigit","reset","unicode","at","s","l","c","nextIndex","current","lookahead","advance","validateRegExpFlags","state","flag","validateRegExpPattern","regexp_pattern","regexp_disjunction","regexp_alternative","regexp_eatQuantifier","regexp_eatTerm","regexp_eatAssertion","regexp_eatAtom","regexp_eatExtendedAtom","lookbehind","noError","regexp_eatQuantifierPrefix","regexp_eatBracedQuantifier","min","max","regexp_eatDecimalDigits","regexp_eatPatternCharacters","regexp_eatReverseSolidusAtomEscape","regexp_eatCharacterClass","regexp_eatUncapturingGroup","regexp_eatCapturingGroup","regexp_eatAtomEscape","regexp_groupSpecifier","regexp_eatInvalidBracedQuantifier","regexp_eatExtendedPatternCharacter","regexp_eatSyntaxCharacter","regexp_eatGroupName","regexp_eatRegExpIdentifierName","regexp_eatRegExpIdentifierStart","regexp_eatRegExpIdentifierPart","regexp_eatRegExpUnicodeEscapeSequence","isRegExpIdentifierStart","isRegExpIdentifierPart","regexp_eatBackReference","regexp_eatCharacterClassEscape","regexp_eatCharacterEscape","regexp_eatKGroupName","regexp_eatDecimalEscape","regexp_eatControlEscape","regexp_eatCControlLetter","regexp_eatZero","regexp_eatHexEscapeSequence","regexp_eatLegacyOctalEscapeSequence","regexp_eatIdentityEscape","regexp_eatControlLetter","regexp_eatFixedHexDigits","lead","leadSurrogateEnd","trail","regexp_eatHexDigits","isCharacterClassEscape","regexp_eatUnicodePropertyValueExpression","regexp_eatUnicodePropertyName","regexp_eatUnicodePropertyValue","regexp_validateUnicodePropertyNameAndValue","regexp_eatLoneUnicodePropertyNameOrValue","nameOrValue","regexp_validateUnicodePropertyNameOrValue","regexp_classRanges","regexp_eatClassAtom","regexp_eatClassEscape","ch$1","regexp_eatClassControlLetter","regexp_eatOctalDigit","n1","n2","Token","pp$8","codePointToString","getToken","Symbol","iterator","done","skipSpace","finishToken","readToken","fullCharCodeAtPos","readWord","getTokenFromCode","skipBlockComment","startSkip","loop","readToken_dot","readNumber","next2","readToken_slash","readRegexp","finishOp","readToken_mult_modulo_exp","size","tokentype","readToken_pipe_amp","readToken_caret","readToken_plus_min","readToken_lt_gt","readToken_eq_excl","readRadixNumber","readString","str","escaped","inClass","flagsStart","readWord1","e","readInt","radix","total","Infinity","startsWithDot","octal","parseInt","parseFloat","readCodePoint","codePos","readHexChar","invalidStringToken","quote","chunkStart","readEscapedChar","INVALID_TEMPLATE_ESCAPE_ERROR","inTemplateElement","readTmplToken","readInvalidTemplateToken","position","inTemplate","octalStr","substr","escStart","esc","version","parseExpressionAt","tokenizer","addLooseExports","Parser$$1","plugins$$1","parse_dammit","LooseParser","pluginsLoose","tokTypes","keywordTypes","tokContexts","defineProperty"],"mappings":";;;;;;;AAAAA,UAAU,WAGV,aAEA,IAAIC,WAIAC,GACFC,EAAG,sNACHC,EAAG,+CACHC,EAAG,OACHC,OAAQ,yEACRC,WAAY,kBAKVC,EAAuB,8KAEvBC,GACFL,EAAGI,EACHH,EAAGG,EAAuB,4CAGxBE,EAA4B,kBAU5BC,EAA+B,86BAC/BC,EAA0B,ijBAE1BC,EAA0B,IAAIC,OAAO,IAAMH,EAA+B,KAC1EI,EAAqB,IAAID,OAAO,IAAMH,EAA+BC,EAA0B,KAEnGD,EAA+BC,EAA0B,KASzD,IAAII,GAA8B,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,IAAI,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,EAAE,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,IAAI,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,KAAK,GAAG,IAAI,KAAK,IAAI,GAAG,IAAI,KAAK,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,KAAK,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,KAAK,IAAI,GAAG,GAAG,KAAK,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE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,iBACA,sBACA,qBACA,WACA,MACA,gBACA,UACA,kBACA,SACA,YACA,MACA,sBACA,OACA,uBACA,OACA,cACA,MACA,WACA,MACA,cACA,OACA,eACA,SACA,0BACA,MACA,YACA,QACA,OACA,0BACA,QACA,iBACA,UACA,sBACA,SACA,iBACA,QACA,UACA,qBACA,KACA,oBACA,QACA,cACA,KACA,uBACA,OACA,oBACA,QACA,YACA,QACA,qBACA,KACA,cACA,QACA,eACA,OACA,YACA,QAEFC,kBACE,eACA,KACA,oBACA,KACA,wBACA,KACA,UACA,KACA,QACA,kBACA,KACA,mBACA,KACA,iBACA,KACA,QACA,iBACA,KACA,oBACA,KACA,SACA,KACA,sBACA,KACA,SACA,IACA,gBACA,KACA,iBACA,KACA,mBACA,KACA,OACA,IACA,iBACA,cACA,KACA,kBACA,KACA,kBACA,KACA,kBACA,KACA,SACA,IACA,mBACA,KACA,QACA,IACA,eACA,KACA,eACA,KACA,oBACA,KACA,eACA,KACA,sBACA,KACA,cACA,KACA,cACA,IACA,QACA,YACA,IACA,kBACA,KACA,eACA,KACA,YACA,KACA,SACA,IACA,mBACA,KACA,aACA,KACA,mBACA,MAEFC,QACE,QACA,OACA,OACA,wBACA,OACA,SACA,OACA,WACA,OACA,UACA,OACA,WACA,OACA,QACA,OACA,YACA,OACA,QACA,OACA,UACA,OACA,YACA,OACA,WACA,OACA,SACA,OACA,UACA,OACA,WACA,OACA,QACA,OACA,sBACA,OACA,SACA,OACA,qBACA,OACA,SACA,OACA,OACA,WACA,OACA,SACA,OACA,SACA,OACA,OACA,YACA,OACA,UACA,OACA,WACA,OACA,UACA,OACA,aACA,OACA,WACA,OACA,uBACA,OACA,UACA,OACA,WACA,OACA,WACA,OACA,aACA,OACA,SACA,OACA,UACA,OACA,QACA,OACA,WACA,OACA,WACA,OACA,MACA,OACA,SACA,OACA,UACA,OACA,SACA,OACA,SACA,OACA,WACA,OACA,mBACA,OACA,YACA,OACA,OACA,wBACA,OACA,yBACA,OACA,WACA,OACA,SACA,OACA,UACA,OACA,WACA,OACA,WACA,OACA,aACA,OACA,QACA,OACA,SACA,OACA,YACA,OACA,MACA,OACA,QACA,OACA,SACA,OACA,QACA,OACA,WACA,OACA,WACA,OACA,OACA,SACA,OACA,SACA,OACA,WACA,OACA,YACA,OACA,UACA,OACA,aACA,OACA,UACA,OACA,gBACA,OACA,eACA,OACA,gBACA,OACA,mBACA,OACA,uBACA,OACA,OACA,OACA,OACA,YACA,OACA,MACA,OACA,UACA,OACA,UACA,OACA,YACA,OACA,cACA,OACA,OACA,MACA,OACA,QACA,OACA,QACA,OACA,WACA,OACA,gBACA,OACA,aACA,OACA,oBACA,OACA,aACA,OACA,cACA,OACA,oBACA,OACA,aACA,OACA,QACA,OACA,QACA,OACA,UACA,OACA,eACA,OACA,YACA,OACA,cACA,OACA,WACA,OACA,aACA,OACA,kBACA,OACA,SACA,OACA,QACA,OACA,YACA,OACA,aACA,OACA,UACA,OACA,UACA,OACA,UACA,OACA,cACA,OACA,UACA,OACA,eACA,OACA,UACA,OACA,YACA,OACA,eACA,OACA,SACA,OACA,UACA,OACA,WACA,OACA,SACA,OACA,WACA,OACA,WACA,OACA,QACA,OACA,QACA,OACA,SACA,OACA,SACA,OACA,SACA,OACA,OACA,UACA,OACA,WACA,OACA,UACA,OACA,WACA,OACA,MACA,OACA,cACA,OACA,KACA,OACA,mBACA,SAGJ9b,MAAMR,UAAUkD,KAAKqZ,MAAMJ,GAAKC,MAAOD,GAAKE,kBAC5CF,GAAKK,GAAKL,GAAKE,iBACfF,GAAKM,GAAKN,GAAKO,kBAAoBP,GAAKQ,IAAMR,GAAKG,OAEnD,IAAIM,GAAO3Y,EAAOjE,UAEd6c,GAAwB,SAA+BrC,GACzDzgB,KAAKygB,OAASA,EACdzgB,KAAK+iB,WAAa,OAAStC,EAAO3f,QAAQ+G,aAAe,EAAI,KAAO,KAAO4Y,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","file":"../../primitives/acorn.js","sourcesContent":["define([],function(){\r\n\r\n\r\n'use strict';\r\n\r\nvar exports = {};\r\n\r\n// Reserved word lists for various dialects of the language\r\n\r\nvar reservedWords = {\r\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\r\n  5: \"class enum extends super const export import\",\r\n  6: \"enum\",\r\n  strict: \"implements interface let package private protected public static yield\",\r\n  strictBind: \"eval arguments\"\r\n};\r\n\r\n// And the keywords\r\n\r\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\r\n\r\nvar keywords = {\r\n  5: ecma5AndLessKeywords,\r\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\r\n};\r\n\r\nvar keywordRelationalOperator = /^in(stanceof)?$/;\r\n\r\n// ## Character categories\r\n\r\n// Big ugly regular expressions that match characters in the\r\n// whitespace, identifier, and identifier-start categories. These\r\n// are only applied when a character is found to actually have a\r\n// code point above 128.\r\n// Generated by `bin/generate-identifier-regex.js`.\r\n\r\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7b9\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\r\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\r\n\r\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\r\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\r\n\r\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\r\n\r\n// These are a run-length and offset encoded representation of the\r\n// >0xffff code points that are a valid part of identifiers. The\r\n// offset starts at 0x10000, and each pair of numbers represents an\r\n// offset to the next range, and then a size of the range. They were\r\n// generated by bin/generate-identifier-regex.js\r\n\r\n// eslint-disable-next-line comma-spacing\r\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,190,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,26,230,43,117,63,32,0,257,0,11,39,8,0,22,0,12,39,3,3,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,68,12,0,67,12,65,1,31,6129,15,754,9486,286,82,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\r\n\r\n// eslint-disable-next-line comma-spacing\r\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,280,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];\r\n\r\n// This has a complexity linear to the value of the code. The\r\n// assumption is that looking up astral identifier characters is\r\n// rare.\r\nfunction isInAstralSet(code, set) {\r\n  var pos = 0x10000;\r\n  for (var i = 0; i < set.length; i += 2) {\r\n    pos += set[i];\r\n    if (pos > code) { return false }\r\n    pos += set[i + 1];\r\n    if (pos >= code) { return true }\r\n  }\r\n}\r\n\r\n// Test whether a given character code starts an identifier.\r\n\r\nfunction isIdentifierStart(code, astral) {\r\n  if (code < 65) { return code === 36 }\r\n  if (code < 91) { return true }\r\n  if (code < 97) { return code === 95 }\r\n  if (code < 123) { return true }\r\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\r\n  if (astral === false) { return false }\r\n  return isInAstralSet(code, astralIdentifierStartCodes)\r\n}\r\n\r\n// Test whether a given character is part of an identifier.\r\n\r\nfunction isIdentifierChar(code, astral) {\r\n  if (code < 48) { return code === 36 }\r\n  if (code < 58) { return true }\r\n  if (code < 65) { return false }\r\n  if (code < 91) { return true }\r\n  if (code < 97) { return code === 95 }\r\n  if (code < 123) { return true }\r\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\r\n  if (astral === false) { return false }\r\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\r\n}\r\n\r\n// ## Token types\r\n\r\n// The assignment of fine-grained, information-carrying type objects\r\n// allows the tokenizer to store the information it has about a\r\n// token in a way that is very cheap for the parser to look up.\r\n\r\n// All token type variables start with an underscore, to make them\r\n// easy to recognize.\r\n\r\n// The `beforeExpr` property is used to disambiguate between regular\r\n// expressions and divisions. It is set on all token types that can\r\n// be followed by an expression (thus, a slash after them would be a\r\n// regular expression).\r\n//\r\n// The `startsExpr` property is used to check if the token ends a\r\n// `yield` expression. It is set on all token types that either can\r\n// directly start an expression (like a quotation mark) or can\r\n// continue an expression (like the body of a string).\r\n//\r\n  // `isLoop` marks a keyword as starting a loop, which is important\r\n  // to know when parsing a label, in order to allow or disallow\r\n  // continue jumps to that label.\r\n\r\n  var TokenType = function TokenType(label, conf) {\r\n    if ( conf === void 0 ) conf = {};\r\n\r\n    this.label = label;\r\n    this.keyword = conf.keyword;\r\n    this.beforeExpr = !!conf.beforeExpr;\r\n    this.startsExpr = !!conf.startsExpr;\r\n    this.isLoop = !!conf.isLoop;\r\n    this.isAssign = !!conf.isAssign;\r\n    this.prefix = !!conf.prefix;\r\n    this.postfix = !!conf.postfix;\r\n    this.binop = conf.binop || null;\r\n    this.updateContext = null;\r\n  };\r\n\r\n  function binop(name, prec) {\r\n    return new TokenType(name, {beforeExpr: true, binop: prec})\r\n  }\r\n  var beforeExpr = {beforeExpr: true};\r\n  var startsExpr = {startsExpr: true};\r\n\r\n  // Map keyword names to token types.\r\n\r\n  var keywords$1 = {};\r\n\r\n  // Succinct definitions of keyword token types\r\n  function kw(name, options) {\r\n    if ( options === void 0 ) options = {};\r\n\r\n    options.keyword = name;\r\n    return keywords$1[name] = new TokenType(name, options)\r\n  }\r\n\r\n  var types = {\r\n    num: new TokenType(\"num\", startsExpr),\r\n    regexp: new TokenType(\"regexp\", startsExpr),\r\n    string: new TokenType(\"string\", startsExpr),\r\n    name: new TokenType(\"name\", startsExpr),\r\n    eof: new TokenType(\"eof\"),\r\n\r\n    // Punctuation token types.\r\n    bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\r\n    bracketR: new TokenType(\"]\"),\r\n    braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\r\n    braceR: new TokenType(\"}\"),\r\n    parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\r\n    parenR: new TokenType(\")\"),\r\n    comma: new TokenType(\",\", beforeExpr),\r\n    semi: new TokenType(\";\", beforeExpr),\r\n    colon: new TokenType(\":\", beforeExpr),\r\n    dot: new TokenType(\".\"),\r\n    question: new TokenType(\"?\", beforeExpr),\r\n    arrow: new TokenType(\"=>\", beforeExpr),\r\n    template: new TokenType(\"template\"),\r\n    invalidTemplate: new TokenType(\"invalidTemplate\"),\r\n    ellipsis: new TokenType(\"...\", beforeExpr),\r\n    backQuote: new TokenType(\"`\", startsExpr),\r\n    dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\r\n\r\n    // Operators. These carry several kinds of properties to help the\r\n    // parser use them properly (the presence of these properties is\r\n    // what categorizes them as operators).\r\n    //\r\n    // `binop`, when present, specifies that this operator is a binary\r\n    // operator, and will refer to its precedence.\r\n    //\r\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\r\n    // unary operator.\r\n    //\r\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\r\n    // binary operators with a very low precedence, that should result\r\n    // in AssignmentExpression nodes.\r\n\r\n    eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\r\n    assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\r\n    incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\r\n    prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\r\n    logicalOR: binop(\"||\", 1),\r\n    logicalAND: binop(\"&&\", 2),\r\n    bitwiseOR: binop(\"|\", 3),\r\n    bitwiseXOR: binop(\"^\", 4),\r\n    bitwiseAND: binop(\"&\", 5),\r\n    equality: binop(\"==/!=/===/!==\", 6),\r\n    relational: binop(\"</>/<=/>=\", 7),\r\n    bitShift: binop(\"<</>>/>>>\", 8),\r\n    plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\r\n    modulo: binop(\"%\", 10),\r\n    star: binop(\"*\", 10),\r\n    slash: binop(\"/\", 10),\r\n    starstar: new TokenType(\"**\", {beforeExpr: true}),\r\n\r\n    // Keyword token types.\r\n    _break: kw(\"break\"),\r\n    _case: kw(\"case\", beforeExpr),\r\n    _catch: kw(\"catch\"),\r\n    _continue: kw(\"continue\"),\r\n    _debugger: kw(\"debugger\"),\r\n    _default: kw(\"default\", beforeExpr),\r\n    _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\r\n    _else: kw(\"else\", beforeExpr),\r\n    _finally: kw(\"finally\"),\r\n    _for: kw(\"for\", {isLoop: true}),\r\n    _function: kw(\"function\", startsExpr),\r\n    _if: kw(\"if\"),\r\n    _return: kw(\"return\", beforeExpr),\r\n    _switch: kw(\"switch\"),\r\n    _throw: kw(\"throw\", beforeExpr),\r\n    _try: kw(\"try\"),\r\n    _var: kw(\"var\"),\r\n    _const: kw(\"const\"),\r\n    _while: kw(\"while\", {isLoop: true}),\r\n    _with: kw(\"with\"),\r\n    _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\r\n    _this: kw(\"this\", startsExpr),\r\n    _super: kw(\"super\", startsExpr),\r\n    _class: kw(\"class\", startsExpr),\r\n    _extends: kw(\"extends\", beforeExpr),\r\n    _export: kw(\"export\"),\r\n    _import: kw(\"import\"),\r\n    _null: kw(\"null\", startsExpr),\r\n    _true: kw(\"true\", startsExpr),\r\n    _false: kw(\"false\", startsExpr),\r\n    _in: kw(\"in\", {beforeExpr: true, binop: 7}),\r\n    _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\r\n    _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\r\n    _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\r\n    _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\r\n  };\r\n\r\n  // Matches a whole line break (where CRLF is considered a single\r\n  // line break). Used to count lines.\r\n\r\n  var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\r\n  var lineBreakG = new RegExp(lineBreak.source, \"g\");\r\n\r\n  function isNewLine(code, ecma2019String) {\r\n    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\r\n  }\r\n\r\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\r\n\r\n  var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\r\n\r\n  var ref = Object.prototype;\r\n  var hasOwnProperty = ref.hasOwnProperty;\r\n  var toString = ref.toString;\r\n\r\n  // Checks if an object has a property.\r\n\r\n  function has(obj, propName) {\r\n    return hasOwnProperty.call(obj, propName)\r\n  }\r\n\r\n  var isArray = Array.isArray || (function (obj) { return (\r\n    toString.call(obj) === \"[object Array]\"\r\n  ); });\r\n\r\n  // These are used when `options.locations` is on, for the\r\n  // `startLoc` and `endLoc` properties.\r\n\r\n  var Position = function Position(line, col) {\r\n    this.line = line;\r\n    this.column = col;\r\n  };\r\n\r\n  Position.prototype.offset = function offset (n) {\r\n    return new Position(this.line, this.column + n)\r\n  };\r\n\r\n  var SourceLocation = function SourceLocation(p, start, end) {\r\n    this.start = start;\r\n    this.end = end;\r\n    if (p.sourceFile !== null) { this.source = p.sourceFile; }\r\n  };\r\n\r\n  // The `getLineInfo` function is mostly useful when the\r\n  // `locations` option is off (for performance reasons) and you\r\n  // want to find the line/column position for a given character\r\n  // offset. `input` should be the code string that the offset refers\r\n  // into.\r\n\r\n  function getLineInfo(input, offset) {\r\n    for (var line = 1, cur = 0;;) {\r\n      lineBreakG.lastIndex = cur;\r\n      var match = lineBreakG.exec(input);\r\n      if (match && match.index < offset) {\r\n        ++line;\r\n        cur = match.index + match[0].length;\r\n      } else {\r\n        return new Position(line, offset - cur)\r\n      }\r\n    }\r\n  }\r\n\r\n  // A second optional argument can be given to further configure\r\n  // the parser process. These options are recognized:\r\n\r\n  var defaultOptions = {\r\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must\r\n    // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\r\n    // for strict mode, the set of reserved words, and support for\r\n    // new syntax features. The default is 7.\r\n    ecmaVersion: 7,\r\n    // `sourceType` indicates the mode the code should be parsed in.\r\n    // Can be either `\"script\"` or `\"module\"`. This influences global\r\n    // strict mode and parsing of `import` and `export` declarations.\r\n    sourceType: \"script\",\r\n    // `onInsertedSemicolon` can be a callback that will be called\r\n    // when a semicolon is automatically inserted. It will be passed\r\n    // th position of the comma as an offset, and if `locations` is\r\n    // enabled, it is given the location as a `{line, column}` object\r\n    // as second argument.\r\n    onInsertedSemicolon: null,\r\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\r\n    // trailing commas.\r\n    onTrailingComma: null,\r\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\r\n    // Set `allowReserved` to a boolean value to explicitly turn this on\r\n    // an off. When this option has the value \"never\", reserved words\r\n    // and keywords can also not be used as property names.\r\n    allowReserved: null,\r\n    // When enabled, a return at the top level is not considered an\r\n    // error.\r\n    allowReturnOutsideFunction: false,\r\n    // When enabled, import/export statements are not constrained to\r\n    // appearing at the top of the program.\r\n    allowImportExportEverywhere: false,\r\n    // When enabled, await identifiers are allowed to appear at the top-level scope,\r\n    // but they are still not allowed in non-async functions.\r\n    allowAwaitOutsideFunction: false,\r\n    // When enabled, hashbang directive in the beginning of file\r\n    // is allowed and treated as a line comment.\r\n    allowHashBang: false,\r\n    // When `locations` is on, `loc` properties holding objects with\r\n    // `start` and `end` properties in `{line, column}` form (with\r\n    // line being 1-based and column 0-based) will be attached to the\r\n    // nodes.\r\n    locations: false,\r\n    // A function can be passed as `onToken` option, which will\r\n    // cause Acorn to call that function with object in the same\r\n    // format as tokens returned from `tokenizer().getToken()`. Note\r\n    // that you are not allowed to call the parser from the\r\n    // callbackthat will corrupt its internal state.\r\n    onToken: null,\r\n    // A function can be passed as `onComment` option, which will\r\n    // cause Acorn to call that function with `(block, text, start,\r\n    // end)` parameters whenever a comment is skipped. `block` is a\r\n    // boolean indicating whether this is a block (`/* */`) comment,\r\n    // `text` is the content of the comment, and `start` and `end` are\r\n    // character offsets that denote the start and end of the comment.\r\n    // When the `locations` option is on, two more parameters are\r\n    // passed, the full `{line, column}` locations of the start and\r\n    // end of the comments. Note that you are not allowed to call the\r\n    // parser from the callbackthat will corrupt its internal state.\r\n    onComment: null,\r\n    // Nodes have their start and end characters offsets recorded in\r\n    // `start` and `end` properties (directly on the node, rather than\r\n    // the `loc` object, which holds line/column data. To also add a\r\n    // [semi-standardized][range] `range` property holding a `[start,\r\n    // end]` array with the same numbers, set the `ranges` option to\r\n    // `true`.\r\n    //\r\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\r\n    ranges: false,\r\n    // It is possible to parse multiple files into a single AST by\r\n    // passing the tree produced by parsing the first file as\r\n    // `program` option in subsequent parses. This will add the\r\n    // toplevel forms of the parsed file to the `Program` (top) node\r\n    // of an existing parse tree.\r\n    program: null,\r\n    // When `locations` is on, you can pass this to record the source\r\n    // file in every node's `loc` object.\r\n    sourceFile: null,\r\n    // This value, if given, is stored in every node, whether\r\n    // `locations` is on or off.\r\n    directSourceFile: null,\r\n    // When enabled, parenthesized expressions are represented by\r\n    // (non-standard) ParenthesizedExpression nodes\r\n    preserveParens: false,\r\n    plugins: {}\r\n  };\r\n\r\n  // Interpret and default an options object\r\n\r\n  function getOptions(opts) {\r\n    var options = {};\r\n\r\n    for (var opt in defaultOptions)\r\n      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\r\n\r\n    if (options.ecmaVersion >= 2015)\r\n      { options.ecmaVersion -= 2009; }\r\n\r\n    if (options.allowReserved == null)\r\n      { options.allowReserved = options.ecmaVersion < 5; }\r\n\r\n    if (isArray(options.onToken)) {\r\n      var tokens = options.onToken;\r\n      options.onToken = function (token) { return tokens.push(token); };\r\n    }\r\n    if (isArray(options.onComment))\r\n      { options.onComment = pushComment(options, options.onComment); }\r\n\r\n    return options\r\n  }\r\n\r\n  function pushComment(options, array) {\r\n    return function(block, text, start, end, startLoc, endLoc) {\r\n      var comment = {\r\n        type: block ? \"Block\" : \"Line\",\r\n        value: text,\r\n        start: start,\r\n        end: end\r\n      };\r\n      if (options.locations)\r\n        { comment.loc = new SourceLocation(this, startLoc, endLoc); }\r\n      if (options.ranges)\r\n        { comment.range = [start, end]; }\r\n      array.push(comment);\r\n    }\r\n  }\r\n\r\n  // Registered plugins\r\n  var plugins = {};\r\n\r\n  function keywordRegexp(words) {\r\n    return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\r\n  }\r\n\r\n  var Parser = function Parser(options, input, startPos) {\r\n    this.options = options = getOptions(options);\r\n    this.sourceFile = options.sourceFile;\r\n    this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\r\n    var reserved = \"\";\r\n    if (!options.allowReserved) {\r\n      for (var v = options.ecmaVersion;; v--)\r\n        { if (reserved = reservedWords[v]) { break } }\r\n      if (options.sourceType === \"module\") { reserved += \" await\"; }\r\n    }\r\n    this.reservedWords = keywordRegexp(reserved);\r\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\r\n    this.reservedWordsStrict = keywordRegexp(reservedStrict);\r\n    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\r\n    this.input = String(input);\r\n\r\n    // Used to signal to callers of `readWord1` whether the word\r\n    // contained any escape sequences. This is needed because words with\r\n    // escape sequences must not be interpreted as keywords.\r\n    this.containsEsc = false;\r\n\r\n    // Load plugins\r\n    this.loadPlugins(options.plugins);\r\n\r\n    // Set up token state\r\n\r\n    // The current position of the tokenizer in the input.\r\n    if (startPos) {\r\n      this.pos = startPos;\r\n      this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\r\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\r\n    } else {\r\n      this.pos = this.lineStart = 0;\r\n      this.curLine = 1;\r\n    }\r\n\r\n    // Properties of the current token:\r\n    // Its type\r\n    this.type = types.eof;\r\n    // For tokens that include more information than their type, the value\r\n    this.value = null;\r\n    // Its start and end offset\r\n    this.start = this.end = this.pos;\r\n    // And, if locations are used, the {line, column} object\r\n    // corresponding to those offsets\r\n    this.startLoc = this.endLoc = this.curPosition();\r\n\r\n    // Position information for the previous token\r\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\r\n    this.lastTokStart = this.lastTokEnd = this.pos;\r\n\r\n    // The context stack is used to superficially track syntactic\r\n    // context to predict whether a regular expression is allowed in a\r\n    // given position.\r\n    this.context = this.initialContext();\r\n    this.exprAllowed = true;\r\n\r\n    // Figure out if it's a module code.\r\n    this.inModule = options.sourceType === \"module\";\r\n    this.strict = this.inModule || this.strictDirective(this.pos);\r\n\r\n    // Used to signify the start of a potential arrow function\r\n    this.potentialArrowAt = -1;\r\n\r\n    // Flags to track whether we are in a function, a generator, an async function.\r\n    this.inFunction = this.inGenerator = this.inAsync = false;\r\n    // Positions to delayed-check that yield/await does not exist in default parameters.\r\n    this.yieldPos = this.awaitPos = 0;\r\n    // Labels in scope.\r\n    this.labels = [];\r\n\r\n    // If enabled, skip leading hashbang line.\r\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\r\n      { this.skipLineComment(2); }\r\n\r\n    // Scope tracking for duplicate variable names (see scope.js)\r\n    this.scopeStack = [];\r\n    this.enterFunctionScope();\r\n\r\n    // For RegExp validation\r\n    this.regexpState = null;\r\n  };\r\n\r\n  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\r\n  Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\r\n  Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\r\n\r\n  Parser.prototype.extend = function extend (name, f) {\r\n    this[name] = f(this[name]);\r\n  };\r\n\r\n  Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\r\n      var this$1 = this;\r\n\r\n    for (var name in pluginConfigs) {\r\n      var plugin = plugins[name];\r\n      if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\r\n      plugin(this$1, pluginConfigs[name]);\r\n    }\r\n  };\r\n\r\n  Parser.prototype.parse = function parse () {\r\n    var node = this.options.program || this.startNode();\r\n    this.nextToken();\r\n    return this.parseTopLevel(node)\r\n  };\r\n\r\n  var pp = Parser.prototype;\r\n\r\n  // ## Parser utilities\r\n\r\n  var literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\"|;)/;\r\n  pp.strictDirective = function(start) {\r\n    var this$1 = this;\r\n\r\n    for (;;) {\r\n      skipWhiteSpace.lastIndex = start;\r\n      start += skipWhiteSpace.exec(this$1.input)[0].length;\r\n      var match = literal.exec(this$1.input.slice(start));\r\n      if (!match) { return false }\r\n      if ((match[1] || match[2]) === \"use strict\") { return true }\r\n      start += match[0].length;\r\n    }\r\n  };\r\n\r\n  // Predicate that tests whether the next token is of the given\r\n  // type, and if yes, consumes it as a side effect.\r\n\r\n  pp.eat = function(type) {\r\n    if (this.type === type) {\r\n      this.next();\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  };\r\n\r\n  // Tests whether parsed token is a contextual keyword.\r\n\r\n  pp.isContextual = function(name) {\r\n    return this.type === types.name && this.value === name && !this.containsEsc\r\n  };\r\n\r\n  // Consumes contextual keyword if possible.\r\n\r\n  pp.eatContextual = function(name) {\r\n    if (!this.isContextual(name)) { return false }\r\n    this.next();\r\n    return true\r\n  };\r\n\r\n  // Asserts that following token is given contextual keyword.\r\n\r\n  pp.expectContextual = function(name) {\r\n    if (!this.eatContextual(name)) { this.unexpected(); }\r\n  };\r\n\r\n  // Test whether a semicolon can be inserted at the current position.\r\n\r\n  pp.canInsertSemicolon = function() {\r\n    return this.type === types.eof ||\r\n      this.type === types.braceR ||\r\n      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\r\n  };\r\n\r\n  pp.insertSemicolon = function() {\r\n    if (this.canInsertSemicolon()) {\r\n      if (this.options.onInsertedSemicolon)\r\n        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\r\n      return true\r\n    }\r\n  };\r\n\r\n  // Consume a semicolon, or, failing that, see if we are allowed to\r\n  // pretend that there is a semicolon at this position.\r\n\r\n  pp.semicolon = function() {\r\n    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\r\n  };\r\n\r\n  pp.afterTrailingComma = function(tokType, notNext) {\r\n    if (this.type === tokType) {\r\n      if (this.options.onTrailingComma)\r\n        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\r\n      if (!notNext)\r\n        { this.next(); }\r\n      return true\r\n    }\r\n  };\r\n\r\n  // Expect a token of a given type. If found, consume it, otherwise,\r\n  // raise an unexpected token error.\r\n\r\n  pp.expect = function(type) {\r\n    this.eat(type) || this.unexpected();\r\n  };\r\n\r\n  // Raise an unexpected token error.\r\n\r\n  pp.unexpected = function(pos) {\r\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\r\n  };\r\n\r\n  function DestructuringErrors() {\r\n    this.shorthandAssign =\r\n    this.trailingComma =\r\n    this.parenthesizedAssign =\r\n    this.parenthesizedBind =\r\n    this.doubleProto =\r\n      -1;\r\n  }\r\n\r\n  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\r\n    if (!refDestructuringErrors) { return }\r\n    if (refDestructuringErrors.trailingComma > -1)\r\n      { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\r\n    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\r\n    if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\r\n  };\r\n\r\n  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\r\n    if (!refDestructuringErrors) { return false }\r\n    var shorthandAssign = refDestructuringErrors.shorthandAssign;\r\n    var doubleProto = refDestructuringErrors.doubleProto;\r\n    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\r\n    if (shorthandAssign >= 0)\r\n      { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\r\n    if (doubleProto >= 0)\r\n      { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\r\n  };\r\n\r\n  pp.checkYieldAwaitInDefaultParams = function() {\r\n    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\r\n      { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\r\n    if (this.awaitPos)\r\n      { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\r\n  };\r\n\r\n  pp.isSimpleAssignTarget = function(expr) {\r\n    if (expr.type === \"ParenthesizedExpression\")\r\n      { return this.isSimpleAssignTarget(expr.expression) }\r\n    return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\r\n  };\r\n\r\n  var pp$1 = Parser.prototype;\r\n\r\n  // ### Statement parsing\r\n\r\n  // Parse a program. Initializes the parser, reads any number of\r\n  // statements, and wraps them in a Program node.  Optionally takes a\r\n  // `program` argument.  If present, the statements will be appended\r\n  // to its body instead of creating a new node.\r\n\r\n  pp$1.parseTopLevel = function(node) {\r\n    var this$1 = this;\r\n\r\n    var exports = {};\r\n    if (!node.body) { node.body = []; }\r\n    while (this.type !== types.eof) {\r\n      var stmt = this$1.parseStatement(true, true, exports);\r\n      node.body.push(stmt);\r\n    }\r\n    this.adaptDirectivePrologue(node.body);\r\n    this.next();\r\n    if (this.options.ecmaVersion >= 6) {\r\n      node.sourceType = this.options.sourceType;\r\n    }\r\n    return this.finishNode(node, \"Program\")\r\n  };\r\n\r\n  var loopLabel = {kind: \"loop\"};\r\n  var switchLabel = {kind: \"switch\"};\r\n\r\n  pp$1.isLet = function() {\r\n    if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\r\n    skipWhiteSpace.lastIndex = this.pos;\r\n    var skip = skipWhiteSpace.exec(this.input);\r\n    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\r\n    if (nextCh === 91 || nextCh === 123) { return true } // '{' and '['\r\n    if (isIdentifierStart(nextCh, true)) {\r\n      var pos = next + 1;\r\n      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\r\n      var ident = this.input.slice(next, pos);\r\n      if (!keywordRelationalOperator.test(ident)) { return true }\r\n    }\r\n    return false\r\n  };\r\n\r\n  // check 'async [no LineTerminator here] function'\r\n  // - 'async /*foo*/ function' is OK.\r\n  // - 'async /*\\n*/ function' is invalid.\r\n  pp$1.isAsyncFunction = function() {\r\n    if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\r\n      { return false }\r\n\r\n    skipWhiteSpace.lastIndex = this.pos;\r\n    var skip = skipWhiteSpace.exec(this.input);\r\n    var next = this.pos + skip[0].length;\r\n    return !lineBreak.test(this.input.slice(this.pos, next)) &&\r\n      this.input.slice(next, next + 8) === \"function\" &&\r\n      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\r\n  };\r\n\r\n  // Parse a single statement.\r\n  //\r\n  // If expecting a statement and finding a slash operator, parse a\r\n  // regular expression literal. This is to handle cases like\r\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\r\n  // does not help.\r\n\r\n  pp$1.parseStatement = function(declaration, topLevel, exports) {\r\n    var starttype = this.type, node = this.startNode(), kind;\r\n\r\n    if (this.isLet()) {\r\n      starttype = types._var;\r\n      kind = \"let\";\r\n    }\r\n\r\n    // Most types of statements are recognized by the keyword they\r\n    // start with. Many are trivial to parse, some require a bit of\r\n    // complexity.\r\n\r\n    switch (starttype) {\r\n    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\r\n    case types._debugger: return this.parseDebuggerStatement(node)\r\n    case types._do: return this.parseDoStatement(node)\r\n    case types._for: return this.parseForStatement(node)\r\n    case types._function:\r\n      if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }\r\n      return this.parseFunctionStatement(node, false)\r\n    case types._class:\r\n      if (!declaration) { this.unexpected(); }\r\n      return this.parseClass(node, true)\r\n    case types._if: return this.parseIfStatement(node)\r\n    case types._return: return this.parseReturnStatement(node)\r\n    case types._switch: return this.parseSwitchStatement(node)\r\n    case types._throw: return this.parseThrowStatement(node)\r\n    case types._try: return this.parseTryStatement(node)\r\n    case types._const: case types._var:\r\n      kind = kind || this.value;\r\n      if (!declaration && kind !== \"var\") { this.unexpected(); }\r\n      return this.parseVarStatement(node, kind)\r\n    case types._while: return this.parseWhileStatement(node)\r\n    case types._with: return this.parseWithStatement(node)\r\n    case types.braceL: return this.parseBlock()\r\n    case types.semi: return this.parseEmptyStatement(node)\r\n    case types._export:\r\n    case types._import:\r\n      if (!this.options.allowImportExportEverywhere) {\r\n        if (!topLevel)\r\n          { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\r\n        if (!this.inModule)\r\n          { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\r\n      }\r\n      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\r\n\r\n      // If the statement does not start with a statement keyword or a\r\n      // brace, it's an ExpressionStatement or LabeledStatement. We\r\n      // simply start parsing an expression, and afterwards, if the\r\n      // next token is a colon and the expression was a simple\r\n      // Identifier node, we switch to interpreting it as a label.\r\n    default:\r\n      if (this.isAsyncFunction()) {\r\n        if (!declaration) { this.unexpected(); }\r\n        this.next();\r\n        return this.parseFunctionStatement(node, true)\r\n      }\r\n\r\n      var maybeName = this.value, expr = this.parseExpression();\r\n      if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\r\n        { return this.parseLabeledStatement(node, maybeName, expr) }\r\n      else { return this.parseExpressionStatement(node, expr) }\r\n    }\r\n  };\r\n\r\n  pp$1.parseBreakContinueStatement = function(node, keyword) {\r\n    var this$1 = this;\r\n\r\n    var isBreak = keyword === \"break\";\r\n    this.next();\r\n    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\r\n    else if (this.type !== types.name) { this.unexpected(); }\r\n    else {\r\n      node.label = this.parseIdent();\r\n      this.semicolon();\r\n    }\r\n\r\n    // Verify that there is an actual destination to break or\r\n    // continue to.\r\n    var i = 0;\r\n    for (; i < this.labels.length; ++i) {\r\n      var lab = this$1.labels[i];\r\n      if (node.label == null || lab.name === node.label.name) {\r\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\r\n        if (node.label && isBreak) { break }\r\n      }\r\n    }\r\n    if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\r\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\r\n  };\r\n\r\n  pp$1.parseDebuggerStatement = function(node) {\r\n    this.next();\r\n    this.semicolon();\r\n    return this.finishNode(node, \"DebuggerStatement\")\r\n  };\r\n\r\n  pp$1.parseDoStatement = function(node) {\r\n    this.next();\r\n    this.labels.push(loopLabel);\r\n    node.body = this.parseStatement(false);\r\n    this.labels.pop();\r\n    this.expect(types._while);\r\n    node.test = this.parseParenExpression();\r\n    if (this.options.ecmaVersion >= 6)\r\n      { this.eat(types.semi); }\r\n    else\r\n      { this.semicolon(); }\r\n    return this.finishNode(node, \"DoWhileStatement\")\r\n  };\r\n\r\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\r\n  // loop is non-trivial. Basically, we have to parse the init `var`\r\n  // statement or expression, disallowing the `in` operator (see\r\n  // the second parameter to `parseExpression`), and then check\r\n  // whether the next token is `in` or `of`. When there is no init\r\n  // part (semicolon immediately after the opening parenthesis), it\r\n  // is a regular `for` loop.\r\n\r\n  pp$1.parseForStatement = function(node) {\r\n    this.next();\r\n    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\r\n    this.labels.push(loopLabel);\r\n    this.enterLexicalScope();\r\n    this.expect(types.parenL);\r\n    if (this.type === types.semi) {\r\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n      return this.parseFor(node, null)\r\n    }\r\n    var isLet = this.isLet();\r\n    if (this.type === types._var || this.type === types._const || isLet) {\r\n      var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\r\n      this.next();\r\n      this.parseVar(init$1, true, kind);\r\n      this.finishNode(init$1, \"VariableDeclaration\");\r\n      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\r\n          !(kind !== \"var\" && init$1.declarations[0].init)) {\r\n        if (this.options.ecmaVersion >= 9) {\r\n          if (this.type === types._in) {\r\n            if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n          } else { node.await = awaitAt > -1; }\r\n        }\r\n        return this.parseForIn(node, init$1)\r\n      }\r\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n      return this.parseFor(node, init$1)\r\n    }\r\n    var refDestructuringErrors = new DestructuringErrors;\r\n    var init = this.parseExpression(true, refDestructuringErrors);\r\n    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\r\n      if (this.options.ecmaVersion >= 9) {\r\n        if (this.type === types._in) {\r\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n        } else { node.await = awaitAt > -1; }\r\n      }\r\n      this.toAssignable(init, false, refDestructuringErrors);\r\n      this.checkLVal(init);\r\n      return this.parseForIn(node, init)\r\n    } else {\r\n      this.checkExpressionErrors(refDestructuringErrors, true);\r\n    }\r\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n    return this.parseFor(node, init)\r\n  };\r\n\r\n  pp$1.parseFunctionStatement = function(node, isAsync) {\r\n    this.next();\r\n    return this.parseFunction(node, true, false, isAsync)\r\n  };\r\n\r\n  pp$1.parseIfStatement = function(node) {\r\n    this.next();\r\n    node.test = this.parseParenExpression();\r\n    // allow function declarations in branches, but only in non-strict mode\r\n    node.consequent = this.parseStatement(!this.strict && this.type === types._function);\r\n    node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;\r\n    return this.finishNode(node, \"IfStatement\")\r\n  };\r\n\r\n  pp$1.parseReturnStatement = function(node) {\r\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction)\r\n      { this.raise(this.start, \"'return' outside of function\"); }\r\n    this.next();\r\n\r\n    // In `return` (and `break`/`continue`), the keywords with\r\n    // optional arguments, we eagerly look for a semicolon or the\r\n    // possibility to insert one.\r\n\r\n    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\r\n    else { node.argument = this.parseExpression(); this.semicolon(); }\r\n    return this.finishNode(node, \"ReturnStatement\")\r\n  };\r\n\r\n  pp$1.parseSwitchStatement = function(node) {\r\n    var this$1 = this;\r\n\r\n    this.next();\r\n    node.discriminant = this.parseParenExpression();\r\n    node.cases = [];\r\n    this.expect(types.braceL);\r\n    this.labels.push(switchLabel);\r\n    this.enterLexicalScope();\r\n\r\n    // Statements under must be grouped (by label) in SwitchCase\r\n    // nodes. `cur` is used to keep the node that we are currently\r\n    // adding statements to.\r\n\r\n    var cur;\r\n    for (var sawDefault = false; this.type !== types.braceR;) {\r\n      if (this$1.type === types._case || this$1.type === types._default) {\r\n        var isCase = this$1.type === types._case;\r\n        if (cur) { this$1.finishNode(cur, \"SwitchCase\"); }\r\n        node.cases.push(cur = this$1.startNode());\r\n        cur.consequent = [];\r\n        this$1.next();\r\n        if (isCase) {\r\n          cur.test = this$1.parseExpression();\r\n        } else {\r\n          if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\"); }\r\n          sawDefault = true;\r\n          cur.test = null;\r\n        }\r\n        this$1.expect(types.colon);\r\n      } else {\r\n        if (!cur) { this$1.unexpected(); }\r\n        cur.consequent.push(this$1.parseStatement(true));\r\n      }\r\n    }\r\n    this.exitLexicalScope();\r\n    if (cur) { this.finishNode(cur, \"SwitchCase\"); }\r\n    this.next(); // Closing brace\r\n    this.labels.pop();\r\n    return this.finishNode(node, \"SwitchStatement\")\r\n  };\r\n\r\n  pp$1.parseThrowStatement = function(node) {\r\n    this.next();\r\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\r\n      { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\r\n    node.argument = this.parseExpression();\r\n    this.semicolon();\r\n    return this.finishNode(node, \"ThrowStatement\")\r\n  };\r\n\r\n  // Reused empty array added for node fields that are always empty.\r\n\r\n  var empty = [];\r\n\r\n  pp$1.parseTryStatement = function(node) {\r\n    this.next();\r\n    node.block = this.parseBlock();\r\n    node.handler = null;\r\n    if (this.type === types._catch) {\r\n      var clause = this.startNode();\r\n      this.next();\r\n      if (this.eat(types.parenL)) {\r\n        clause.param = this.parseBindingAtom();\r\n        this.enterLexicalScope();\r\n        this.checkLVal(clause.param, \"let\");\r\n        this.expect(types.parenR);\r\n      } else {\r\n        if (this.options.ecmaVersion < 10) { this.unexpected(); }\r\n        clause.param = null;\r\n        this.enterLexicalScope();\r\n      }\r\n      clause.body = this.parseBlock(false);\r\n      this.exitLexicalScope();\r\n      node.handler = this.finishNode(clause, \"CatchClause\");\r\n    }\r\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\r\n    if (!node.handler && !node.finalizer)\r\n      { this.raise(node.start, \"Missing catch or finally clause\"); }\r\n    return this.finishNode(node, \"TryStatement\")\r\n  };\r\n\r\n  pp$1.parseVarStatement = function(node, kind) {\r\n    this.next();\r\n    this.parseVar(node, false, kind);\r\n    this.semicolon();\r\n    return this.finishNode(node, \"VariableDeclaration\")\r\n  };\r\n\r\n  pp$1.parseWhileStatement = function(node) {\r\n    this.next();\r\n    node.test = this.parseParenExpression();\r\n    this.labels.push(loopLabel);\r\n    node.body = this.parseStatement(false);\r\n    this.labels.pop();\r\n    return this.finishNode(node, \"WhileStatement\")\r\n  };\r\n\r\n  pp$1.parseWithStatement = function(node) {\r\n    if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\r\n    this.next();\r\n    node.object = this.parseParenExpression();\r\n    node.body = this.parseStatement(false);\r\n    return this.finishNode(node, \"WithStatement\")\r\n  };\r\n\r\n  pp$1.parseEmptyStatement = function(node) {\r\n    this.next();\r\n    return this.finishNode(node, \"EmptyStatement\")\r\n  };\r\n\r\n  pp$1.parseLabeledStatement = function(node, maybeName, expr) {\r\n    var this$1 = this;\r\n\r\n    for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)\r\n      {\r\n      var label = list[i$1];\r\n\r\n      if (label.name === maybeName)\r\n        { this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\r\n    } }\r\n    var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\r\n    for (var i = this.labels.length - 1; i >= 0; i--) {\r\n      var label$1 = this$1.labels[i];\r\n      if (label$1.statementStart === node.start) {\r\n        // Update information about previous labels on this node\r\n        label$1.statementStart = this$1.start;\r\n        label$1.kind = kind;\r\n      } else { break }\r\n    }\r\n    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\r\n    node.body = this.parseStatement(true);\r\n    if (node.body.type === \"ClassDeclaration\" ||\r\n        node.body.type === \"VariableDeclaration\" && node.body.kind !== \"var\" ||\r\n        node.body.type === \"FunctionDeclaration\" && (this.strict || node.body.generator || node.body.async))\r\n      { this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\"); }\r\n    this.labels.pop();\r\n    node.label = expr;\r\n    return this.finishNode(node, \"LabeledStatement\")\r\n  };\r\n\r\n  pp$1.parseExpressionStatement = function(node, expr) {\r\n    node.expression = expr;\r\n    this.semicolon();\r\n    return this.finishNode(node, \"ExpressionStatement\")\r\n  };\r\n\r\n  // Parse a semicolon-enclosed block of statements, handling `\"use\r\n  // strict\"` declarations when `allowStrict` is true (used for\r\n  // function bodies).\r\n\r\n  pp$1.parseBlock = function(createNewLexicalScope) {\r\n    var this$1 = this;\r\n    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\r\n\r\n    var node = this.startNode();\r\n    node.body = [];\r\n    this.expect(types.braceL);\r\n    if (createNewLexicalScope) {\r\n      this.enterLexicalScope();\r\n    }\r\n    while (!this.eat(types.braceR)) {\r\n      var stmt = this$1.parseStatement(true);\r\n      node.body.push(stmt);\r\n    }\r\n    if (createNewLexicalScope) {\r\n      this.exitLexicalScope();\r\n    }\r\n    return this.finishNode(node, \"BlockStatement\")\r\n  };\r\n\r\n  // Parse a regular `for` loop. The disambiguation code in\r\n  // `parseStatement` will already have parsed the init statement or\r\n  // expression.\r\n\r\n  pp$1.parseFor = function(node, init) {\r\n    node.init = init;\r\n    this.expect(types.semi);\r\n    node.test = this.type === types.semi ? null : this.parseExpression();\r\n    this.expect(types.semi);\r\n    node.update = this.type === types.parenR ? null : this.parseExpression();\r\n    this.expect(types.parenR);\r\n    this.exitLexicalScope();\r\n    node.body = this.parseStatement(false);\r\n    this.labels.pop();\r\n    return this.finishNode(node, \"ForStatement\")\r\n  };\r\n\r\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\r\n  // same from parser's perspective.\r\n\r\n  pp$1.parseForIn = function(node, init) {\r\n    var type = this.type === types._in ? \"ForInStatement\" : \"ForOfStatement\";\r\n    this.next();\r\n    if (type === \"ForInStatement\") {\r\n      if (init.type === \"AssignmentPattern\" ||\r\n        (init.type === \"VariableDeclaration\" && init.declarations[0].init != null &&\r\n         (this.strict || init.declarations[0].id.type !== \"Identifier\")))\r\n        { this.raise(init.start, \"Invalid assignment in for-in loop head\"); }\r\n    }\r\n    node.left = init;\r\n    node.right = type === \"ForInStatement\" ? this.parseExpression() : this.parseMaybeAssign();\r\n    this.expect(types.parenR);\r\n    this.exitLexicalScope();\r\n    node.body = this.parseStatement(false);\r\n    this.labels.pop();\r\n    return this.finishNode(node, type)\r\n  };\r\n\r\n  // Parse a list of variable declarations.\r\n\r\n  pp$1.parseVar = function(node, isFor, kind) {\r\n    var this$1 = this;\r\n\r\n    node.declarations = [];\r\n    node.kind = kind;\r\n    for (;;) {\r\n      var decl = this$1.startNode();\r\n      this$1.parseVarId(decl, kind);\r\n      if (this$1.eat(types.eq)) {\r\n        decl.init = this$1.parseMaybeAssign(isFor);\r\n      } else if (kind === \"const\" && !(this$1.type === types._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\r\n        this$1.unexpected();\r\n      } else if (decl.id.type !== \"Identifier\" && !(isFor && (this$1.type === types._in || this$1.isContextual(\"of\")))) {\r\n        this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\");\r\n      } else {\r\n        decl.init = null;\r\n      }\r\n      node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\r\n      if (!this$1.eat(types.comma)) { break }\r\n    }\r\n    return node\r\n  };\r\n\r\n  pp$1.parseVarId = function(decl, kind) {\r\n    decl.id = this.parseBindingAtom(kind);\r\n    this.checkLVal(decl.id, kind, false);\r\n  };\r\n\r\n  // Parse a function declaration or literal (depending on the\r\n  // `isStatement` parameter).\r\n\r\n  pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\r\n    this.initFunction(node);\r\n    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync)\r\n      { node.generator = this.eat(types.star); }\r\n    if (this.options.ecmaVersion >= 8)\r\n      { node.async = !!isAsync; }\r\n\r\n    if (isStatement) {\r\n      node.id = isStatement === \"nullableID\" && this.type !== types.name ? null : this.parseIdent();\r\n      if (node.id) {\r\n        this.checkLVal(node.id, this.inModule && !this.inFunction ? \"let\" : \"var\");\r\n      }\r\n    }\r\n\r\n    var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\r\n        oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\r\n    this.inGenerator = node.generator;\r\n    this.inAsync = node.async;\r\n    this.yieldPos = 0;\r\n    this.awaitPos = 0;\r\n    this.inFunction = true;\r\n    this.enterFunctionScope();\r\n\r\n    if (!isStatement)\r\n      { node.id = this.type === types.name ? this.parseIdent() : null; }\r\n\r\n    this.parseFunctionParams(node);\r\n    this.parseFunctionBody(node, allowExpressionBody);\r\n\r\n    this.inGenerator = oldInGen;\r\n    this.inAsync = oldInAsync;\r\n    this.yieldPos = oldYieldPos;\r\n    this.awaitPos = oldAwaitPos;\r\n    this.inFunction = oldInFunc;\r\n    return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\r\n  };\r\n\r\n  pp$1.parseFunctionParams = function(node) {\r\n    this.expect(types.parenL);\r\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\r\n    this.checkYieldAwaitInDefaultParams();\r\n  };\r\n\r\n  // Parse a class declaration or literal (depending on the\r\n  // `isStatement` parameter).\r\n\r\n  pp$1.parseClass = function(node, isStatement) {\r\n    var this$1 = this;\r\n\r\n    this.next();\r\n\r\n    this.parseClassId(node, isStatement);\r\n    this.parseClassSuper(node);\r\n    var classBody = this.startNode();\r\n    var hadConstructor = false;\r\n    classBody.body = [];\r\n    this.expect(types.braceL);\r\n    while (!this.eat(types.braceR)) {\r\n      var member = this$1.parseClassMember(classBody);\r\n      if (member && member.type === \"MethodDefinition\" && member.kind === \"constructor\") {\r\n        if (hadConstructor) { this$1.raise(member.start, \"Duplicate constructor in the same class\"); }\r\n        hadConstructor = true;\r\n      }\r\n    }\r\n    node.body = this.finishNode(classBody, \"ClassBody\");\r\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\r\n  };\r\n\r\n  pp$1.parseClassMember = function(classBody) {\r\n    var this$1 = this;\r\n\r\n    if (this.eat(types.semi)) { return null }\r\n\r\n    var method = this.startNode();\r\n    var tryContextual = function (k, noLineBreak) {\r\n      if ( noLineBreak === void 0 ) noLineBreak = false;\r\n\r\n      var start = this$1.start, startLoc = this$1.startLoc;\r\n      if (!this$1.eatContextual(k)) { return false }\r\n      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\r\n      if (method.key) { this$1.unexpected(); }\r\n      method.computed = false;\r\n      method.key = this$1.startNodeAt(start, startLoc);\r\n      method.key.name = k;\r\n      this$1.finishNode(method.key, \"Identifier\");\r\n      return false\r\n    };\r\n\r\n    method.kind = \"method\";\r\n    method.static = tryContextual(\"static\");\r\n    var isGenerator = this.eat(types.star);\r\n    var isAsync = false;\r\n    if (!isGenerator) {\r\n      if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\r\n        isAsync = true;\r\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\r\n      } else if (tryContextual(\"get\")) {\r\n        method.kind = \"get\";\r\n      } else if (tryContextual(\"set\")) {\r\n        method.kind = \"set\";\r\n      }\r\n    }\r\n    if (!method.key) { this.parsePropertyName(method); }\r\n    var key = method.key;\r\n    if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\r\n        key.type === \"Literal\" && key.value === \"constructor\")) {\r\n      if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\r\n      if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\r\n      if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\r\n      method.kind = \"constructor\";\r\n    } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\r\n      this.raise(key.start, \"Classes may not have a static property named prototype\");\r\n    }\r\n    this.parseClassMethod(classBody, method, isGenerator, isAsync);\r\n    if (method.kind === \"get\" && method.value.params.length !== 0)\r\n      { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\r\n    if (method.kind === \"set\" && method.value.params.length !== 1)\r\n      { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\r\n    if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\r\n      { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\r\n    return method\r\n  };\r\n\r\n  pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\r\n    method.value = this.parseMethod(isGenerator, isAsync);\r\n    classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\r\n  };\r\n\r\n  pp$1.parseClassId = function(node, isStatement) {\r\n    node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;\r\n  };\r\n\r\n  pp$1.parseClassSuper = function(node) {\r\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\r\n  };\r\n\r\n  // Parses module export declaration.\r\n\r\n  pp$1.parseExport = function(node, exports) {\r\n    var this$1 = this;\r\n\r\n    this.next();\r\n    // export * from '...'\r\n    if (this.eat(types.star)) {\r\n      this.expectContextual(\"from\");\r\n      if (this.type !== types.string) { this.unexpected(); }\r\n      node.source = this.parseExprAtom();\r\n      this.semicolon();\r\n      return this.finishNode(node, \"ExportAllDeclaration\")\r\n    }\r\n    if (this.eat(types._default)) { // export default ...\r\n      this.checkExport(exports, \"default\", this.lastTokStart);\r\n      var isAsync;\r\n      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\r\n        var fNode = this.startNode();\r\n        this.next();\r\n        if (isAsync) { this.next(); }\r\n        node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\r\n      } else if (this.type === types._class) {\r\n        var cNode = this.startNode();\r\n        node.declaration = this.parseClass(cNode, \"nullableID\");\r\n      } else {\r\n        node.declaration = this.parseMaybeAssign();\r\n        this.semicolon();\r\n      }\r\n      return this.finishNode(node, \"ExportDefaultDeclaration\")\r\n    }\r\n    // export var|const|let|function|class ...\r\n    if (this.shouldParseExportStatement()) {\r\n      node.declaration = this.parseStatement(true);\r\n      if (node.declaration.type === \"VariableDeclaration\")\r\n        { this.checkVariableExport(exports, node.declaration.declarations); }\r\n      else\r\n        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\r\n      node.specifiers = [];\r\n      node.source = null;\r\n    } else { // export { x, y as z } [from '...']\r\n      node.declaration = null;\r\n      node.specifiers = this.parseExportSpecifiers(exports);\r\n      if (this.eatContextual(\"from\")) {\r\n        if (this.type !== types.string) { this.unexpected(); }\r\n        node.source = this.parseExprAtom();\r\n      } else {\r\n        // check for keywords used as local names\r\n        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\r\n          var spec = list[i];\r\n\r\n          this$1.checkUnreserved(spec.local);\r\n        }\r\n\r\n        node.source = null;\r\n      }\r\n      this.semicolon();\r\n    }\r\n    return this.finishNode(node, \"ExportNamedDeclaration\")\r\n  };\r\n\r\n  pp$1.checkExport = function(exports, name, pos) {\r\n    if (!exports) { return }\r\n    if (has(exports, name))\r\n      { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\r\n    exports[name] = true;\r\n  };\r\n\r\n  pp$1.checkPatternExport = function(exports, pat) {\r\n    var this$1 = this;\r\n\r\n    var type = pat.type;\r\n    if (type === \"Identifier\")\r\n      { this.checkExport(exports, pat.name, pat.start); }\r\n    else if (type === \"ObjectPattern\")\r\n      { for (var i = 0, list = pat.properties; i < list.length; i += 1)\r\n        {\r\n          var prop = list[i];\r\n\r\n          this$1.checkPatternExport(exports, prop);\r\n        } }\r\n    else if (type === \"ArrayPattern\")\r\n      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\r\n        var elt = list$1[i$1];\r\n\r\n          if (elt) { this$1.checkPatternExport(exports, elt); }\r\n      } }\r\n    else if (type === \"Property\")\r\n      { this.checkPatternExport(exports, pat.value); }\r\n    else if (type === \"AssignmentPattern\")\r\n      { this.checkPatternExport(exports, pat.left); }\r\n    else if (type === \"RestElement\")\r\n      { this.checkPatternExport(exports, pat.argument); }\r\n    else if (type === \"ParenthesizedExpression\")\r\n      { this.checkPatternExport(exports, pat.expression); }\r\n  };\r\n\r\n  pp$1.checkVariableExport = function(exports, decls) {\r\n    var this$1 = this;\r\n\r\n    if (!exports) { return }\r\n    for (var i = 0, list = decls; i < list.length; i += 1)\r\n      {\r\n      var decl = list[i];\r\n\r\n      this$1.checkPatternExport(exports, decl.id);\r\n    }\r\n  };\r\n\r\n  pp$1.shouldParseExportStatement = function() {\r\n    return this.type.keyword === \"var\" ||\r\n      this.type.keyword === \"const\" ||\r\n      this.type.keyword === \"class\" ||\r\n      this.type.keyword === \"function\" ||\r\n      this.isLet() ||\r\n      this.isAsyncFunction()\r\n  };\r\n\r\n  // Parses a comma-separated list of module exports.\r\n\r\n  pp$1.parseExportSpecifiers = function(exports) {\r\n    var this$1 = this;\r\n\r\n    var nodes = [], first = true;\r\n    // export { x, y as z } [from '...']\r\n    this.expect(types.braceL);\r\n    while (!this.eat(types.braceR)) {\r\n      if (!first) {\r\n        this$1.expect(types.comma);\r\n        if (this$1.afterTrailingComma(types.braceR)) { break }\r\n      } else { first = false; }\r\n\r\n      var node = this$1.startNode();\r\n      node.local = this$1.parseIdent(true);\r\n      node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local;\r\n      this$1.checkExport(exports, node.exported.name, node.exported.start);\r\n      nodes.push(this$1.finishNode(node, \"ExportSpecifier\"));\r\n    }\r\n    return nodes\r\n  };\r\n\r\n  // Parses import declaration.\r\n\r\n  pp$1.parseImport = function(node) {\r\n    this.next();\r\n    // import '...'\r\n    if (this.type === types.string) {\r\n      node.specifiers = empty;\r\n      node.source = this.parseExprAtom();\r\n    } else {\r\n      node.specifiers = this.parseImportSpecifiers();\r\n      this.expectContextual(\"from\");\r\n      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\r\n    }\r\n    this.semicolon();\r\n    return this.finishNode(node, \"ImportDeclaration\")\r\n  };\r\n\r\n  // Parses a comma-separated list of module imports.\r\n\r\n  pp$1.parseImportSpecifiers = function() {\r\n    var this$1 = this;\r\n\r\n    var nodes = [], first = true;\r\n    if (this.type === types.name) {\r\n      // import defaultObj, { x, y as z } from '...'\r\n      var node = this.startNode();\r\n      node.local = this.parseIdent();\r\n      this.checkLVal(node.local, \"let\");\r\n      nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\r\n      if (!this.eat(types.comma)) { return nodes }\r\n    }\r\n    if (this.type === types.star) {\r\n      var node$1 = this.startNode();\r\n      this.next();\r\n      this.expectContextual(\"as\");\r\n      node$1.local = this.parseIdent();\r\n      this.checkLVal(node$1.local, \"let\");\r\n      nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\r\n      return nodes\r\n    }\r\n    this.expect(types.braceL);\r\n    while (!this.eat(types.braceR)) {\r\n      if (!first) {\r\n        this$1.expect(types.comma);\r\n        if (this$1.afterTrailingComma(types.braceR)) { break }\r\n      } else { first = false; }\r\n\r\n      var node$2 = this$1.startNode();\r\n      node$2.imported = this$1.parseIdent(true);\r\n      if (this$1.eatContextual(\"as\")) {\r\n        node$2.local = this$1.parseIdent();\r\n      } else {\r\n        this$1.checkUnreserved(node$2.imported);\r\n        node$2.local = node$2.imported;\r\n      }\r\n      this$1.checkLVal(node$2.local, \"let\");\r\n      nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\r\n    }\r\n    return nodes\r\n  };\r\n\r\n  // Set `ExpressionStatement#directive` property for directive prologues.\r\n  pp$1.adaptDirectivePrologue = function(statements) {\r\n    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\r\n      statements[i].directive = statements[i].expression.raw.slice(1, -1);\r\n    }\r\n  };\r\n  pp$1.isDirectiveCandidate = function(statement) {\r\n    return (\r\n      statement.type === \"ExpressionStatement\" &&\r\n      statement.expression.type === \"Literal\" &&\r\n      typeof statement.expression.value === \"string\" &&\r\n      // Reject parenthesized strings.\r\n      (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\r\n    )\r\n  };\r\n\r\n  var pp$2 = Parser.prototype;\r\n\r\n  // Convert existing expression atom to assignable pattern\r\n  // if possible.\r\n\r\n  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\r\n    var this$1 = this;\r\n\r\n    if (this.options.ecmaVersion >= 6 && node) {\r\n      switch (node.type) {\r\n      case \"Identifier\":\r\n        if (this.inAsync && node.name === \"await\")\r\n          { this.raise(node.start, \"Can not use 'await' as identifier inside an async function\"); }\r\n        break\r\n\r\n      case \"ObjectPattern\":\r\n      case \"ArrayPattern\":\r\n      case \"RestElement\":\r\n        break\r\n\r\n      case \"ObjectExpression\":\r\n        node.type = \"ObjectPattern\";\r\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\r\n        for (var i = 0, list = node.properties; i < list.length; i += 1) {\r\n          var prop = list[i];\r\n\r\n        this$1.toAssignable(prop, isBinding);\r\n          // Early error:\r\n          //   AssignmentRestProperty[Yield, Await] :\r\n          //     `...` DestructuringAssignmentTarget[Yield, Await]\r\n          //\r\n          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\r\n          if (\r\n            prop.type === \"RestElement\" &&\r\n            (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\r\n          ) {\r\n            this$1.raise(prop.argument.start, \"Unexpected token\");\r\n          }\r\n        }\r\n        break\r\n\r\n      case \"Property\":\r\n        // AssignmentProperty has type === \"Property\"\r\n        if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\r\n        this.toAssignable(node.value, isBinding);\r\n        break\r\n\r\n      case \"ArrayExpression\":\r\n        node.type = \"ArrayPattern\";\r\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\r\n        this.toAssignableList(node.elements, isBinding);\r\n        break\r\n\r\n      case \"SpreadElement\":\r\n        node.type = \"RestElement\";\r\n        this.toAssignable(node.argument, isBinding);\r\n        if (node.argument.type === \"AssignmentPattern\")\r\n          { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\r\n        break\r\n\r\n      case \"AssignmentExpression\":\r\n        if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\r\n        node.type = \"AssignmentPattern\";\r\n        delete node.operator;\r\n        this.toAssignable(node.left, isBinding);\r\n        // falls through to AssignmentPattern\r\n\r\n      case \"AssignmentPattern\":\r\n        break\r\n\r\n      case \"ParenthesizedExpression\":\r\n        this.toAssignable(node.expression, isBinding);\r\n        break\r\n\r\n      case \"MemberExpression\":\r\n        if (!isBinding) { break }\r\n\r\n      default:\r\n        this.raise(node.start, \"Assigning to rvalue\");\r\n      }\r\n    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\r\n    return node\r\n  };\r\n\r\n  // Convert list of expression atoms to binding list.\r\n\r\n  pp$2.toAssignableList = function(exprList, isBinding) {\r\n    var this$1 = this;\r\n\r\n    var end = exprList.length;\r\n    for (var i = 0; i < end; i++) {\r\n      var elt = exprList[i];\r\n      if (elt) { this$1.toAssignable(elt, isBinding); }\r\n    }\r\n    if (end) {\r\n      var last = exprList[end - 1];\r\n      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\r\n        { this.unexpected(last.argument.start); }\r\n    }\r\n    return exprList\r\n  };\r\n\r\n  // Parses spread element.\r\n\r\n  pp$2.parseSpread = function(refDestructuringErrors) {\r\n    var node = this.startNode();\r\n    this.next();\r\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\r\n    return this.finishNode(node, \"SpreadElement\")\r\n  };\r\n\r\n  pp$2.parseRestBinding = function() {\r\n    var node = this.startNode();\r\n    this.next();\r\n\r\n    // RestElement inside of a function parameter must be an identifier\r\n    if (this.options.ecmaVersion === 6 && this.type !== types.name)\r\n      { this.unexpected(); }\r\n\r\n    node.argument = this.parseBindingAtom();\r\n\r\n    return this.finishNode(node, \"RestElement\")\r\n  };\r\n\r\n  // Parses lvalue (assignable) atom.\r\n\r\n  pp$2.parseBindingAtom = function() {\r\n    if (this.options.ecmaVersion >= 6) {\r\n      switch (this.type) {\r\n      case types.bracketL:\r\n        var node = this.startNode();\r\n        this.next();\r\n        node.elements = this.parseBindingList(types.bracketR, true, true);\r\n        return this.finishNode(node, \"ArrayPattern\")\r\n\r\n      case types.braceL:\r\n        return this.parseObj(true)\r\n      }\r\n    }\r\n    return this.parseIdent()\r\n  };\r\n\r\n  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\r\n    var this$1 = this;\r\n\r\n    var elts = [], first = true;\r\n    while (!this.eat(close)) {\r\n      if (first) { first = false; }\r\n      else { this$1.expect(types.comma); }\r\n      if (allowEmpty && this$1.type === types.comma) {\r\n        elts.push(null);\r\n      } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\r\n        break\r\n      } else if (this$1.type === types.ellipsis) {\r\n        var rest = this$1.parseRestBinding();\r\n        this$1.parseBindingListItem(rest);\r\n        elts.push(rest);\r\n        if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\r\n        this$1.expect(close);\r\n        break\r\n      } else {\r\n        var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);\r\n        this$1.parseBindingListItem(elem);\r\n        elts.push(elem);\r\n      }\r\n    }\r\n    return elts\r\n  };\r\n\r\n  pp$2.parseBindingListItem = function(param) {\r\n    return param\r\n  };\r\n\r\n  // Parses assignment pattern around given atom if possible.\r\n\r\n  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {\r\n    left = left || this.parseBindingAtom();\r\n    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\r\n    var node = this.startNodeAt(startPos, startLoc);\r\n    node.left = left;\r\n    node.right = this.parseMaybeAssign();\r\n    return this.finishNode(node, \"AssignmentPattern\")\r\n  };\r\n\r\n  // Verify that a node is an lval  something that can be assigned\r\n  // to.\r\n  // bindingType can be either:\r\n  // 'var' indicating that the lval creates a 'var' binding\r\n  // 'let' indicating that the lval creates a lexical ('let' or 'const') binding\r\n  // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\r\n\r\n  pp$2.checkLVal = function(expr, bindingType, checkClashes) {\r\n    var this$1 = this;\r\n\r\n    switch (expr.type) {\r\n    case \"Identifier\":\r\n      if (this.strict && this.reservedWordsStrictBind.test(expr.name))\r\n        { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\r\n      if (checkClashes) {\r\n        if (has(checkClashes, expr.name))\r\n          { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\r\n        checkClashes[expr.name] = true;\r\n      }\r\n      if (bindingType && bindingType !== \"none\") {\r\n        if (\r\n          bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\r\n          bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\r\n        ) {\r\n          this.raiseRecoverable(expr.start, (\"Identifier '\" + (expr.name) + \"' has already been declared\"));\r\n        }\r\n        if (bindingType === \"var\") {\r\n          this.declareVarName(expr.name);\r\n        } else {\r\n          this.declareLexicalName(expr.name);\r\n        }\r\n      }\r\n      break\r\n\r\n    case \"MemberExpression\":\r\n      if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\r\n      break\r\n\r\n    case \"ObjectPattern\":\r\n      for (var i = 0, list = expr.properties; i < list.length; i += 1)\r\n        {\r\n      var prop = list[i];\r\n\r\n      this$1.checkLVal(prop, bindingType, checkClashes);\r\n    }\r\n      break\r\n\r\n    case \"Property\":\r\n      // AssignmentProperty has type === \"Property\"\r\n      this.checkLVal(expr.value, bindingType, checkClashes);\r\n      break\r\n\r\n    case \"ArrayPattern\":\r\n      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\r\n        var elem = list$1[i$1];\r\n\r\n      if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }\r\n      }\r\n      break\r\n\r\n    case \"AssignmentPattern\":\r\n      this.checkLVal(expr.left, bindingType, checkClashes);\r\n      break\r\n\r\n    case \"RestElement\":\r\n      this.checkLVal(expr.argument, bindingType, checkClashes);\r\n      break\r\n\r\n    case \"ParenthesizedExpression\":\r\n      this.checkLVal(expr.expression, bindingType, checkClashes);\r\n      break\r\n\r\n    default:\r\n      this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\r\n    }\r\n  };\r\n\r\n  // A recursive descent parser operates by defining functions for all\r\n  // syntactic elements, and recursively calling those, each function\r\n  // advancing the input stream and returning an AST node. Precedence\r\n  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\r\n  // instead of `(!x)[1]` is handled by the fact that the parser\r\n  // function that parses unary prefix operators is called first, and\r\n  // in turn calls the function that parses `[]` subscripts  that\r\n  // way, it'll receive the node for `x[1]` already parsed, and wraps\r\n  // *that* in the unary operator node.\r\n  //\r\n  // Acorn uses an [operator precedence parser][opp] to handle binary\r\n  // operator precedence, because it is much more compact than using\r\n  // the technique outlined above, which uses different, nesting\r\n  // functions to specify precedence, for all of the ten binary\r\n  // precedence levels that JavaScript defines.\r\n  //\r\n  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\r\n\r\n  var pp$3 = Parser.prototype;\r\n\r\n  // Check if property name clashes with already added.\r\n  // Object/class getters and setters are not allowed to clash \r\n  // either with each other or with an init property  and in\r\n  // strict mode, init properties are also not allowed to be repeated.\r\n\r\n  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\r\n    if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\r\n      { return }\r\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\r\n      { return }\r\n    var key = prop.key;\r\n    var name;\r\n    switch (key.type) {\r\n    case \"Identifier\": name = key.name; break\r\n    case \"Literal\": name = String(key.value); break\r\n    default: return\r\n    }\r\n    var kind = prop.kind;\r\n    if (this.options.ecmaVersion >= 6) {\r\n      if (name === \"__proto__\" && kind === \"init\") {\r\n        if (propHash.proto) {\r\n          if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }\r\n          // Backwards-compat kludge. Can be removed in version 6.0\r\n          else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\r\n        }\r\n        propHash.proto = true;\r\n      }\r\n      return\r\n    }\r\n    name = \"$\" + name;\r\n    var other = propHash[name];\r\n    if (other) {\r\n      var redefinition;\r\n      if (kind === \"init\") {\r\n        redefinition = this.strict && other.init || other.get || other.set;\r\n      } else {\r\n        redefinition = other.init || other[kind];\r\n      }\r\n      if (redefinition)\r\n        { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\r\n    } else {\r\n      other = propHash[name] = {\r\n        init: false,\r\n        get: false,\r\n        set: false\r\n      };\r\n    }\r\n    other[kind] = true;\r\n  };\r\n\r\n  // ### Expression parsing\r\n\r\n  // These nest, from the most general expression type at the top to\r\n  // 'atomic', nondivisible expression types at the bottom. Most of\r\n  // the functions will simply let the function(s) below them parse,\r\n  // and, *if* the syntactic construct they handle is present, wrap\r\n  // the AST node that the inner parser gave them in another node.\r\n\r\n  // Parse a full expression. The optional arguments are used to\r\n  // forbid the `in` operator (in for loops initalization expressions)\r\n  // and provide reference for storing '=' operator inside shorthand\r\n  // property assignment in contexts where both object expression\r\n  // and object pattern might appear (so it's possible to raise\r\n  // delayed syntax error at correct position).\r\n\r\n  pp$3.parseExpression = function(noIn, refDestructuringErrors) {\r\n    var this$1 = this;\r\n\r\n    var startPos = this.start, startLoc = this.startLoc;\r\n    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\r\n    if (this.type === types.comma) {\r\n      var node = this.startNodeAt(startPos, startLoc);\r\n      node.expressions = [expr];\r\n      while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }\r\n      return this.finishNode(node, \"SequenceExpression\")\r\n    }\r\n    return expr\r\n  };\r\n\r\n  // Parse an assignment expression. This includes applications of\r\n  // operators like `+=`.\r\n\r\n  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\r\n    if (this.inGenerator && this.isContextual(\"yield\")) { return this.parseYield() }\r\n\r\n    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\r\n    if (refDestructuringErrors) {\r\n      oldParenAssign = refDestructuringErrors.parenthesizedAssign;\r\n      oldTrailingComma = refDestructuringErrors.trailingComma;\r\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\r\n    } else {\r\n      refDestructuringErrors = new DestructuringErrors;\r\n      ownDestructuringErrors = true;\r\n    }\r\n\r\n    var startPos = this.start, startLoc = this.startLoc;\r\n    if (this.type === types.parenL || this.type === types.name)\r\n      { this.potentialArrowAt = this.start; }\r\n    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\r\n    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\r\n    if (this.type.isAssign) {\r\n      var node = this.startNodeAt(startPos, startLoc);\r\n      node.operator = this.value;\r\n      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\r\n      if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\r\n      refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\r\n      this.checkLVal(left);\r\n      this.next();\r\n      node.right = this.parseMaybeAssign(noIn);\r\n      return this.finishNode(node, \"AssignmentExpression\")\r\n    } else {\r\n      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\r\n    }\r\n    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\r\n    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\r\n    return left\r\n  };\r\n\r\n  // Parse a ternary conditional (`?:`) operator.\r\n\r\n  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\r\n    var startPos = this.start, startLoc = this.startLoc;\r\n    var expr = this.parseExprOps(noIn, refDestructuringErrors);\r\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\r\n    if (this.eat(types.question)) {\r\n      var node = this.startNodeAt(startPos, startLoc);\r\n      node.test = expr;\r\n      node.consequent = this.parseMaybeAssign();\r\n      this.expect(types.colon);\r\n      node.alternate = this.parseMaybeAssign(noIn);\r\n      return this.finishNode(node, \"ConditionalExpression\")\r\n    }\r\n    return expr\r\n  };\r\n\r\n  // Start the precedence parser.\r\n\r\n  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {\r\n    var startPos = this.start, startLoc = this.startLoc;\r\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false);\r\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\r\n    return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\r\n  };\r\n\r\n  // Parse binary operators with the operator precedence parsing\r\n  // algorithm. `left` is the left-hand side of the operator.\r\n  // `minPrec` provides context that allows the function to stop and\r\n  // defer further parser to one of its callers when it encounters an\r\n  // operator that has a lower precedence than the set it is parsing.\r\n\r\n  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\r\n    var prec = this.type.binop;\r\n    if (prec != null && (!noIn || this.type !== types._in)) {\r\n      if (prec > minPrec) {\r\n        var logical = this.type === types.logicalOR || this.type === types.logicalAND;\r\n        var op = this.value;\r\n        this.next();\r\n        var startPos = this.start, startLoc = this.startLoc;\r\n        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\r\n        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\r\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\r\n      }\r\n    }\r\n    return left\r\n  };\r\n\r\n  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\r\n    var node = this.startNodeAt(startPos, startLoc);\r\n    node.left = left;\r\n    node.operator = op;\r\n    node.right = right;\r\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\r\n  };\r\n\r\n  // Parse unary operators, both prefix and postfix.\r\n\r\n  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\r\n    var this$1 = this;\r\n\r\n    var startPos = this.start, startLoc = this.startLoc, expr;\r\n    if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\r\n      expr = this.parseAwait();\r\n      sawUnary = true;\r\n    } else if (this.type.prefix) {\r\n      var node = this.startNode(), update = this.type === types.incDec;\r\n      node.operator = this.value;\r\n      node.prefix = true;\r\n      this.next();\r\n      node.argument = this.parseMaybeUnary(null, true);\r\n      this.checkExpressionErrors(refDestructuringErrors, true);\r\n      if (update) { this.checkLVal(node.argument); }\r\n      else if (this.strict && node.operator === \"delete\" &&\r\n               node.argument.type === \"Identifier\")\r\n        { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\r\n      else { sawUnary = true; }\r\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\r\n    } else {\r\n      expr = this.parseExprSubscripts(refDestructuringErrors);\r\n      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\r\n      while (this.type.postfix && !this.canInsertSemicolon()) {\r\n        var node$1 = this$1.startNodeAt(startPos, startLoc);\r\n        node$1.operator = this$1.value;\r\n        node$1.prefix = false;\r\n        node$1.argument = expr;\r\n        this$1.checkLVal(expr);\r\n        this$1.next();\r\n        expr = this$1.finishNode(node$1, \"UpdateExpression\");\r\n      }\r\n    }\r\n\r\n    if (!sawUnary && this.eat(types.starstar))\r\n      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\r\n    else\r\n      { return expr }\r\n  };\r\n\r\n  // Parse call, dot, and `[]`-subscript expressions.\r\n\r\n  pp$3.parseExprSubscripts = function(refDestructuringErrors) {\r\n    var startPos = this.start, startLoc = this.startLoc;\r\n    var expr = this.parseExprAtom(refDestructuringErrors);\r\n    var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\r\n    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\r\n    var result = this.parseSubscripts(expr, startPos, startLoc);\r\n    if (refDestructuringErrors && result.type === \"MemberExpression\") {\r\n      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\r\n      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\r\n    }\r\n    return result\r\n  };\r\n\r\n  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\r\n    var this$1 = this;\r\n\r\n    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\r\n        this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\r\n    for (var computed = (void 0);;) {\r\n      if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {\r\n        var node = this$1.startNodeAt(startPos, startLoc);\r\n        node.object = base;\r\n        node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);\r\n        node.computed = !!computed;\r\n        if (computed) { this$1.expect(types.bracketR); }\r\n        base = this$1.finishNode(node, \"MemberExpression\");\r\n      } else if (!noCalls && this$1.eat(types.parenL)) {\r\n        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;\r\n        this$1.yieldPos = 0;\r\n        this$1.awaitPos = 0;\r\n        var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\r\n        if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\r\n          this$1.checkPatternErrors(refDestructuringErrors, false);\r\n          this$1.checkYieldAwaitInDefaultParams();\r\n          this$1.yieldPos = oldYieldPos;\r\n          this$1.awaitPos = oldAwaitPos;\r\n          return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\r\n        }\r\n        this$1.checkExpressionErrors(refDestructuringErrors, true);\r\n        this$1.yieldPos = oldYieldPos || this$1.yieldPos;\r\n        this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\r\n        var node$1 = this$1.startNodeAt(startPos, startLoc);\r\n        node$1.callee = base;\r\n        node$1.arguments = exprList;\r\n        base = this$1.finishNode(node$1, \"CallExpression\");\r\n      } else if (this$1.type === types.backQuote) {\r\n        var node$2 = this$1.startNodeAt(startPos, startLoc);\r\n        node$2.tag = base;\r\n        node$2.quasi = this$1.parseTemplate({isTagged: true});\r\n        base = this$1.finishNode(node$2, \"TaggedTemplateExpression\");\r\n      } else {\r\n        return base\r\n      }\r\n    }\r\n  };\r\n\r\n  // Parse an atomic expression  either a single token that is an\r\n  // expression, an expression started by a keyword like `function` or\r\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\r\n  // or `{}`.\r\n\r\n  pp$3.parseExprAtom = function(refDestructuringErrors) {\r\n    var node, canBeArrow = this.potentialArrowAt === this.start;\r\n    switch (this.type) {\r\n    case types._super:\r\n      if (!this.inFunction)\r\n        { this.raise(this.start, \"'super' outside of function or class\"); }\r\n      node = this.startNode();\r\n      this.next();\r\n      // The `super` keyword can appear at below:\r\n      // SuperProperty:\r\n      //     super [ Expression ]\r\n      //     super . IdentifierName\r\n      // SuperCall:\r\n      //     super Arguments\r\n      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\r\n        { this.unexpected(); }\r\n      return this.finishNode(node, \"Super\")\r\n\r\n    case types._this:\r\n      node = this.startNode();\r\n      this.next();\r\n      return this.finishNode(node, \"ThisExpression\")\r\n\r\n    case types.name:\r\n      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\r\n      var id = this.parseIdent(this.type !== types.name);\r\n      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\r\n        { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }\r\n      if (canBeArrow && !this.canInsertSemicolon()) {\r\n        if (this.eat(types.arrow))\r\n          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\r\n        if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\r\n          id = this.parseIdent();\r\n          if (this.canInsertSemicolon() || !this.eat(types.arrow))\r\n            { this.unexpected(); }\r\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\r\n        }\r\n      }\r\n      return id\r\n\r\n    case types.regexp:\r\n      var value = this.value;\r\n      node = this.parseLiteral(value.value);\r\n      node.regex = {pattern: value.pattern, flags: value.flags};\r\n      return node\r\n\r\n    case types.num: case types.string:\r\n      return this.parseLiteral(this.value)\r\n\r\n    case types._null: case types._true: case types._false:\r\n      node = this.startNode();\r\n      node.value = this.type === types._null ? null : this.type === types._true;\r\n      node.raw = this.type.keyword;\r\n      this.next();\r\n      return this.finishNode(node, \"Literal\")\r\n\r\n    case types.parenL:\r\n      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\r\n      if (refDestructuringErrors) {\r\n        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\r\n          { refDestructuringErrors.parenthesizedAssign = start; }\r\n        if (refDestructuringErrors.parenthesizedBind < 0)\r\n          { refDestructuringErrors.parenthesizedBind = start; }\r\n      }\r\n      return expr\r\n\r\n    case types.bracketL:\r\n      node = this.startNode();\r\n      this.next();\r\n      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\r\n      return this.finishNode(node, \"ArrayExpression\")\r\n\r\n    case types.braceL:\r\n      return this.parseObj(false, refDestructuringErrors)\r\n\r\n    case types._function:\r\n      node = this.startNode();\r\n      this.next();\r\n      return this.parseFunction(node, false)\r\n\r\n    case types._class:\r\n      return this.parseClass(this.startNode(), false)\r\n\r\n    case types._new:\r\n      return this.parseNew()\r\n\r\n    case types.backQuote:\r\n      return this.parseTemplate()\r\n\r\n    default:\r\n      this.unexpected();\r\n    }\r\n  };\r\n\r\n  pp$3.parseLiteral = function(value) {\r\n    var node = this.startNode();\r\n    node.value = value;\r\n    node.raw = this.input.slice(this.start, this.end);\r\n    this.next();\r\n    return this.finishNode(node, \"Literal\")\r\n  };\r\n\r\n  pp$3.parseParenExpression = function() {\r\n    this.expect(types.parenL);\r\n    var val = this.parseExpression();\r\n    this.expect(types.parenR);\r\n    return val\r\n  };\r\n\r\n  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\r\n    var this$1 = this;\r\n\r\n    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\r\n    if (this.options.ecmaVersion >= 6) {\r\n      this.next();\r\n\r\n      var innerStartPos = this.start, innerStartLoc = this.startLoc;\r\n      var exprList = [], first = true, lastIsComma = false;\r\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\r\n      this.yieldPos = 0;\r\n      this.awaitPos = 0;\r\n      while (this.type !== types.parenR) {\r\n        first ? first = false : this$1.expect(types.comma);\r\n        if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {\r\n          lastIsComma = true;\r\n          break\r\n        } else if (this$1.type === types.ellipsis) {\r\n          spreadStart = this$1.start;\r\n          exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));\r\n          if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\r\n          break\r\n        } else {\r\n          exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));\r\n        }\r\n      }\r\n      var innerEndPos = this.start, innerEndLoc = this.startLoc;\r\n      this.expect(types.parenR);\r\n\r\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\r\n        this.checkPatternErrors(refDestructuringErrors, false);\r\n        this.checkYieldAwaitInDefaultParams();\r\n        this.yieldPos = oldYieldPos;\r\n        this.awaitPos = oldAwaitPos;\r\n        return this.parseParenArrowList(startPos, startLoc, exprList)\r\n      }\r\n\r\n      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\r\n      if (spreadStart) { this.unexpected(spreadStart); }\r\n      this.checkExpressionErrors(refDestructuringErrors, true);\r\n      this.yieldPos = oldYieldPos || this.yieldPos;\r\n      this.awaitPos = oldAwaitPos || this.awaitPos;\r\n\r\n      if (exprList.length > 1) {\r\n        val = this.startNodeAt(innerStartPos, innerStartLoc);\r\n        val.expressions = exprList;\r\n        this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\r\n      } else {\r\n        val = exprList[0];\r\n      }\r\n    } else {\r\n      val = this.parseParenExpression();\r\n    }\r\n\r\n    if (this.options.preserveParens) {\r\n      var par = this.startNodeAt(startPos, startLoc);\r\n      par.expression = val;\r\n      return this.finishNode(par, \"ParenthesizedExpression\")\r\n    } else {\r\n      return val\r\n    }\r\n  };\r\n\r\n  pp$3.parseParenItem = function(item) {\r\n    return item\r\n  };\r\n\r\n  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\r\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\r\n  };\r\n\r\n  // New's precedence is slightly tricky. It must allow its argument to\r\n  // be a `[]` or dot subscript expression, but not a call  at least,\r\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\r\n  // argument to parseSubscripts to prevent it from consuming the\r\n  // argument list.\r\n\r\n  var empty$1 = [];\r\n\r\n  pp$3.parseNew = function() {\r\n    var node = this.startNode();\r\n    var meta = this.parseIdent(true);\r\n    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\r\n      node.meta = meta;\r\n      var containsEsc = this.containsEsc;\r\n      node.property = this.parseIdent(true);\r\n      if (node.property.name !== \"target\" || containsEsc)\r\n        { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\r\n      if (!this.inFunction)\r\n        { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\r\n      return this.finishNode(node, \"MetaProperty\")\r\n    }\r\n    var startPos = this.start, startLoc = this.startLoc;\r\n    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\r\n    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\r\n    else { node.arguments = empty$1; }\r\n    return this.finishNode(node, \"NewExpression\")\r\n  };\r\n\r\n  // Parse template expression.\r\n\r\n  pp$3.parseTemplateElement = function(ref) {\r\n    var isTagged = ref.isTagged;\r\n\r\n    var elem = this.startNode();\r\n    if (this.type === types.invalidTemplate) {\r\n      if (!isTagged) {\r\n        this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\r\n      }\r\n      elem.value = {\r\n        raw: this.value,\r\n        cooked: null\r\n      };\r\n    } else {\r\n      elem.value = {\r\n        raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\r\n        cooked: this.value\r\n      };\r\n    }\r\n    this.next();\r\n    elem.tail = this.type === types.backQuote;\r\n    return this.finishNode(elem, \"TemplateElement\")\r\n  };\r\n\r\n  pp$3.parseTemplate = function(ref) {\r\n    var this$1 = this;\r\n    if ( ref === void 0 ) ref = {};\r\n    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\r\n\r\n    var node = this.startNode();\r\n    this.next();\r\n    node.expressions = [];\r\n    var curElt = this.parseTemplateElement({isTagged: isTagged});\r\n    node.quasis = [curElt];\r\n    while (!curElt.tail) {\r\n      this$1.expect(types.dollarBraceL);\r\n      node.expressions.push(this$1.parseExpression());\r\n      this$1.expect(types.braceR);\r\n      node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));\r\n    }\r\n    this.next();\r\n    return this.finishNode(node, \"TemplateLiteral\")\r\n  };\r\n\r\n  pp$3.isAsyncProp = function(prop) {\r\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\r\n      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\r\n      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\r\n  };\r\n\r\n  // Parse an object literal or binding pattern.\r\n\r\n  pp$3.parseObj = function(isPattern, refDestructuringErrors) {\r\n    var this$1 = this;\r\n\r\n    var node = this.startNode(), first = true, propHash = {};\r\n    node.properties = [];\r\n    this.next();\r\n    while (!this.eat(types.braceR)) {\r\n      if (!first) {\r\n        this$1.expect(types.comma);\r\n        if (this$1.afterTrailingComma(types.braceR)) { break }\r\n      } else { first = false; }\r\n\r\n      var prop = this$1.parseProperty(isPattern, refDestructuringErrors);\r\n      if (!isPattern) { this$1.checkPropClash(prop, propHash, refDestructuringErrors); }\r\n      node.properties.push(prop);\r\n    }\r\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\r\n  };\r\n\r\n  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {\r\n    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\r\n    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\r\n      if (isPattern) {\r\n        prop.argument = this.parseIdent(false);\r\n        if (this.type === types.comma) {\r\n          this.raise(this.start, \"Comma is not permitted after the rest element\");\r\n        }\r\n        return this.finishNode(prop, \"RestElement\")\r\n      }\r\n      // To disallow parenthesized identifier via `this.toAssignable()`.\r\n      if (this.type === types.parenL && refDestructuringErrors) {\r\n        if (refDestructuringErrors.parenthesizedAssign < 0) {\r\n          refDestructuringErrors.parenthesizedAssign = this.start;\r\n        }\r\n        if (refDestructuringErrors.parenthesizedBind < 0) {\r\n          refDestructuringErrors.parenthesizedBind = this.start;\r\n        }\r\n      }\r\n      // Parse argument.\r\n      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\r\n      // To disallow trailing comma via `this.toAssignable()`.\r\n      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\r\n        refDestructuringErrors.trailingComma = this.start;\r\n      }\r\n      // Finish\r\n      return this.finishNode(prop, \"SpreadElement\")\r\n    }\r\n    if (this.options.ecmaVersion >= 6) {\r\n      prop.method = false;\r\n      prop.shorthand = false;\r\n      if (isPattern || refDestructuringErrors) {\r\n        startPos = this.start;\r\n        startLoc = this.startLoc;\r\n      }\r\n      if (!isPattern)\r\n        { isGenerator = this.eat(types.star); }\r\n    }\r\n    var containsEsc = this.containsEsc;\r\n    this.parsePropertyName(prop);\r\n    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\r\n      isAsync = true;\r\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\r\n      this.parsePropertyName(prop, refDestructuringErrors);\r\n    } else {\r\n      isAsync = false;\r\n    }\r\n    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\r\n    return this.finishNode(prop, \"Property\")\r\n  };\r\n\r\n  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\r\n    if ((isGenerator || isAsync) && this.type === types.colon)\r\n      { this.unexpected(); }\r\n\r\n    if (this.eat(types.colon)) {\r\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\r\n      prop.kind = \"init\";\r\n    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\r\n      if (isPattern) { this.unexpected(); }\r\n      prop.kind = \"init\";\r\n      prop.method = true;\r\n      prop.value = this.parseMethod(isGenerator, isAsync);\r\n    } else if (!isPattern && !containsEsc &&\r\n               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\r\n               (prop.key.name === \"get\" || prop.key.name === \"set\") &&\r\n               (this.type !== types.comma && this.type !== types.braceR)) {\r\n      if (isGenerator || isAsync) { this.unexpected(); }\r\n      prop.kind = prop.key.name;\r\n      this.parsePropertyName(prop);\r\n      prop.value = this.parseMethod(false);\r\n      var paramCount = prop.kind === \"get\" ? 0 : 1;\r\n      if (prop.value.params.length !== paramCount) {\r\n        var start = prop.value.start;\r\n        if (prop.kind === \"get\")\r\n          { this.raiseRecoverable(start, \"getter should have no params\"); }\r\n        else\r\n          { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\r\n      } else {\r\n        if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\r\n          { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\r\n      }\r\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\r\n      this.checkUnreserved(prop.key);\r\n      prop.kind = \"init\";\r\n      if (isPattern) {\r\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\r\n      } else if (this.type === types.eq && refDestructuringErrors) {\r\n        if (refDestructuringErrors.shorthandAssign < 0)\r\n          { refDestructuringErrors.shorthandAssign = this.start; }\r\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\r\n      } else {\r\n        prop.value = prop.key;\r\n      }\r\n      prop.shorthand = true;\r\n    } else { this.unexpected(); }\r\n  };\r\n\r\n  pp$3.parsePropertyName = function(prop) {\r\n    if (this.options.ecmaVersion >= 6) {\r\n      if (this.eat(types.bracketL)) {\r\n        prop.computed = true;\r\n        prop.key = this.parseMaybeAssign();\r\n        this.expect(types.bracketR);\r\n        return prop.key\r\n      } else {\r\n        prop.computed = false;\r\n      }\r\n    }\r\n    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)\r\n  };\r\n\r\n  // Initialize empty function node.\r\n\r\n  pp$3.initFunction = function(node) {\r\n    node.id = null;\r\n    if (this.options.ecmaVersion >= 6) {\r\n      node.generator = false;\r\n      node.expression = false;\r\n    }\r\n    if (this.options.ecmaVersion >= 8)\r\n      { node.async = false; }\r\n  };\r\n\r\n  // Parse object or class method.\r\n\r\n  pp$3.parseMethod = function(isGenerator, isAsync) {\r\n    var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\r\n        oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\r\n\r\n    this.initFunction(node);\r\n    if (this.options.ecmaVersion >= 6)\r\n      { node.generator = isGenerator; }\r\n    if (this.options.ecmaVersion >= 8)\r\n      { node.async = !!isAsync; }\r\n\r\n    this.inGenerator = node.generator;\r\n    this.inAsync = node.async;\r\n    this.yieldPos = 0;\r\n    this.awaitPos = 0;\r\n    this.inFunction = true;\r\n    this.enterFunctionScope();\r\n\r\n    this.expect(types.parenL);\r\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\r\n    this.checkYieldAwaitInDefaultParams();\r\n    this.parseFunctionBody(node, false);\r\n\r\n    this.inGenerator = oldInGen;\r\n    this.inAsync = oldInAsync;\r\n    this.yieldPos = oldYieldPos;\r\n    this.awaitPos = oldAwaitPos;\r\n    this.inFunction = oldInFunc;\r\n    return this.finishNode(node, \"FunctionExpression\")\r\n  };\r\n\r\n  // Parse arrow function expression with given parameters.\r\n\r\n  pp$3.parseArrowExpression = function(node, params, isAsync) {\r\n    var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\r\n        oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\r\n\r\n    this.enterFunctionScope();\r\n    this.initFunction(node);\r\n    if (this.options.ecmaVersion >= 8)\r\n      { node.async = !!isAsync; }\r\n\r\n    this.inGenerator = false;\r\n    this.inAsync = node.async;\r\n    this.yieldPos = 0;\r\n    this.awaitPos = 0;\r\n    this.inFunction = true;\r\n\r\n    node.params = this.toAssignableList(params, true);\r\n    this.parseFunctionBody(node, true);\r\n\r\n    this.inGenerator = oldInGen;\r\n    this.inAsync = oldInAsync;\r\n    this.yieldPos = oldYieldPos;\r\n    this.awaitPos = oldAwaitPos;\r\n    this.inFunction = oldInFunc;\r\n    return this.finishNode(node, \"ArrowFunctionExpression\")\r\n  };\r\n\r\n  // Parse function body and check parameters.\r\n\r\n  pp$3.parseFunctionBody = function(node, isArrowFunction) {\r\n    var isExpression = isArrowFunction && this.type !== types.braceL;\r\n    var oldStrict = this.strict, useStrict = false;\r\n\r\n    if (isExpression) {\r\n      node.body = this.parseMaybeAssign();\r\n      node.expression = true;\r\n      this.checkParams(node, false);\r\n    } else {\r\n      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\r\n      if (!oldStrict || nonSimple) {\r\n        useStrict = this.strictDirective(this.end);\r\n        // If this is a strict mode function, verify that argument names\r\n        // are not repeated, and it does not try to bind the words `eval`\r\n        // or `arguments`.\r\n        if (useStrict && nonSimple)\r\n          { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\r\n      }\r\n      // Start a new scope with regard to labels and the `inFunction`\r\n      // flag (restore them to their old value afterwards).\r\n      var oldLabels = this.labels;\r\n      this.labels = [];\r\n      if (useStrict) { this.strict = true; }\r\n\r\n      // Add the params to varDeclaredNames to ensure that an error is thrown\r\n      // if a let/const declaration in the function clashes with one of the params.\r\n      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));\r\n      node.body = this.parseBlock(false);\r\n      node.expression = false;\r\n      this.adaptDirectivePrologue(node.body.body);\r\n      this.labels = oldLabels;\r\n    }\r\n    this.exitFunctionScope();\r\n\r\n    if (this.strict && node.id) {\r\n      // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\r\n      this.checkLVal(node.id, \"none\");\r\n    }\r\n    this.strict = oldStrict;\r\n  };\r\n\r\n  pp$3.isSimpleParamList = function(params) {\r\n    for (var i = 0, list = params; i < list.length; i += 1)\r\n      {\r\n      var param = list[i];\r\n\r\n      if (param.type !== \"Identifier\") { return false\r\n    } }\r\n    return true\r\n  };\r\n\r\n  // Checks function params for various disallowed patterns such as using \"eval\"\r\n  // or \"arguments\" and duplicate parameters.\r\n\r\n  pp$3.checkParams = function(node, allowDuplicates) {\r\n    var this$1 = this;\r\n\r\n    var nameHash = {};\r\n    for (var i = 0, list = node.params; i < list.length; i += 1)\r\n      {\r\n      var param = list[i];\r\n\r\n      this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\r\n    }\r\n  };\r\n\r\n  // Parses a comma-separated list of expressions, and returns them as\r\n  // an array. `close` is the token type that ends the list, and\r\n  // `allowEmpty` can be turned on to allow subsequent commas with\r\n  // nothing in between them to be parsed as `null` (which is needed\r\n  // for array literals).\r\n\r\n  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\r\n    var this$1 = this;\r\n\r\n    var elts = [], first = true;\r\n    while (!this.eat(close)) {\r\n      if (!first) {\r\n        this$1.expect(types.comma);\r\n        if (allowTrailingComma && this$1.afterTrailingComma(close)) { break }\r\n      } else { first = false; }\r\n\r\n      var elt = (void 0);\r\n      if (allowEmpty && this$1.type === types.comma)\r\n        { elt = null; }\r\n      else if (this$1.type === types.ellipsis) {\r\n        elt = this$1.parseSpread(refDestructuringErrors);\r\n        if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0)\r\n          { refDestructuringErrors.trailingComma = this$1.start; }\r\n      } else {\r\n        elt = this$1.parseMaybeAssign(false, refDestructuringErrors);\r\n      }\r\n      elts.push(elt);\r\n    }\r\n    return elts\r\n  };\r\n\r\n  pp$3.checkUnreserved = function(ref) {\r\n    var start = ref.start;\r\n    var end = ref.end;\r\n    var name = ref.name;\r\n\r\n    if (this.inGenerator && name === \"yield\")\r\n      { this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\"); }\r\n    if (this.inAsync && name === \"await\")\r\n      { this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\"); }\r\n    if (this.isKeyword(name))\r\n      { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\r\n    if (this.options.ecmaVersion < 6 &&\r\n      this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\r\n    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\r\n    if (re.test(name)) {\r\n      if (!this.inAsync && name === \"await\")\r\n        { this.raiseRecoverable(start, \"Can not use keyword 'await' outside an async function\"); }\r\n      this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\r\n    }\r\n  };\r\n\r\n  // Parse the next token as an identifier. If `liberal` is true (used\r\n  // when parsing properties), it will also convert keywords into\r\n  // identifiers.\r\n\r\n  pp$3.parseIdent = function(liberal, isBinding) {\r\n    var node = this.startNode();\r\n    if (liberal && this.options.allowReserved === \"never\") { liberal = false; }\r\n    if (this.type === types.name) {\r\n      node.name = this.value;\r\n    } else if (this.type.keyword) {\r\n      node.name = this.type.keyword;\r\n\r\n      // To fix https://github.com/acornjs/acorn/issues/575\r\n      // `class` and `function` keywords push new context into this.context.\r\n      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\r\n      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\r\n      if ((node.name === \"class\" || node.name === \"function\") &&\r\n          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\r\n        this.context.pop();\r\n      }\r\n    } else {\r\n      this.unexpected();\r\n    }\r\n    this.next();\r\n    this.finishNode(node, \"Identifier\");\r\n    if (!liberal) { this.checkUnreserved(node); }\r\n    return node\r\n  };\r\n\r\n  // Parses yield expression inside generator.\r\n\r\n  pp$3.parseYield = function() {\r\n    if (!this.yieldPos) { this.yieldPos = this.start; }\r\n\r\n    var node = this.startNode();\r\n    this.next();\r\n    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\r\n      node.delegate = false;\r\n      node.argument = null;\r\n    } else {\r\n      node.delegate = this.eat(types.star);\r\n      node.argument = this.parseMaybeAssign();\r\n    }\r\n    return this.finishNode(node, \"YieldExpression\")\r\n  };\r\n\r\n  pp$3.parseAwait = function() {\r\n    if (!this.awaitPos) { this.awaitPos = this.start; }\r\n\r\n    var node = this.startNode();\r\n    this.next();\r\n    node.argument = this.parseMaybeUnary(null, true);\r\n    return this.finishNode(node, \"AwaitExpression\")\r\n  };\r\n\r\n  var pp$4 = Parser.prototype;\r\n\r\n  // This function is used to raise exceptions on parse errors. It\r\n  // takes an offset integer (into the current `input`) to indicate\r\n  // the location of the error, attaches the position to the end\r\n  // of the error message, and then raises a `SyntaxError` with that\r\n  // message.\r\n\r\n  pp$4.raise = function(pos, message) {\r\n    var loc = getLineInfo(this.input, pos);\r\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\r\n    var err = new SyntaxError(message);\r\n    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\r\n    throw err\r\n  };\r\n\r\n  pp$4.raiseRecoverable = pp$4.raise;\r\n\r\n  pp$4.curPosition = function() {\r\n    if (this.options.locations) {\r\n      return new Position(this.curLine, this.pos - this.lineStart)\r\n    }\r\n  };\r\n\r\n  var pp$5 = Parser.prototype;\r\n\r\n  // Object.assign polyfill\r\n  var assign = Object.assign || function(target) {\r\n    var sources = [], len = arguments.length - 1;\r\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\r\n\r\n    for (var i = 0, list = sources; i < list.length; i += 1) {\r\n      var source = list[i];\r\n\r\n      for (var key in source) {\r\n        if (has(source, key)) {\r\n          target[key] = source[key];\r\n        }\r\n      }\r\n    }\r\n    return target\r\n  };\r\n\r\n  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\r\n\r\n  pp$5.enterFunctionScope = function() {\r\n    // var: a hash of var-declared names in the current lexical scope\r\n    // lexical: a hash of lexically-declared names in the current lexical scope\r\n    // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\r\n    // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\r\n    this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});\r\n  };\r\n\r\n  pp$5.exitFunctionScope = function() {\r\n    this.scopeStack.pop();\r\n  };\r\n\r\n  pp$5.enterLexicalScope = function() {\r\n    var parentScope = this.scopeStack[this.scopeStack.length - 1];\r\n    var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};\r\n\r\n    this.scopeStack.push(childScope);\r\n    assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\r\n  };\r\n\r\n  pp$5.exitLexicalScope = function() {\r\n    var childScope = this.scopeStack.pop();\r\n    var parentScope = this.scopeStack[this.scopeStack.length - 1];\r\n\r\n    assign(parentScope.childVar, childScope.var, childScope.childVar);\r\n  };\r\n\r\n  /**\r\n   * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\r\n   * in the current lexical scope or any of the parent lexical scopes in this function.\r\n   */\r\n  pp$5.canDeclareVarName = function(name) {\r\n    var currentScope = this.scopeStack[this.scopeStack.length - 1];\r\n\r\n    return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\r\n  };\r\n\r\n  /**\r\n   * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\r\n   * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\r\n   * any child lexical scopes in this function.\r\n   */\r\n  pp$5.canDeclareLexicalName = function(name) {\r\n    var currentScope = this.scopeStack[this.scopeStack.length - 1];\r\n\r\n    return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\r\n  };\r\n\r\n  pp$5.declareVarName = function(name) {\r\n    this.scopeStack[this.scopeStack.length - 1].var[name] = true;\r\n  };\r\n\r\n  pp$5.declareLexicalName = function(name) {\r\n    this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\r\n  };\r\n\r\n  var Node = function Node(parser, pos, loc) {\r\n    this.type = \"\";\r\n    this.start = pos;\r\n    this.end = 0;\r\n    if (parser.options.locations)\r\n      { this.loc = new SourceLocation(parser, loc); }\r\n    if (parser.options.directSourceFile)\r\n      { this.sourceFile = parser.options.directSourceFile; }\r\n    if (parser.options.ranges)\r\n      { this.range = [pos, 0]; }\r\n  };\r\n\r\n  // Start an AST node, attaching a start offset.\r\n\r\n  var pp$6 = Parser.prototype;\r\n\r\n  pp$6.startNode = function() {\r\n    return new Node(this, this.start, this.startLoc)\r\n  };\r\n\r\n  pp$6.startNodeAt = function(pos, loc) {\r\n    return new Node(this, pos, loc)\r\n  };\r\n\r\n  // Finish an AST node, adding `type` and `end` properties.\r\n\r\n  function finishNodeAt(node, type, pos, loc) {\r\n    node.type = type;\r\n    node.end = pos;\r\n    if (this.options.locations)\r\n      { node.loc.end = loc; }\r\n    if (this.options.ranges)\r\n      { node.range[1] = pos; }\r\n    return node\r\n  }\r\n\r\n  pp$6.finishNode = function(node, type) {\r\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\r\n  };\r\n\r\n  // Finish node at given position\r\n\r\n  pp$6.finishNodeAt = function(node, type, pos, loc) {\r\n    return finishNodeAt.call(this, node, type, pos, loc)\r\n  };\r\n\r\n  // The algorithm used to determine whether a regexp can appear at a\r\n  // given point in the program is loosely based on sweet.js' approach.\r\n  // See https://github.com/mozilla/sweet.js/wiki/design\r\n\r\n  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\r\n    this.token = token;\r\n    this.isExpr = !!isExpr;\r\n    this.preserveSpace = !!preserveSpace;\r\n    this.override = override;\r\n    this.generator = !!generator;\r\n  };\r\n\r\n  var types$1 = {\r\n    b_stat: new TokContext(\"{\", false),\r\n    b_expr: new TokContext(\"{\", true),\r\n    b_tmpl: new TokContext(\"${\", false),\r\n    p_stat: new TokContext(\"(\", false),\r\n    p_expr: new TokContext(\"(\", true),\r\n    q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\r\n    f_stat: new TokContext(\"function\", false),\r\n    f_expr: new TokContext(\"function\", true),\r\n    f_expr_gen: new TokContext(\"function\", true, false, null, true),\r\n    f_gen: new TokContext(\"function\", false, false, null, true)\r\n  };\r\n\r\n  var pp$7 = Parser.prototype;\r\n\r\n  pp$7.initialContext = function() {\r\n    return [types$1.b_stat]\r\n  };\r\n\r\n  pp$7.braceIsBlock = function(prevType) {\r\n    var parent = this.curContext();\r\n    if (parent === types$1.f_expr || parent === types$1.f_stat)\r\n      { return true }\r\n    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\r\n      { return !parent.isExpr }\r\n\r\n    // The check for `tt.name && exprAllowed` detects whether we are\r\n    // after a `yield` or `of` construct. See the `updateContext` for\r\n    // `tt.name`.\r\n    if (prevType === types._return || prevType === types.name && this.exprAllowed)\r\n      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\r\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\r\n      { return true }\r\n    if (prevType === types.braceL)\r\n      { return parent === types$1.b_stat }\r\n    if (prevType === types._var || prevType === types.name)\r\n      { return false }\r\n    return !this.exprAllowed\r\n  };\r\n\r\n  pp$7.inGeneratorContext = function() {\r\n    var this$1 = this;\r\n\r\n    for (var i = this.context.length - 1; i >= 1; i--) {\r\n      var context = this$1.context[i];\r\n      if (context.token === \"function\")\r\n        { return context.generator }\r\n    }\r\n    return false\r\n  };\r\n\r\n  pp$7.updateContext = function(prevType) {\r\n    var update, type = this.type;\r\n    if (type.keyword && prevType === types.dot)\r\n      { this.exprAllowed = false; }\r\n    else if (update = type.updateContext)\r\n      { update.call(this, prevType); }\r\n    else\r\n      { this.exprAllowed = type.beforeExpr; }\r\n  };\r\n\r\n  // Token-specific context update code\r\n\r\n  types.parenR.updateContext = types.braceR.updateContext = function() {\r\n    if (this.context.length === 1) {\r\n      this.exprAllowed = true;\r\n      return\r\n    }\r\n    var out = this.context.pop();\r\n    if (out === types$1.b_stat && this.curContext().token === \"function\") {\r\n      out = this.context.pop();\r\n    }\r\n    this.exprAllowed = !out.isExpr;\r\n  };\r\n\r\n  types.braceL.updateContext = function(prevType) {\r\n    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\r\n    this.exprAllowed = true;\r\n  };\r\n\r\n  types.dollarBraceL.updateContext = function() {\r\n    this.context.push(types$1.b_tmpl);\r\n    this.exprAllowed = true;\r\n  };\r\n\r\n  types.parenL.updateContext = function(prevType) {\r\n    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\r\n    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\r\n    this.exprAllowed = true;\r\n  };\r\n\r\n  types.incDec.updateContext = function() {\r\n    // tokExprAllowed stays unchanged\r\n  };\r\n\r\n  types._function.updateContext = types._class.updateContext = function(prevType) {\r\n    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\r\n        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\r\n      { this.context.push(types$1.f_expr); }\r\n    else\r\n      { this.context.push(types$1.f_stat); }\r\n    this.exprAllowed = false;\r\n  };\r\n\r\n  types.backQuote.updateContext = function() {\r\n    if (this.curContext() === types$1.q_tmpl)\r\n      { this.context.pop(); }\r\n    else\r\n      { this.context.push(types$1.q_tmpl); }\r\n    this.exprAllowed = false;\r\n  };\r\n\r\n  types.star.updateContext = function(prevType) {\r\n    if (prevType === types._function) {\r\n      var index = this.context.length - 1;\r\n      if (this.context[index] === types$1.f_expr)\r\n        { this.context[index] = types$1.f_expr_gen; }\r\n      else\r\n        { this.context[index] = types$1.f_gen; }\r\n    }\r\n    this.exprAllowed = true;\r\n  };\r\n\r\n  types.name.updateContext = function(prevType) {\r\n    var allowed = false;\r\n    if (this.options.ecmaVersion >= 6) {\r\n      if (this.value === \"of\" && !this.exprAllowed ||\r\n          this.value === \"yield\" && this.inGeneratorContext())\r\n        { allowed = true; }\r\n    }\r\n    this.exprAllowed = allowed;\r\n  };\r\n\r\n  var data = {\r\n    \"$LONE\": [\r\n      \"ASCII\",\r\n      \"ASCII_Hex_Digit\",\r\n      \"AHex\",\r\n      \"Alphabetic\",\r\n      \"Alpha\",\r\n      \"Any\",\r\n      \"Assigned\",\r\n      \"Bidi_Control\",\r\n      \"Bidi_C\",\r\n      \"Bidi_Mirrored\",\r\n      \"Bidi_M\",\r\n      \"Case_Ignorable\",\r\n      \"CI\",\r\n      \"Cased\",\r\n      \"Changes_When_Casefolded\",\r\n      \"CWCF\",\r\n      \"Changes_When_Casemapped\",\r\n      \"CWCM\",\r\n      \"Changes_When_Lowercased\",\r\n      \"CWL\",\r\n      \"Changes_When_NFKC_Casefolded\",\r\n      \"CWKCF\",\r\n      \"Changes_When_Titlecased\",\r\n      \"CWT\",\r\n      \"Changes_When_Uppercased\",\r\n      \"CWU\",\r\n      \"Dash\",\r\n      \"Default_Ignorable_Code_Point\",\r\n      \"DI\",\r\n      \"Deprecated\",\r\n      \"Dep\",\r\n      \"Diacritic\",\r\n      \"Dia\",\r\n      \"Emoji\",\r\n      \"Emoji_Component\",\r\n      \"Emoji_Modifier\",\r\n      \"Emoji_Modifier_Base\",\r\n      \"Emoji_Presentation\",\r\n      \"Extender\",\r\n      \"Ext\",\r\n      \"Grapheme_Base\",\r\n      \"Gr_Base\",\r\n      \"Grapheme_Extend\",\r\n      \"Gr_Ext\",\r\n      \"Hex_Digit\",\r\n      \"Hex\",\r\n      \"IDS_Binary_Operator\",\r\n      \"IDSB\",\r\n      \"IDS_Trinary_Operator\",\r\n      \"IDST\",\r\n      \"ID_Continue\",\r\n      \"IDC\",\r\n      \"ID_Start\",\r\n      \"IDS\",\r\n      \"Ideographic\",\r\n      \"Ideo\",\r\n      \"Join_Control\",\r\n      \"Join_C\",\r\n      \"Logical_Order_Exception\",\r\n      \"LOE\",\r\n      \"Lowercase\",\r\n      \"Lower\",\r\n      \"Math\",\r\n      \"Noncharacter_Code_Point\",\r\n      \"NChar\",\r\n      \"Pattern_Syntax\",\r\n      \"Pat_Syn\",\r\n      \"Pattern_White_Space\",\r\n      \"Pat_WS\",\r\n      \"Quotation_Mark\",\r\n      \"QMark\",\r\n      \"Radical\",\r\n      \"Regional_Indicator\",\r\n      \"RI\",\r\n      \"Sentence_Terminal\",\r\n      \"STerm\",\r\n      \"Soft_Dotted\",\r\n      \"SD\",\r\n      \"Terminal_Punctuation\",\r\n      \"Term\",\r\n      \"Unified_Ideograph\",\r\n      \"UIdeo\",\r\n      \"Uppercase\",\r\n      \"Upper\",\r\n      \"Variation_Selector\",\r\n      \"VS\",\r\n      \"White_Space\",\r\n      \"space\",\r\n      \"XID_Continue\",\r\n      \"XIDC\",\r\n      \"XID_Start\",\r\n      \"XIDS\"\r\n    ],\r\n    \"General_Category\": [\r\n      \"Cased_Letter\",\r\n      \"LC\",\r\n      \"Close_Punctuation\",\r\n      \"Pe\",\r\n      \"Connector_Punctuation\",\r\n      \"Pc\",\r\n      \"Control\",\r\n      \"Cc\",\r\n      \"cntrl\",\r\n      \"Currency_Symbol\",\r\n      \"Sc\",\r\n      \"Dash_Punctuation\",\r\n      \"Pd\",\r\n      \"Decimal_Number\",\r\n      \"Nd\",\r\n      \"digit\",\r\n      \"Enclosing_Mark\",\r\n      \"Me\",\r\n      \"Final_Punctuation\",\r\n      \"Pf\",\r\n      \"Format\",\r\n      \"Cf\",\r\n      \"Initial_Punctuation\",\r\n      \"Pi\",\r\n      \"Letter\",\r\n      \"L\",\r\n      \"Letter_Number\",\r\n      \"Nl\",\r\n      \"Line_Separator\",\r\n      \"Zl\",\r\n      \"Lowercase_Letter\",\r\n      \"Ll\",\r\n      \"Mark\",\r\n      \"M\",\r\n      \"Combining_Mark\",\r\n      \"Math_Symbol\",\r\n      \"Sm\",\r\n      \"Modifier_Letter\",\r\n      \"Lm\",\r\n      \"Modifier_Symbol\",\r\n      \"Sk\",\r\n      \"Nonspacing_Mark\",\r\n      \"Mn\",\r\n      \"Number\",\r\n      \"N\",\r\n      \"Open_Punctuation\",\r\n      \"Ps\",\r\n      \"Other\",\r\n      \"C\",\r\n      \"Other_Letter\",\r\n      \"Lo\",\r\n      \"Other_Number\",\r\n      \"No\",\r\n      \"Other_Punctuation\",\r\n      \"Po\",\r\n      \"Other_Symbol\",\r\n      \"So\",\r\n      \"Paragraph_Separator\",\r\n      \"Zp\",\r\n      \"Private_Use\",\r\n      \"Co\",\r\n      \"Punctuation\",\r\n      \"P\",\r\n      \"punct\",\r\n      \"Separator\",\r\n      \"Z\",\r\n      \"Space_Separator\",\r\n      \"Zs\",\r\n      \"Spacing_Mark\",\r\n      \"Mc\",\r\n      \"Surrogate\",\r\n      \"Cs\",\r\n      \"Symbol\",\r\n      \"S\",\r\n      \"Titlecase_Letter\",\r\n      \"Lt\",\r\n      \"Unassigned\",\r\n      \"Cn\",\r\n      \"Uppercase_Letter\",\r\n      \"Lu\"\r\n    ],\r\n    \"Script\": [\r\n      \"Adlam\",\r\n      \"Adlm\",\r\n      \"Ahom\",\r\n      \"Anatolian_Hieroglyphs\",\r\n      \"Hluw\",\r\n      \"Arabic\",\r\n      \"Arab\",\r\n      \"Armenian\",\r\n      \"Armn\",\r\n      \"Avestan\",\r\n      \"Avst\",\r\n      \"Balinese\",\r\n      \"Bali\",\r\n      \"Bamum\",\r\n      \"Bamu\",\r\n      \"Bassa_Vah\",\r\n      \"Bass\",\r\n      \"Batak\",\r\n      \"Batk\",\r\n      \"Bengali\",\r\n      \"Beng\",\r\n      \"Bhaiksuki\",\r\n      \"Bhks\",\r\n      \"Bopomofo\",\r\n      \"Bopo\",\r\n      \"Brahmi\",\r\n      \"Brah\",\r\n      \"Braille\",\r\n      \"Brai\",\r\n      \"Buginese\",\r\n      \"Bugi\",\r\n      \"Buhid\",\r\n      \"Buhd\",\r\n      \"Canadian_Aboriginal\",\r\n      \"Cans\",\r\n      \"Carian\",\r\n      \"Cari\",\r\n      \"Caucasian_Albanian\",\r\n      \"Aghb\",\r\n      \"Chakma\",\r\n      \"Cakm\",\r\n      \"Cham\",\r\n      \"Cherokee\",\r\n      \"Cher\",\r\n      \"Common\",\r\n      \"Zyyy\",\r\n      \"Coptic\",\r\n      \"Copt\",\r\n      \"Qaac\",\r\n      \"Cuneiform\",\r\n      \"Xsux\",\r\n      \"Cypriot\",\r\n      \"Cprt\",\r\n      \"Cyrillic\",\r\n      \"Cyrl\",\r\n      \"Deseret\",\r\n      \"Dsrt\",\r\n      \"Devanagari\",\r\n      \"Deva\",\r\n      \"Duployan\",\r\n      \"Dupl\",\r\n      \"Egyptian_Hieroglyphs\",\r\n      \"Egyp\",\r\n      \"Elbasan\",\r\n      \"Elba\",\r\n      \"Ethiopic\",\r\n      \"Ethi\",\r\n      \"Georgian\",\r\n      \"Geor\",\r\n      \"Glagolitic\",\r\n      \"Glag\",\r\n      \"Gothic\",\r\n      \"Goth\",\r\n      \"Grantha\",\r\n      \"Gran\",\r\n      \"Greek\",\r\n      \"Grek\",\r\n      \"Gujarati\",\r\n      \"Gujr\",\r\n      \"Gurmukhi\",\r\n      \"Guru\",\r\n      \"Han\",\r\n      \"Hani\",\r\n      \"Hangul\",\r\n      \"Hang\",\r\n      \"Hanunoo\",\r\n      \"Hano\",\r\n      \"Hatran\",\r\n      \"Hatr\",\r\n      \"Hebrew\",\r\n      \"Hebr\",\r\n      \"Hiragana\",\r\n      \"Hira\",\r\n      \"Imperial_Aramaic\",\r\n      \"Armi\",\r\n      \"Inherited\",\r\n      \"Zinh\",\r\n      \"Qaai\",\r\n      \"Inscriptional_Pahlavi\",\r\n      \"Phli\",\r\n      \"Inscriptional_Parthian\",\r\n      \"Prti\",\r\n      \"Javanese\",\r\n      \"Java\",\r\n      \"Kaithi\",\r\n      \"Kthi\",\r\n      \"Kannada\",\r\n      \"Knda\",\r\n      \"Katakana\",\r\n      \"Kana\",\r\n      \"Kayah_Li\",\r\n      \"Kali\",\r\n      \"Kharoshthi\",\r\n      \"Khar\",\r\n      \"Khmer\",\r\n      \"Khmr\",\r\n      \"Khojki\",\r\n      \"Khoj\",\r\n      \"Khudawadi\",\r\n      \"Sind\",\r\n      \"Lao\",\r\n      \"Laoo\",\r\n      \"Latin\",\r\n      \"Latn\",\r\n      \"Lepcha\",\r\n      \"Lepc\",\r\n      \"Limbu\",\r\n      \"Limb\",\r\n      \"Linear_A\",\r\n      \"Lina\",\r\n      \"Linear_B\",\r\n      \"Linb\",\r\n      \"Lisu\",\r\n      \"Lycian\",\r\n      \"Lyci\",\r\n      \"Lydian\",\r\n      \"Lydi\",\r\n      \"Mahajani\",\r\n      \"Mahj\",\r\n      \"Malayalam\",\r\n      \"Mlym\",\r\n      \"Mandaic\",\r\n      \"Mand\",\r\n      \"Manichaean\",\r\n      \"Mani\",\r\n      \"Marchen\",\r\n      \"Marc\",\r\n      \"Masaram_Gondi\",\r\n      \"Gonm\",\r\n      \"Meetei_Mayek\",\r\n      \"Mtei\",\r\n      \"Mende_Kikakui\",\r\n      \"Mend\",\r\n      \"Meroitic_Cursive\",\r\n      \"Merc\",\r\n      \"Meroitic_Hieroglyphs\",\r\n      \"Mero\",\r\n      \"Miao\",\r\n      \"Plrd\",\r\n      \"Modi\",\r\n      \"Mongolian\",\r\n      \"Mong\",\r\n      \"Mro\",\r\n      \"Mroo\",\r\n      \"Multani\",\r\n      \"Mult\",\r\n      \"Myanmar\",\r\n      \"Mymr\",\r\n      \"Nabataean\",\r\n      \"Nbat\",\r\n      \"New_Tai_Lue\",\r\n      \"Talu\",\r\n      \"Newa\",\r\n      \"Nko\",\r\n      \"Nkoo\",\r\n      \"Nushu\",\r\n      \"Nshu\",\r\n      \"Ogham\",\r\n      \"Ogam\",\r\n      \"Ol_Chiki\",\r\n      \"Olck\",\r\n      \"Old_Hungarian\",\r\n      \"Hung\",\r\n      \"Old_Italic\",\r\n      \"Ital\",\r\n      \"Old_North_Arabian\",\r\n      \"Narb\",\r\n      \"Old_Permic\",\r\n      \"Perm\",\r\n      \"Old_Persian\",\r\n      \"Xpeo\",\r\n      \"Old_South_Arabian\",\r\n      \"Sarb\",\r\n      \"Old_Turkic\",\r\n      \"Orkh\",\r\n      \"Oriya\",\r\n      \"Orya\",\r\n      \"Osage\",\r\n      \"Osge\",\r\n      \"Osmanya\",\r\n      \"Osma\",\r\n      \"Pahawh_Hmong\",\r\n      \"Hmng\",\r\n      \"Palmyrene\",\r\n      \"Palm\",\r\n      \"Pau_Cin_Hau\",\r\n      \"Pauc\",\r\n      \"Phags_Pa\",\r\n      \"Phag\",\r\n      \"Phoenician\",\r\n      \"Phnx\",\r\n      \"Psalter_Pahlavi\",\r\n      \"Phlp\",\r\n      \"Rejang\",\r\n      \"Rjng\",\r\n      \"Runic\",\r\n      \"Runr\",\r\n      \"Samaritan\",\r\n      \"Samr\",\r\n      \"Saurashtra\",\r\n      \"Saur\",\r\n      \"Sharada\",\r\n      \"Shrd\",\r\n      \"Shavian\",\r\n      \"Shaw\",\r\n      \"Siddham\",\r\n      \"Sidd\",\r\n      \"SignWriting\",\r\n      \"Sgnw\",\r\n      \"Sinhala\",\r\n      \"Sinh\",\r\n      \"Sora_Sompeng\",\r\n      \"Sora\",\r\n      \"Soyombo\",\r\n      \"Soyo\",\r\n      \"Sundanese\",\r\n      \"Sund\",\r\n      \"Syloti_Nagri\",\r\n      \"Sylo\",\r\n      \"Syriac\",\r\n      \"Syrc\",\r\n      \"Tagalog\",\r\n      \"Tglg\",\r\n      \"Tagbanwa\",\r\n      \"Tagb\",\r\n      \"Tai_Le\",\r\n      \"Tale\",\r\n      \"Tai_Tham\",\r\n      \"Lana\",\r\n      \"Tai_Viet\",\r\n      \"Tavt\",\r\n      \"Takri\",\r\n      \"Takr\",\r\n      \"Tamil\",\r\n      \"Taml\",\r\n      \"Tangut\",\r\n      \"Tang\",\r\n      \"Telugu\",\r\n      \"Telu\",\r\n      \"Thaana\",\r\n      \"Thaa\",\r\n      \"Thai\",\r\n      \"Tibetan\",\r\n      \"Tibt\",\r\n      \"Tifinagh\",\r\n      \"Tfng\",\r\n      \"Tirhuta\",\r\n      \"Tirh\",\r\n      \"Ugaritic\",\r\n      \"Ugar\",\r\n      \"Vai\",\r\n      \"Vaii\",\r\n      \"Warang_Citi\",\r\n      \"Wara\",\r\n      \"Yi\",\r\n      \"Yiii\",\r\n      \"Zanabazar_Square\",\r\n      \"Zanb\"\r\n    ]\r\n  };\r\n  Array.prototype.push.apply(data.$LONE, data.General_Category);\r\n  data.gc = data.General_Category;\r\n  data.sc = data.Script_Extensions = data.scx = data.Script;\r\n\r\n  var pp$9 = Parser.prototype;\r\n\r\n  var RegExpValidationState = function RegExpValidationState(parser) {\r\n    this.parser = parser;\r\n    this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\r\n    this.source = \"\";\r\n    this.flags = \"\";\r\n    this.start = 0;\r\n    this.switchU = false;\r\n    this.switchN = false;\r\n    this.pos = 0;\r\n    this.lastIntValue = 0;\r\n    this.lastStringValue = \"\";\r\n    this.lastAssertionIsQuantifiable = false;\r\n    this.numCapturingParens = 0;\r\n    this.maxBackReference = 0;\r\n    this.groupNames = [];\r\n    this.backReferenceNames = [];\r\n  };\r\n\r\n  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\r\n    var unicode = flags.indexOf(\"u\") !== -1;\r\n    this.start = start | 0;\r\n    this.source = pattern + \"\";\r\n    this.flags = flags;\r\n    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\r\n    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\r\n  };\r\n\r\n  RegExpValidationState.prototype.raise = function raise (message) {\r\n    this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\r\n  };\r\n\r\n  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).\r\n  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\r\n  RegExpValidationState.prototype.at = function at (i) {\r\n    var s = this.source;\r\n    var l = s.length;\r\n    if (i >= l) {\r\n      return -1\r\n    }\r\n    var c = s.charCodeAt(i);\r\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\r\n      return c\r\n    }\r\n    return (c << 10) + s.charCodeAt(i + 1) - 0x35FDC00\r\n  };\r\n\r\n  RegExpValidationState.prototype.nextIndex = function nextIndex (i) {\r\n    var s = this.source;\r\n    var l = s.length;\r\n    if (i >= l) {\r\n      return l\r\n    }\r\n    var c = s.charCodeAt(i);\r\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\r\n      return i + 1\r\n    }\r\n    return i + 2\r\n  };\r\n\r\n  RegExpValidationState.prototype.current = function current () {\r\n    return this.at(this.pos)\r\n  };\r\n\r\n  RegExpValidationState.prototype.lookahead = function lookahead () {\r\n    return this.at(this.nextIndex(this.pos))\r\n  };\r\n\r\n  RegExpValidationState.prototype.advance = function advance () {\r\n    this.pos = this.nextIndex(this.pos);\r\n  };\r\n\r\n  RegExpValidationState.prototype.eat = function eat (ch) {\r\n    if (this.current() === ch) {\r\n      this.advance();\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  function codePointToString$1(ch) {\r\n    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\r\n    ch -= 0x10000;\r\n    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\r\n  }\r\n\r\n  /**\r\n   * Validate the flags part of a given RegExpLiteral.\r\n   *\r\n   * @param {RegExpValidationState} state The state to validate RegExp.\r\n   * @returns {void}\r\n   */\r\n  pp$9.validateRegExpFlags = function(state) {\r\n    var this$1 = this;\r\n\r\n    var validFlags = state.validFlags;\r\n    var flags = state.flags;\r\n\r\n    for (var i = 0; i < flags.length; i++) {\r\n      var flag = flags.charAt(i);\r\n      if (validFlags.indexOf(flag) === -1) {\r\n        this$1.raise(state.start, \"Invalid regular expression flag\");\r\n      }\r\n      if (flags.indexOf(flag, i + 1) > -1) {\r\n        this$1.raise(state.start, \"Duplicate regular expression flag\");\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validate the pattern part of a given RegExpLiteral.\r\n   *\r\n   * @param {RegExpValidationState} state The state to validate RegExp.\r\n   * @returns {void}\r\n   */\r\n  pp$9.validateRegExpPattern = function(state) {\r\n    this.regexp_pattern(state);\r\n\r\n    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\r\n    // parsing contains a |GroupName|, reparse with the goal symbol\r\n    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\r\n    // exception if _P_ did not conform to the grammar, if any elements of _P_\r\n    // were not matched by the parse, or if any Early Error conditions exist.\r\n    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\r\n      state.switchN = true;\r\n      this.regexp_pattern(state);\r\n    }\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\r\n  pp$9.regexp_pattern = function(state) {\r\n    state.pos = 0;\r\n    state.lastIntValue = 0;\r\n    state.lastStringValue = \"\";\r\n    state.lastAssertionIsQuantifiable = false;\r\n    state.numCapturingParens = 0;\r\n    state.maxBackReference = 0;\r\n    state.groupNames.length = 0;\r\n    state.backReferenceNames.length = 0;\r\n\r\n    this.regexp_disjunction(state);\r\n\r\n    if (state.pos !== state.source.length) {\r\n      // Make the same messages as V8.\r\n      if (state.eat(0x29 /* ) */)) {\r\n        state.raise(\"Unmatched ')'\");\r\n      }\r\n      if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {\r\n        state.raise(\"Lone quantifier brackets\");\r\n      }\r\n    }\r\n    if (state.maxBackReference > state.numCapturingParens) {\r\n      state.raise(\"Invalid escape\");\r\n    }\r\n    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\r\n      var name = list[i];\r\n\r\n      if (state.groupNames.indexOf(name) === -1) {\r\n        state.raise(\"Invalid named capture referenced\");\r\n      }\r\n    }\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\r\n  pp$9.regexp_disjunction = function(state) {\r\n    var this$1 = this;\r\n\r\n    this.regexp_alternative(state);\r\n    while (state.eat(0x7C /* | */)) {\r\n      this$1.regexp_alternative(state);\r\n    }\r\n\r\n    // Make the same message as V8.\r\n    if (this.regexp_eatQuantifier(state, true)) {\r\n      state.raise(\"Nothing to repeat\");\r\n    }\r\n    if (state.eat(0x7B /* { */)) {\r\n      state.raise(\"Lone quantifier brackets\");\r\n    }\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\r\n  pp$9.regexp_alternative = function(state) {\r\n    while (state.pos < state.source.length && this.regexp_eatTerm(state))\r\n      {  }\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\r\n  pp$9.regexp_eatTerm = function(state) {\r\n    if (this.regexp_eatAssertion(state)) {\r\n      // Handle `QuantifiableAssertion Quantifier` alternative.\r\n      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\r\n      // is a QuantifiableAssertion.\r\n      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\r\n        // Make the same message as V8.\r\n        if (state.switchU) {\r\n          state.raise(\"Invalid quantifier\");\r\n        }\r\n      }\r\n      return true\r\n    }\r\n\r\n    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\r\n      this.regexp_eatQuantifier(state);\r\n      return true\r\n    }\r\n\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\r\n  pp$9.regexp_eatAssertion = function(state) {\r\n    var start = state.pos;\r\n    state.lastAssertionIsQuantifiable = false;\r\n\r\n    // ^, $\r\n    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\r\n      return true\r\n    }\r\n\r\n    // \\b \\B\r\n    if (state.eat(0x5C /* \\ */)) {\r\n      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\r\n        return true\r\n      }\r\n      state.pos = start;\r\n    }\r\n\r\n    // Lookahead / Lookbehind\r\n    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\r\n      var lookbehind = false;\r\n      if (this.options.ecmaVersion >= 9) {\r\n        lookbehind = state.eat(0x3C /* < */);\r\n      }\r\n      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\r\n        this.regexp_disjunction(state);\r\n        if (!state.eat(0x29 /* ) */)) {\r\n          state.raise(\"Unterminated group\");\r\n        }\r\n        state.lastAssertionIsQuantifiable = !lookbehind;\r\n        return true\r\n      }\r\n    }\r\n\r\n    state.pos = start;\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\r\n  pp$9.regexp_eatQuantifier = function(state, noError) {\r\n    if ( noError === void 0 ) noError = false;\r\n\r\n    if (this.regexp_eatQuantifierPrefix(state, noError)) {\r\n      state.eat(0x3F /* ? */);\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\r\n  pp$9.regexp_eatQuantifierPrefix = function(state, noError) {\r\n    return (\r\n      state.eat(0x2A /* * */) ||\r\n      state.eat(0x2B /* + */) ||\r\n      state.eat(0x3F /* ? */) ||\r\n      this.regexp_eatBracedQuantifier(state, noError)\r\n    )\r\n  };\r\n  pp$9.regexp_eatBracedQuantifier = function(state, noError) {\r\n    var start = state.pos;\r\n    if (state.eat(0x7B /* { */)) {\r\n      var min = 0, max = -1;\r\n      if (this.regexp_eatDecimalDigits(state)) {\r\n        min = state.lastIntValue;\r\n        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\r\n          max = state.lastIntValue;\r\n        }\r\n        if (state.eat(0x7D /* } */)) {\r\n          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\r\n          if (max !== -1 && max < min && !noError) {\r\n            state.raise(\"numbers out of order in {} quantifier\");\r\n          }\r\n          return true\r\n        }\r\n      }\r\n      if (state.switchU && !noError) {\r\n        state.raise(\"Incomplete quantifier\");\r\n      }\r\n      state.pos = start;\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\r\n  pp$9.regexp_eatAtom = function(state) {\r\n    return (\r\n      this.regexp_eatPatternCharacters(state) ||\r\n      state.eat(0x2E /* . */) ||\r\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\r\n      this.regexp_eatCharacterClass(state) ||\r\n      this.regexp_eatUncapturingGroup(state) ||\r\n      this.regexp_eatCapturingGroup(state)\r\n    )\r\n  };\r\n  pp$9.regexp_eatReverseSolidusAtomEscape = function(state) {\r\n    var start = state.pos;\r\n    if (state.eat(0x5C /* \\ */)) {\r\n      if (this.regexp_eatAtomEscape(state)) {\r\n        return true\r\n      }\r\n      state.pos = start;\r\n    }\r\n    return false\r\n  };\r\n  pp$9.regexp_eatUncapturingGroup = function(state) {\r\n    var start = state.pos;\r\n    if (state.eat(0x28 /* ( */)) {\r\n      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\r\n        this.regexp_disjunction(state);\r\n        if (state.eat(0x29 /* ) */)) {\r\n          return true\r\n        }\r\n        state.raise(\"Unterminated group\");\r\n      }\r\n      state.pos = start;\r\n    }\r\n    return false\r\n  };\r\n  pp$9.regexp_eatCapturingGroup = function(state) {\r\n    if (state.eat(0x28 /* ( */)) {\r\n      if (this.options.ecmaVersion >= 9) {\r\n        this.regexp_groupSpecifier(state);\r\n      } else if (state.current() === 0x3F /* ? */) {\r\n        state.raise(\"Invalid group\");\r\n      }\r\n      this.regexp_disjunction(state);\r\n      if (state.eat(0x29 /* ) */)) {\r\n        state.numCapturingParens += 1;\r\n        return true\r\n      }\r\n      state.raise(\"Unterminated group\");\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\r\n  pp$9.regexp_eatExtendedAtom = function(state) {\r\n    return (\r\n      state.eat(0x2E /* . */) ||\r\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\r\n      this.regexp_eatCharacterClass(state) ||\r\n      this.regexp_eatUncapturingGroup(state) ||\r\n      this.regexp_eatCapturingGroup(state) ||\r\n      this.regexp_eatInvalidBracedQuantifier(state) ||\r\n      this.regexp_eatExtendedPatternCharacter(state)\r\n    )\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\r\n  pp$9.regexp_eatInvalidBracedQuantifier = function(state) {\r\n    if (this.regexp_eatBracedQuantifier(state, true)) {\r\n      state.raise(\"Nothing to repeat\");\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\r\n  pp$9.regexp_eatSyntaxCharacter = function(state) {\r\n    var ch = state.current();\r\n    if (isSyntaxCharacter(ch)) {\r\n      state.lastIntValue = ch;\r\n      state.advance();\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n  function isSyntaxCharacter(ch) {\r\n    return (\r\n      ch === 0x24 /* $ */ ||\r\n      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\r\n      ch === 0x2E /* . */ ||\r\n      ch === 0x3F /* ? */ ||\r\n      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\r\n      ch >= 0x7B /* { */ && ch <= 0x7D /* } */\r\n    )\r\n  }\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\r\n  // But eat eager.\r\n  pp$9.regexp_eatPatternCharacters = function(state) {\r\n    var start = state.pos;\r\n    var ch = 0;\r\n    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\r\n      state.advance();\r\n    }\r\n    return state.pos !== start\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\r\n  pp$9.regexp_eatExtendedPatternCharacter = function(state) {\r\n    var ch = state.current();\r\n    if (\r\n      ch !== -1 &&\r\n      ch !== 0x24 /* $ */ &&\r\n      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\r\n      ch !== 0x2E /* . */ &&\r\n      ch !== 0x3F /* ? */ &&\r\n      ch !== 0x5B /* [ */ &&\r\n      ch !== 0x5E /* ^ */ &&\r\n      ch !== 0x7C /* | */\r\n    ) {\r\n      state.advance();\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // GroupSpecifier[U] ::\r\n  //   [empty]\r\n  //   `?` GroupName[?U]\r\n  pp$9.regexp_groupSpecifier = function(state) {\r\n    if (state.eat(0x3F /* ? */)) {\r\n      if (this.regexp_eatGroupName(state)) {\r\n        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\r\n          state.raise(\"Duplicate capture group name\");\r\n        }\r\n        state.groupNames.push(state.lastStringValue);\r\n        return\r\n      }\r\n      state.raise(\"Invalid group\");\r\n    }\r\n  };\r\n\r\n  // GroupName[U] ::\r\n  //   `<` RegExpIdentifierName[?U] `>`\r\n  // Note: this updates `state.lastStringValue` property with the eaten name.\r\n  pp$9.regexp_eatGroupName = function(state) {\r\n    state.lastStringValue = \"\";\r\n    if (state.eat(0x3C /* < */)) {\r\n      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\r\n        return true\r\n      }\r\n      state.raise(\"Invalid capture group name\");\r\n    }\r\n    return false\r\n  };\r\n\r\n  // RegExpIdentifierName[U] ::\r\n  //   RegExpIdentifierStart[?U]\r\n  //   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\r\n  // Note: this updates `state.lastStringValue` property with the eaten name.\r\n  pp$9.regexp_eatRegExpIdentifierName = function(state) {\r\n    state.lastStringValue = \"\";\r\n    if (this.regexp_eatRegExpIdentifierStart(state)) {\r\n      state.lastStringValue += codePointToString$1(state.lastIntValue);\r\n      while (this.regexp_eatRegExpIdentifierPart(state)) {\r\n        state.lastStringValue += codePointToString$1(state.lastIntValue);\r\n      }\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // RegExpIdentifierStart[U] ::\r\n  //   UnicodeIDStart\r\n  //   `$`\r\n  //   `_`\r\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\r\n  pp$9.regexp_eatRegExpIdentifierStart = function(state) {\r\n    var start = state.pos;\r\n    var ch = state.current();\r\n    state.advance();\r\n\r\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\r\n      ch = state.lastIntValue;\r\n    }\r\n    if (isRegExpIdentifierStart(ch)) {\r\n      state.lastIntValue = ch;\r\n      return true\r\n    }\r\n\r\n    state.pos = start;\r\n    return false\r\n  };\r\n  function isRegExpIdentifierStart(ch) {\r\n    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\r\n  }\r\n\r\n  // RegExpIdentifierPart[U] ::\r\n  //   UnicodeIDContinue\r\n  //   `$`\r\n  //   `_`\r\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\r\n  //   <ZWNJ>\r\n  //   <ZWJ>\r\n  pp$9.regexp_eatRegExpIdentifierPart = function(state) {\r\n    var start = state.pos;\r\n    var ch = state.current();\r\n    state.advance();\r\n\r\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\r\n      ch = state.lastIntValue;\r\n    }\r\n    if (isRegExpIdentifierPart(ch)) {\r\n      state.lastIntValue = ch;\r\n      return true\r\n    }\r\n\r\n    state.pos = start;\r\n    return false\r\n  };\r\n  function isRegExpIdentifierPart(ch) {\r\n    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\r\n  }\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\r\n  pp$9.regexp_eatAtomEscape = function(state) {\r\n    if (\r\n      this.regexp_eatBackReference(state) ||\r\n      this.regexp_eatCharacterClassEscape(state) ||\r\n      this.regexp_eatCharacterEscape(state) ||\r\n      (state.switchN && this.regexp_eatKGroupName(state))\r\n    ) {\r\n      return true\r\n    }\r\n    if (state.switchU) {\r\n      // Make the same message as V8.\r\n      if (state.current() === 0x63 /* c */) {\r\n        state.raise(\"Invalid unicode escape\");\r\n      }\r\n      state.raise(\"Invalid escape\");\r\n    }\r\n    return false\r\n  };\r\n  pp$9.regexp_eatBackReference = function(state) {\r\n    var start = state.pos;\r\n    if (this.regexp_eatDecimalEscape(state)) {\r\n      var n = state.lastIntValue;\r\n      if (state.switchU) {\r\n        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\r\n        if (n > state.maxBackReference) {\r\n          state.maxBackReference = n;\r\n        }\r\n        return true\r\n      }\r\n      if (n <= state.numCapturingParens) {\r\n        return true\r\n      }\r\n      state.pos = start;\r\n    }\r\n    return false\r\n  };\r\n  pp$9.regexp_eatKGroupName = function(state) {\r\n    if (state.eat(0x6B /* k */)) {\r\n      if (this.regexp_eatGroupName(state)) {\r\n        state.backReferenceNames.push(state.lastStringValue);\r\n        return true\r\n      }\r\n      state.raise(\"Invalid named reference\");\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\r\n  pp$9.regexp_eatCharacterEscape = function(state) {\r\n    return (\r\n      this.regexp_eatControlEscape(state) ||\r\n      this.regexp_eatCControlLetter(state) ||\r\n      this.regexp_eatZero(state) ||\r\n      this.regexp_eatHexEscapeSequence(state) ||\r\n      this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\r\n      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\r\n      this.regexp_eatIdentityEscape(state)\r\n    )\r\n  };\r\n  pp$9.regexp_eatCControlLetter = function(state) {\r\n    var start = state.pos;\r\n    if (state.eat(0x63 /* c */)) {\r\n      if (this.regexp_eatControlLetter(state)) {\r\n        return true\r\n      }\r\n      state.pos = start;\r\n    }\r\n    return false\r\n  };\r\n  pp$9.regexp_eatZero = function(state) {\r\n    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\r\n      state.lastIntValue = 0;\r\n      state.advance();\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\r\n  pp$9.regexp_eatControlEscape = function(state) {\r\n    var ch = state.current();\r\n    if (ch === 0x74 /* t */) {\r\n      state.lastIntValue = 0x09; /* \\t */\r\n      state.advance();\r\n      return true\r\n    }\r\n    if (ch === 0x6E /* n */) {\r\n      state.lastIntValue = 0x0A; /* \\n */\r\n      state.advance();\r\n      return true\r\n    }\r\n    if (ch === 0x76 /* v */) {\r\n      state.lastIntValue = 0x0B; /* \\v */\r\n      state.advance();\r\n      return true\r\n    }\r\n    if (ch === 0x66 /* f */) {\r\n      state.lastIntValue = 0x0C; /* \\f */\r\n      state.advance();\r\n      return true\r\n    }\r\n    if (ch === 0x72 /* r */) {\r\n      state.lastIntValue = 0x0D; /* \\r */\r\n      state.advance();\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\r\n  pp$9.regexp_eatControlLetter = function(state) {\r\n    var ch = state.current();\r\n    if (isControlLetter(ch)) {\r\n      state.lastIntValue = ch % 0x20;\r\n      state.advance();\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n  function isControlLetter(ch) {\r\n    return (\r\n      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\r\n      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\r\n    )\r\n  }\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\r\n  pp$9.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\r\n    var start = state.pos;\r\n\r\n    if (state.eat(0x75 /* u */)) {\r\n      if (this.regexp_eatFixedHexDigits(state, 4)) {\r\n        var lead = state.lastIntValue;\r\n        if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\r\n          var leadSurrogateEnd = state.pos;\r\n          if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\r\n            var trail = state.lastIntValue;\r\n            if (trail >= 0xDC00 && trail <= 0xDFFF) {\r\n              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\r\n              return true\r\n            }\r\n          }\r\n          state.pos = leadSurrogateEnd;\r\n          state.lastIntValue = lead;\r\n        }\r\n        return true\r\n      }\r\n      if (\r\n        state.switchU &&\r\n        state.eat(0x7B /* { */) &&\r\n        this.regexp_eatHexDigits(state) &&\r\n        state.eat(0x7D /* } */) &&\r\n        isValidUnicode(state.lastIntValue)\r\n      ) {\r\n        return true\r\n      }\r\n      if (state.switchU) {\r\n        state.raise(\"Invalid unicode escape\");\r\n      }\r\n      state.pos = start;\r\n    }\r\n\r\n    return false\r\n  };\r\n  function isValidUnicode(ch) {\r\n    return ch >= 0 && ch <= 0x10FFFF\r\n  }\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\r\n  pp$9.regexp_eatIdentityEscape = function(state) {\r\n    if (state.switchU) {\r\n      if (this.regexp_eatSyntaxCharacter(state)) {\r\n        return true\r\n      }\r\n      if (state.eat(0x2F /* / */)) {\r\n        state.lastIntValue = 0x2F; /* / */\r\n        return true\r\n      }\r\n      return false\r\n    }\r\n\r\n    var ch = state.current();\r\n    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\r\n      state.lastIntValue = ch;\r\n      state.advance();\r\n      return true\r\n    }\r\n\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\r\n  pp$9.regexp_eatDecimalEscape = function(state) {\r\n    state.lastIntValue = 0;\r\n    var ch = state.current();\r\n    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\r\n      do {\r\n        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\r\n        state.advance();\r\n      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\r\n  pp$9.regexp_eatCharacterClassEscape = function(state) {\r\n    var ch = state.current();\r\n\r\n    if (isCharacterClassEscape(ch)) {\r\n      state.lastIntValue = -1;\r\n      state.advance();\r\n      return true\r\n    }\r\n\r\n    if (\r\n      state.switchU &&\r\n      this.options.ecmaVersion >= 9 &&\r\n      (ch === 0x50 /* P */ || ch === 0x70 /* p */)\r\n    ) {\r\n      state.lastIntValue = -1;\r\n      state.advance();\r\n      if (\r\n        state.eat(0x7B /* { */) &&\r\n        this.regexp_eatUnicodePropertyValueExpression(state) &&\r\n        state.eat(0x7D /* } */)\r\n      ) {\r\n        return true\r\n      }\r\n      state.raise(\"Invalid property name\");\r\n    }\r\n\r\n    return false\r\n  };\r\n  function isCharacterClassEscape(ch) {\r\n    return (\r\n      ch === 0x64 /* d */ ||\r\n      ch === 0x44 /* D */ ||\r\n      ch === 0x73 /* s */ ||\r\n      ch === 0x53 /* S */ ||\r\n      ch === 0x77 /* w */ ||\r\n      ch === 0x57 /* W */\r\n    )\r\n  }\r\n\r\n  // UnicodePropertyValueExpression ::\r\n  //   UnicodePropertyName `=` UnicodePropertyValue\r\n  //   LoneUnicodePropertyNameOrValue\r\n  pp$9.regexp_eatUnicodePropertyValueExpression = function(state) {\r\n    var start = state.pos;\r\n\r\n    // UnicodePropertyName `=` UnicodePropertyValue\r\n    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\r\n      var name = state.lastStringValue;\r\n      if (this.regexp_eatUnicodePropertyValue(state)) {\r\n        var value = state.lastStringValue;\r\n        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\r\n        return true\r\n      }\r\n    }\r\n    state.pos = start;\r\n\r\n    // LoneUnicodePropertyNameOrValue\r\n    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\r\n      var nameOrValue = state.lastStringValue;\r\n      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n  pp$9.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\r\n    if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {\r\n      state.raise(\"Invalid property name\");\r\n    }\r\n  };\r\n  pp$9.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\r\n    if (data.$LONE.indexOf(nameOrValue) === -1) {\r\n      state.raise(\"Invalid property name\");\r\n    }\r\n  };\r\n\r\n  // UnicodePropertyName ::\r\n  //   UnicodePropertyNameCharacters\r\n  pp$9.regexp_eatUnicodePropertyName = function(state) {\r\n    var ch = 0;\r\n    state.lastStringValue = \"\";\r\n    while (isUnicodePropertyNameCharacter(ch = state.current())) {\r\n      state.lastStringValue += codePointToString$1(ch);\r\n      state.advance();\r\n    }\r\n    return state.lastStringValue !== \"\"\r\n  };\r\n  function isUnicodePropertyNameCharacter(ch) {\r\n    return isControlLetter(ch) || ch === 0x5F /* _ */\r\n  }\r\n\r\n  // UnicodePropertyValue ::\r\n  //   UnicodePropertyValueCharacters\r\n  pp$9.regexp_eatUnicodePropertyValue = function(state) {\r\n    var ch = 0;\r\n    state.lastStringValue = \"\";\r\n    while (isUnicodePropertyValueCharacter(ch = state.current())) {\r\n      state.lastStringValue += codePointToString$1(ch);\r\n      state.advance();\r\n    }\r\n    return state.lastStringValue !== \"\"\r\n  };\r\n  function isUnicodePropertyValueCharacter(ch) {\r\n    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\r\n  }\r\n\r\n  // LoneUnicodePropertyNameOrValue ::\r\n  //   UnicodePropertyValueCharacters\r\n  pp$9.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\r\n    return this.regexp_eatUnicodePropertyValue(state)\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\r\n  pp$9.regexp_eatCharacterClass = function(state) {\r\n    if (state.eat(0x5B /* [ */)) {\r\n      state.eat(0x5E /* ^ */);\r\n      this.regexp_classRanges(state);\r\n      if (state.eat(0x5D /* [ */)) {\r\n        return true\r\n      }\r\n      // Unreachable since it threw \"unterminated regular expression\" error before.\r\n      state.raise(\"Unterminated character class\");\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\r\n  pp$9.regexp_classRanges = function(state) {\r\n    var this$1 = this;\r\n\r\n    while (this.regexp_eatClassAtom(state)) {\r\n      var left = state.lastIntValue;\r\n      if (state.eat(0x2D /* - */) && this$1.regexp_eatClassAtom(state)) {\r\n        var right = state.lastIntValue;\r\n        if (state.switchU && (left === -1 || right === -1)) {\r\n          state.raise(\"Invalid character class\");\r\n        }\r\n        if (left !== -1 && right !== -1 && left > right) {\r\n          state.raise(\"Range out of order in character class\");\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\r\n  pp$9.regexp_eatClassAtom = function(state) {\r\n    var start = state.pos;\r\n\r\n    if (state.eat(0x5C /* \\ */)) {\r\n      if (this.regexp_eatClassEscape(state)) {\r\n        return true\r\n      }\r\n      if (state.switchU) {\r\n        // Make the same message as V8.\r\n        var ch$1 = state.current();\r\n        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\r\n          state.raise(\"Invalid class escape\");\r\n        }\r\n        state.raise(\"Invalid escape\");\r\n      }\r\n      state.pos = start;\r\n    }\r\n\r\n    var ch = state.current();\r\n    if (ch !== 0x5D /* [ */) {\r\n      state.lastIntValue = ch;\r\n      state.advance();\r\n      return true\r\n    }\r\n\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\r\n  pp$9.regexp_eatClassEscape = function(state) {\r\n    var start = state.pos;\r\n\r\n    if (state.eat(0x62 /* b */)) {\r\n      state.lastIntValue = 0x08; /* <BS> */\r\n      return true\r\n    }\r\n\r\n    if (state.switchU && state.eat(0x2D /* - */)) {\r\n      state.lastIntValue = 0x2D; /* - */\r\n      return true\r\n    }\r\n\r\n    if (!state.switchU && state.eat(0x63 /* c */)) {\r\n      if (this.regexp_eatClassControlLetter(state)) {\r\n        return true\r\n      }\r\n      state.pos = start;\r\n    }\r\n\r\n    return (\r\n      this.regexp_eatCharacterClassEscape(state) ||\r\n      this.regexp_eatCharacterEscape(state)\r\n    )\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\r\n  pp$9.regexp_eatClassControlLetter = function(state) {\r\n    var ch = state.current();\r\n    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\r\n      state.lastIntValue = ch % 0x20;\r\n      state.advance();\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\r\n  pp$9.regexp_eatHexEscapeSequence = function(state) {\r\n    var start = state.pos;\r\n    if (state.eat(0x78 /* x */)) {\r\n      if (this.regexp_eatFixedHexDigits(state, 2)) {\r\n        return true\r\n      }\r\n      if (state.switchU) {\r\n        state.raise(\"Invalid escape\");\r\n      }\r\n      state.pos = start;\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\r\n  pp$9.regexp_eatDecimalDigits = function(state) {\r\n    var start = state.pos;\r\n    var ch = 0;\r\n    state.lastIntValue = 0;\r\n    while (isDecimalDigit(ch = state.current())) {\r\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\r\n      state.advance();\r\n    }\r\n    return state.pos !== start\r\n  };\r\n  function isDecimalDigit(ch) {\r\n    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\r\n  }\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\r\n  pp$9.regexp_eatHexDigits = function(state) {\r\n    var start = state.pos;\r\n    var ch = 0;\r\n    state.lastIntValue = 0;\r\n    while (isHexDigit(ch = state.current())) {\r\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\r\n      state.advance();\r\n    }\r\n    return state.pos !== start\r\n  };\r\n  function isHexDigit(ch) {\r\n    return (\r\n      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\r\n      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\r\n      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\r\n    )\r\n  }\r\n  function hexToInt(ch) {\r\n    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\r\n      return 10 + (ch - 0x41 /* A */)\r\n    }\r\n    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\r\n      return 10 + (ch - 0x61 /* a */)\r\n    }\r\n    return ch - 0x30 /* 0 */\r\n  }\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\r\n  // Allows only 0-377(octal) i.e. 0-255(decimal).\r\n  pp$9.regexp_eatLegacyOctalEscapeSequence = function(state) {\r\n    if (this.regexp_eatOctalDigit(state)) {\r\n      var n1 = state.lastIntValue;\r\n      if (this.regexp_eatOctalDigit(state)) {\r\n        var n2 = state.lastIntValue;\r\n        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\r\n          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\r\n        } else {\r\n          state.lastIntValue = n1 * 8 + n2;\r\n        }\r\n      } else {\r\n        state.lastIntValue = n1;\r\n      }\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\r\n  pp$9.regexp_eatOctalDigit = function(state) {\r\n    var ch = state.current();\r\n    if (isOctalDigit(ch)) {\r\n      state.lastIntValue = ch - 0x30; /* 0 */\r\n      state.advance();\r\n      return true\r\n    }\r\n    state.lastIntValue = 0;\r\n    return false\r\n  };\r\n  function isOctalDigit(ch) {\r\n    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\r\n  }\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\r\n  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\r\n  pp$9.regexp_eatFixedHexDigits = function(state, length) {\r\n    var start = state.pos;\r\n    state.lastIntValue = 0;\r\n    for (var i = 0; i < length; ++i) {\r\n      var ch = state.current();\r\n      if (!isHexDigit(ch)) {\r\n        state.pos = start;\r\n        return false\r\n      }\r\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\r\n      state.advance();\r\n    }\r\n    return true\r\n  };\r\n\r\n  // Object type used to represent tokens. Note that normally, tokens\r\n  // simply exist as properties on the parser object. This is only\r\n  // used for the onToken callback and the external tokenizer.\r\n\r\n  var Token = function Token(p) {\r\n    this.type = p.type;\r\n    this.value = p.value;\r\n    this.start = p.start;\r\n    this.end = p.end;\r\n    if (p.options.locations)\r\n      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\r\n    if (p.options.ranges)\r\n      { this.range = [p.start, p.end]; }\r\n  };\r\n\r\n  // ## Tokenizer\r\n\r\n  var pp$8 = Parser.prototype;\r\n\r\n  // Move to the next token\r\n\r\n  pp$8.next = function() {\r\n    if (this.options.onToken)\r\n      { this.options.onToken(new Token(this)); }\r\n\r\n    this.lastTokEnd = this.end;\r\n    this.lastTokStart = this.start;\r\n    this.lastTokEndLoc = this.endLoc;\r\n    this.lastTokStartLoc = this.startLoc;\r\n    this.nextToken();\r\n  };\r\n\r\n  pp$8.getToken = function() {\r\n    this.next();\r\n    return new Token(this)\r\n  };\r\n\r\n  // If we're in an ES6 environment, make parsers iterable\r\n  if (typeof Symbol !== \"undefined\")\r\n    { pp$8[Symbol.iterator] = function() {\r\n      var this$1 = this;\r\n\r\n      return {\r\n        next: function () {\r\n          var token = this$1.getToken();\r\n          return {\r\n            done: token.type === types.eof,\r\n            value: token\r\n          }\r\n        }\r\n      }\r\n    }; }\r\n\r\n  // Toggle strict mode. Re-reads the next number or string to please\r\n  // pedantic tests (`\"use strict\"; 010;` should fail).\r\n\r\n  pp$8.curContext = function() {\r\n    return this.context[this.context.length - 1]\r\n  };\r\n\r\n  // Read a single token, updating the parser object's token-related\r\n  // properties.\r\n\r\n  pp$8.nextToken = function() {\r\n    var curContext = this.curContext();\r\n    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\r\n\r\n    this.start = this.pos;\r\n    if (this.options.locations) { this.startLoc = this.curPosition(); }\r\n    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\r\n\r\n    if (curContext.override) { return curContext.override(this) }\r\n    else { this.readToken(this.fullCharCodeAtPos()); }\r\n  };\r\n\r\n  pp$8.readToken = function(code) {\r\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\r\n    // identifiers, so '\\' also dispatches to that.\r\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\r\n      { return this.readWord() }\r\n\r\n    return this.getTokenFromCode(code)\r\n  };\r\n\r\n  pp$8.fullCharCodeAtPos = function() {\r\n    var code = this.input.charCodeAt(this.pos);\r\n    if (code <= 0xd7ff || code >= 0xe000) { return code }\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    return (code << 10) + next - 0x35fdc00\r\n  };\r\n\r\n  pp$8.skipBlockComment = function() {\r\n    var this$1 = this;\r\n\r\n    var startLoc = this.options.onComment && this.curPosition();\r\n    var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\r\n    if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\r\n    this.pos = end + 2;\r\n    if (this.options.locations) {\r\n      lineBreakG.lastIndex = start;\r\n      var match;\r\n      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\r\n        ++this$1.curLine;\r\n        this$1.lineStart = match.index + match[0].length;\r\n      }\r\n    }\r\n    if (this.options.onComment)\r\n      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\r\n                             startLoc, this.curPosition()); }\r\n  };\r\n\r\n  pp$8.skipLineComment = function(startSkip) {\r\n    var this$1 = this;\r\n\r\n    var start = this.pos;\r\n    var startLoc = this.options.onComment && this.curPosition();\r\n    var ch = this.input.charCodeAt(this.pos += startSkip);\r\n    while (this.pos < this.input.length && !isNewLine(ch)) {\r\n      ch = this$1.input.charCodeAt(++this$1.pos);\r\n    }\r\n    if (this.options.onComment)\r\n      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\r\n                             startLoc, this.curPosition()); }\r\n  };\r\n\r\n  // Called at the start of the parse and after every token. Skips\r\n  // whitespace and comments, and.\r\n\r\n  pp$8.skipSpace = function() {\r\n    var this$1 = this;\r\n\r\n    loop: while (this.pos < this.input.length) {\r\n      var ch = this$1.input.charCodeAt(this$1.pos);\r\n      switch (ch) {\r\n      case 32: case 160: // ' '\r\n        ++this$1.pos;\r\n        break\r\n      case 13:\r\n        if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\r\n          ++this$1.pos;\r\n        }\r\n      case 10: case 8232: case 8233:\r\n        ++this$1.pos;\r\n        if (this$1.options.locations) {\r\n          ++this$1.curLine;\r\n          this$1.lineStart = this$1.pos;\r\n        }\r\n        break\r\n      case 47: // '/'\r\n        switch (this$1.input.charCodeAt(this$1.pos + 1)) {\r\n        case 42: // '*'\r\n          this$1.skipBlockComment();\r\n          break\r\n        case 47:\r\n          this$1.skipLineComment(2);\r\n          break\r\n        default:\r\n          break loop\r\n        }\r\n        break\r\n      default:\r\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\r\n          ++this$1.pos;\r\n        } else {\r\n          break loop\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // Called at the end of every token. Sets `end`, `val`, and\r\n  // maintains `context` and `exprAllowed`, and skips the space after\r\n  // the token, so that the next one's `start` will point at the\r\n  // right position.\r\n\r\n  pp$8.finishToken = function(type, val) {\r\n    this.end = this.pos;\r\n    if (this.options.locations) { this.endLoc = this.curPosition(); }\r\n    var prevType = this.type;\r\n    this.type = type;\r\n    this.value = val;\r\n\r\n    this.updateContext(prevType);\r\n  };\r\n\r\n  // ### Token reading\r\n\r\n  // This is the function that is called to fetch the next token. It\r\n  // is somewhat obscure, because it works in character codes rather\r\n  // than characters, and because operator parsing has been inlined\r\n  // into it.\r\n  //\r\n  // All in the name of speed.\r\n  //\r\n  pp$8.readToken_dot = function() {\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    if (next >= 48 && next <= 57) { return this.readNumber(true) }\r\n    var next2 = this.input.charCodeAt(this.pos + 2);\r\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\r\n      this.pos += 3;\r\n      return this.finishToken(types.ellipsis)\r\n    } else {\r\n      ++this.pos;\r\n      return this.finishToken(types.dot)\r\n    }\r\n  };\r\n\r\n  pp$8.readToken_slash = function() { // '/'\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\r\n    if (next === 61) { return this.finishOp(types.assign, 2) }\r\n    return this.finishOp(types.slash, 1)\r\n  };\r\n\r\n  pp$8.readToken_mult_modulo_exp = function(code) { // '%*'\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    var size = 1;\r\n    var tokentype = code === 42 ? types.star : types.modulo;\r\n\r\n    // exponentiation operator ** and **=\r\n    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\r\n      ++size;\r\n      tokentype = types.starstar;\r\n      next = this.input.charCodeAt(this.pos + 2);\r\n    }\r\n\r\n    if (next === 61) { return this.finishOp(types.assign, size + 1) }\r\n    return this.finishOp(tokentype, size)\r\n  };\r\n\r\n  pp$8.readToken_pipe_amp = function(code) { // '|&'\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\r\n    if (next === 61) { return this.finishOp(types.assign, 2) }\r\n    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\r\n  };\r\n\r\n  pp$8.readToken_caret = function() { // '^'\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    if (next === 61) { return this.finishOp(types.assign, 2) }\r\n    return this.finishOp(types.bitwiseXOR, 1)\r\n  };\r\n\r\n  pp$8.readToken_plus_min = function(code) { // '+-'\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    if (next === code) {\r\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\r\n          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\r\n        // A `-->` line comment\r\n        this.skipLineComment(3);\r\n        this.skipSpace();\r\n        return this.nextToken()\r\n      }\r\n      return this.finishOp(types.incDec, 2)\r\n    }\r\n    if (next === 61) { return this.finishOp(types.assign, 2) }\r\n    return this.finishOp(types.plusMin, 1)\r\n  };\r\n\r\n  pp$8.readToken_lt_gt = function(code) { // '<>'\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    var size = 1;\r\n    if (next === code) {\r\n      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\r\n      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\r\n      return this.finishOp(types.bitShift, size)\r\n    }\r\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\r\n        this.input.charCodeAt(this.pos + 3) === 45) {\r\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\r\n      this.skipLineComment(4);\r\n      this.skipSpace();\r\n      return this.nextToken()\r\n    }\r\n    if (next === 61) { size = 2; }\r\n    return this.finishOp(types.relational, size)\r\n  };\r\n\r\n  pp$8.readToken_eq_excl = function(code) { // '=!'\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\r\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\r\n      this.pos += 2;\r\n      return this.finishToken(types.arrow)\r\n    }\r\n    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\r\n  };\r\n\r\n  pp$8.getTokenFromCode = function(code) {\r\n    switch (code) {\r\n    // The interpretation of a dot depends on whether it is followed\r\n    // by a digit or another two dots.\r\n    case 46: // '.'\r\n      return this.readToken_dot()\r\n\r\n    // Punctuation tokens.\r\n    case 40: ++this.pos; return this.finishToken(types.parenL)\r\n    case 41: ++this.pos; return this.finishToken(types.parenR)\r\n    case 59: ++this.pos; return this.finishToken(types.semi)\r\n    case 44: ++this.pos; return this.finishToken(types.comma)\r\n    case 91: ++this.pos; return this.finishToken(types.bracketL)\r\n    case 93: ++this.pos; return this.finishToken(types.bracketR)\r\n    case 123: ++this.pos; return this.finishToken(types.braceL)\r\n    case 125: ++this.pos; return this.finishToken(types.braceR)\r\n    case 58: ++this.pos; return this.finishToken(types.colon)\r\n    case 63: ++this.pos; return this.finishToken(types.question)\r\n\r\n    case 96: // '`'\r\n      if (this.options.ecmaVersion < 6) { break }\r\n      ++this.pos;\r\n      return this.finishToken(types.backQuote)\r\n\r\n    case 48: // '0'\r\n      var next = this.input.charCodeAt(this.pos + 1);\r\n      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\r\n      if (this.options.ecmaVersion >= 6) {\r\n        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\r\n        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\r\n      }\r\n\r\n    // Anything else beginning with a digit is an integer, octal\r\n    // number, or float.\r\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\r\n      return this.readNumber(false)\r\n\r\n    // Quotes produce strings.\r\n    case 34: case 39: // '\"', \"'\"\r\n      return this.readString(code)\r\n\r\n    // Operators are parsed inline in tiny state machines. '=' (61) is\r\n    // often referred to. `finishOp` simply skips the amount of\r\n    // characters it is given as second argument, and returns a token\r\n    // of the type given by its first argument.\r\n\r\n    case 47: // '/'\r\n      return this.readToken_slash()\r\n\r\n    case 37: case 42: // '%*'\r\n      return this.readToken_mult_modulo_exp(code)\r\n\r\n    case 124: case 38: // '|&'\r\n      return this.readToken_pipe_amp(code)\r\n\r\n    case 94: // '^'\r\n      return this.readToken_caret()\r\n\r\n    case 43: case 45: // '+-'\r\n      return this.readToken_plus_min(code)\r\n\r\n    case 60: case 62: // '<>'\r\n      return this.readToken_lt_gt(code)\r\n\r\n    case 61: case 33: // '=!'\r\n      return this.readToken_eq_excl(code)\r\n\r\n    case 126: // '~'\r\n      return this.finishOp(types.prefix, 1)\r\n    }\r\n\r\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\r\n  };\r\n\r\n  pp$8.finishOp = function(type, size) {\r\n    var str = this.input.slice(this.pos, this.pos + size);\r\n    this.pos += size;\r\n    return this.finishToken(type, str)\r\n  };\r\n\r\n  pp$8.readRegexp = function() {\r\n    var this$1 = this;\r\n\r\n    var escaped, inClass, start = this.pos;\r\n    for (;;) {\r\n      if (this$1.pos >= this$1.input.length) { this$1.raise(start, \"Unterminated regular expression\"); }\r\n      var ch = this$1.input.charAt(this$1.pos);\r\n      if (lineBreak.test(ch)) { this$1.raise(start, \"Unterminated regular expression\"); }\r\n      if (!escaped) {\r\n        if (ch === \"[\") { inClass = true; }\r\n        else if (ch === \"]\" && inClass) { inClass = false; }\r\n        else if (ch === \"/\" && !inClass) { break }\r\n        escaped = ch === \"\\\\\";\r\n      } else { escaped = false; }\r\n      ++this$1.pos;\r\n    }\r\n    var pattern = this.input.slice(start, this.pos);\r\n    ++this.pos;\r\n    var flagsStart = this.pos;\r\n    var flags = this.readWord1();\r\n    if (this.containsEsc) { this.unexpected(flagsStart); }\r\n\r\n    // Validate pattern\r\n    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\r\n    state.reset(start, pattern, flags);\r\n    this.validateRegExpFlags(state);\r\n    this.validateRegExpPattern(state);\r\n\r\n    // Create Literal#value property value.\r\n    var value = null;\r\n    try {\r\n      value = new RegExp(pattern, flags);\r\n    } catch (e) {\r\n      // ESTree requires null if it failed to instantiate RegExp object.\r\n      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\r\n    }\r\n\r\n    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\r\n  };\r\n\r\n  // Read an integer in the given radix. Return null if zero digits\r\n  // were read, the integer value otherwise. When `len` is given, this\r\n  // will return `null` unless the integer has exactly `len` digits.\r\n\r\n  pp$8.readInt = function(radix, len) {\r\n    var this$1 = this;\r\n\r\n    var start = this.pos, total = 0;\r\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\r\n      var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);\r\n      if (code >= 97) { val = code - 97 + 10; } // a\r\n      else if (code >= 65) { val = code - 65 + 10; } // A\r\n      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\r\n      else { val = Infinity; }\r\n      if (val >= radix) { break }\r\n      ++this$1.pos;\r\n      total = total * radix + val;\r\n    }\r\n    if (this.pos === start || len != null && this.pos - start !== len) { return null }\r\n\r\n    return total\r\n  };\r\n\r\n  pp$8.readRadixNumber = function(radix) {\r\n    this.pos += 2; // 0x\r\n    var val = this.readInt(radix);\r\n    if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\r\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\r\n    return this.finishToken(types.num, val)\r\n  };\r\n\r\n  // Read an integer, octal integer, or floating-point number.\r\n\r\n  pp$8.readNumber = function(startsWithDot) {\r\n    var start = this.pos;\r\n    if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\r\n    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\r\n    if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\r\n    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\r\n    var next = this.input.charCodeAt(this.pos);\r\n    if (next === 46 && !octal) { // '.'\r\n      ++this.pos;\r\n      this.readInt(10);\r\n      next = this.input.charCodeAt(this.pos);\r\n    }\r\n    if ((next === 69 || next === 101) && !octal) { // 'eE'\r\n      next = this.input.charCodeAt(++this.pos);\r\n      if (next === 43 || next === 45) { ++this.pos; } // '+-'\r\n      if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\r\n    }\r\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\r\n\r\n    var str = this.input.slice(start, this.pos);\r\n    var val = octal ? parseInt(str, 8) : parseFloat(str);\r\n    return this.finishToken(types.num, val)\r\n  };\r\n\r\n  // Read a string value, interpreting backslash-escapes.\r\n\r\n  pp$8.readCodePoint = function() {\r\n    var ch = this.input.charCodeAt(this.pos), code;\r\n\r\n    if (ch === 123) { // '{'\r\n      if (this.options.ecmaVersion < 6) { this.unexpected(); }\r\n      var codePos = ++this.pos;\r\n      code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\r\n      ++this.pos;\r\n      if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\r\n    } else {\r\n      code = this.readHexChar(4);\r\n    }\r\n    return code\r\n  };\r\n\r\n  function codePointToString(code) {\r\n    // UTF-16 Decoding\r\n    if (code <= 0xFFFF) { return String.fromCharCode(code) }\r\n    code -= 0x10000;\r\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\r\n  }\r\n\r\n  pp$8.readString = function(quote) {\r\n    var this$1 = this;\r\n\r\n    var out = \"\", chunkStart = ++this.pos;\r\n    for (;;) {\r\n      if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\r\n      var ch = this$1.input.charCodeAt(this$1.pos);\r\n      if (ch === quote) { break }\r\n      if (ch === 92) { // '\\'\r\n        out += this$1.input.slice(chunkStart, this$1.pos);\r\n        out += this$1.readEscapedChar(false);\r\n        chunkStart = this$1.pos;\r\n      } else {\r\n        if (isNewLine(ch, this$1.options.ecmaVersion >= 10)) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\r\n        ++this$1.pos;\r\n      }\r\n    }\r\n    out += this.input.slice(chunkStart, this.pos++);\r\n    return this.finishToken(types.string, out)\r\n  };\r\n\r\n  // Reads template string tokens.\r\n\r\n  var INVALID_TEMPLATE_ESCAPE_ERROR = {};\r\n\r\n  pp$8.tryReadTemplateToken = function() {\r\n    this.inTemplateElement = true;\r\n    try {\r\n      this.readTmplToken();\r\n    } catch (err) {\r\n      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\r\n        this.readInvalidTemplateToken();\r\n      } else {\r\n        throw err\r\n      }\r\n    }\r\n\r\n    this.inTemplateElement = false;\r\n  };\r\n\r\n  pp$8.invalidStringToken = function(position, message) {\r\n    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\r\n      throw INVALID_TEMPLATE_ESCAPE_ERROR\r\n    } else {\r\n      this.raise(position, message);\r\n    }\r\n  };\r\n\r\n  pp$8.readTmplToken = function() {\r\n    var this$1 = this;\r\n\r\n    var out = \"\", chunkStart = this.pos;\r\n    for (;;) {\r\n      if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated template\"); }\r\n      var ch = this$1.input.charCodeAt(this$1.pos);\r\n      if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\r\n        if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {\r\n          if (ch === 36) {\r\n            this$1.pos += 2;\r\n            return this$1.finishToken(types.dollarBraceL)\r\n          } else {\r\n            ++this$1.pos;\r\n            return this$1.finishToken(types.backQuote)\r\n          }\r\n        }\r\n        out += this$1.input.slice(chunkStart, this$1.pos);\r\n        return this$1.finishToken(types.template, out)\r\n      }\r\n      if (ch === 92) { // '\\'\r\n        out += this$1.input.slice(chunkStart, this$1.pos);\r\n        out += this$1.readEscapedChar(true);\r\n        chunkStart = this$1.pos;\r\n      } else if (isNewLine(ch)) {\r\n        out += this$1.input.slice(chunkStart, this$1.pos);\r\n        ++this$1.pos;\r\n        switch (ch) {\r\n        case 13:\r\n          if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }\r\n        case 10:\r\n          out += \"\\n\";\r\n          break\r\n        default:\r\n          out += String.fromCharCode(ch);\r\n          break\r\n        }\r\n        if (this$1.options.locations) {\r\n          ++this$1.curLine;\r\n          this$1.lineStart = this$1.pos;\r\n        }\r\n        chunkStart = this$1.pos;\r\n      } else {\r\n        ++this$1.pos;\r\n      }\r\n    }\r\n  };\r\n\r\n  // Reads a template token to search for the end, without validating any escape sequences\r\n  pp$8.readInvalidTemplateToken = function() {\r\n    var this$1 = this;\r\n\r\n    for (; this.pos < this.input.length; this.pos++) {\r\n      switch (this$1.input[this$1.pos]) {\r\n      case \"\\\\\":\r\n        ++this$1.pos;\r\n        break\r\n\r\n      case \"$\":\r\n        if (this$1.input[this$1.pos + 1] !== \"{\") {\r\n          break\r\n        }\r\n      // falls through\r\n\r\n      case \"`\":\r\n        return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))\r\n\r\n      // no default\r\n      }\r\n    }\r\n    this.raise(this.start, \"Unterminated template\");\r\n  };\r\n\r\n  // Used to read escaped characters\r\n\r\n  pp$8.readEscapedChar = function(inTemplate) {\r\n    var ch = this.input.charCodeAt(++this.pos);\r\n    ++this.pos;\r\n    switch (ch) {\r\n    case 110: return \"\\n\" // 'n' -> '\\n'\r\n    case 114: return \"\\r\" // 'r' -> '\\r'\r\n    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\r\n    case 117: return codePointToString(this.readCodePoint()) // 'u'\r\n    case 116: return \"\\t\" // 't' -> '\\t'\r\n    case 98: return \"\\b\" // 'b' -> '\\b'\r\n    case 118: return \"\\u000b\" // 'v' -> '\\u000b'\r\n    case 102: return \"\\f\" // 'f' -> '\\f'\r\n    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\r\n    case 10: // ' \\n'\r\n      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\r\n      return \"\"\r\n    default:\r\n      if (ch >= 48 && ch <= 55) {\r\n        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\r\n        var octal = parseInt(octalStr, 8);\r\n        if (octal > 255) {\r\n          octalStr = octalStr.slice(0, -1);\r\n          octal = parseInt(octalStr, 8);\r\n        }\r\n        this.pos += octalStr.length - 1;\r\n        ch = this.input.charCodeAt(this.pos);\r\n        if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\r\n          this.invalidStringToken(\r\n            this.pos - 1 - octalStr.length,\r\n            inTemplate\r\n              ? \"Octal literal in template string\"\r\n              : \"Octal literal in strict mode\"\r\n          );\r\n        }\r\n        return String.fromCharCode(octal)\r\n      }\r\n      return String.fromCharCode(ch)\r\n    }\r\n  };\r\n\r\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\r\n\r\n  pp$8.readHexChar = function(len) {\r\n    var codePos = this.pos;\r\n    var n = this.readInt(16, len);\r\n    if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\r\n    return n\r\n  };\r\n\r\n  // Read an identifier, and return it as a string. Sets `this.containsEsc`\r\n  // to whether the word contained a '\\u' escape.\r\n  //\r\n  // Incrementally adds only escaped chars, adding other chunks as-is\r\n  // as a micro-optimization.\r\n\r\n  pp$8.readWord1 = function() {\r\n    var this$1 = this;\r\n\r\n    this.containsEsc = false;\r\n    var word = \"\", first = true, chunkStart = this.pos;\r\n    var astral = this.options.ecmaVersion >= 6;\r\n    while (this.pos < this.input.length) {\r\n      var ch = this$1.fullCharCodeAtPos();\r\n      if (isIdentifierChar(ch, astral)) {\r\n        this$1.pos += ch <= 0xffff ? 1 : 2;\r\n      } else if (ch === 92) { // \"\\\"\r\n        this$1.containsEsc = true;\r\n        word += this$1.input.slice(chunkStart, this$1.pos);\r\n        var escStart = this$1.pos;\r\n        if (this$1.input.charCodeAt(++this$1.pos) !== 117) // \"u\"\r\n          { this$1.invalidStringToken(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\r\n        ++this$1.pos;\r\n        var esc = this$1.readCodePoint();\r\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\r\n          { this$1.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\r\n        word += codePointToString(esc);\r\n        chunkStart = this$1.pos;\r\n      } else {\r\n        break\r\n      }\r\n      first = false;\r\n    }\r\n    return word + this.input.slice(chunkStart, this.pos)\r\n  };\r\n\r\n  // Read an identifier or keyword token. Will check for reserved\r\n  // words when necessary.\r\n\r\n  pp$8.readWord = function() {\r\n    var word = this.readWord1();\r\n    var type = types.name;\r\n    if (this.keywords.test(word)) {\r\n      if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\r\n      type = keywords$1[word];\r\n    }\r\n    return this.finishToken(type, word)\r\n  };\r\n\r\n  // Acorn is a tiny, fast JavaScript parser written in JavaScript.\r\n  //\r\n  // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\r\n  // various contributors and released under an MIT license.\r\n  //\r\n  // Git repositories for Acorn are available at\r\n  //\r\n  //     http://marijnhaverbeke.nl/git/acorn\r\n  //     https://github.com/acornjs/acorn.git\r\n  //\r\n  // Please use the [github bug tracker][ghbt] to report issues.\r\n  //\r\n  // [ghbt]: https://github.com/acornjs/acorn/issues\r\n  //\r\n  // This file defines the main parser interface. The library also comes\r\n  // with a [error-tolerant parser][dammit] and an\r\n  // [abstract syntax tree walker][walk], defined in other files.\r\n  //\r\n  // [dammit]: acorn_loose.js\r\n  // [walk]: util/walk.js\r\n\r\n  var version = \"5.7.2\";\r\n\r\n  // The main exported interface (under `self.acorn` when in the\r\n  // browser) is a `parse` function that takes a code string and\r\n  // returns an abstract syntax tree as specified by [Mozilla parser\r\n  // API][api].\r\n  //\r\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\r\n\r\n  function parse(input, options) {\r\n    return new Parser(options, input).parse()\r\n  }\r\n\r\n  // This function tries to parse a single expression at a given\r\n  // offset in a string. Useful for parsing mixed-language formats\r\n  // that embed JavaScript expressions.\r\n\r\n  function parseExpressionAt(input, pos, options) {\r\n    var p = new Parser(options, input, pos);\r\n    p.nextToken();\r\n    return p.parseExpression()\r\n  }\r\n\r\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\r\n  // The `tokenizer` export provides an interface to the tokenizer.\r\n\r\n  function tokenizer(input, options) {\r\n    return new Parser(options, input)\r\n  }\r\n\r\n  // This is a terrible kludge to support the existing, pre-ES6\r\n  // interface where the loose parser module retroactively adds exports\r\n  // to this module.\r\n   // eslint-disable-line camelcase\r\n  function addLooseExports(parse, Parser$$1, plugins$$1) {\r\n    exports.parse_dammit = parse; // eslint-disable-line camelcase\r\n    exports.LooseParser = Parser$$1;\r\n    exports.pluginsLoose = plugins$$1;\r\n  }\r\n\r\n  exports.version = version;\r\n  exports.parse = parse;\r\n  exports.parseExpressionAt = parseExpressionAt;\r\n  exports.tokenizer = tokenizer;\r\n  exports.addLooseExports = addLooseExports;\r\n  exports.Parser = Parser;\r\n  exports.plugins = plugins;\r\n  exports.defaultOptions = defaultOptions;\r\n  exports.Position = Position;\r\n  exports.SourceLocation = SourceLocation;\r\n  exports.getLineInfo = getLineInfo;\r\n  exports.Node = Node;\r\n  exports.TokenType = TokenType;\r\n  exports.tokTypes = types;\r\n  exports.keywordTypes = keywords$1;\r\n  exports.TokContext = TokContext;\r\n  exports.tokContexts = types$1;\r\n  exports.isIdentifierChar = isIdentifierChar;\r\n  exports.isIdentifierStart = isIdentifierStart;\r\n  exports.Token = Token;\r\n  exports.isNewLine = isNewLine;\r\n  exports.lineBreak = lineBreak;\r\n  exports.lineBreakG = lineBreakG;\r\n  exports.nonASCIIwhitespace = nonASCIIwhitespace;\r\n\r\n  Object.defineProperty(exports, '__esModule', { value: true });\r\n\r\n  return exports;\r\n});\r\n"]}