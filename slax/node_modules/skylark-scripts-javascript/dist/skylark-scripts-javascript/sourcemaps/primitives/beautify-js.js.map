{"version":3,"sources":["primitives/beautify-js.js"],"names":["define","exports","nonASCIIidentifierStartChars","nonASCIIidentifierStart","nonASCIIidentifier","acorn","in_array","what","arr","i","length","trim","s","replace","RegExp","newline","isIdentifierStart","code","test","String","fromCharCode","isIdentifierChar","MODE","BlockStatement","Statement","ObjectLiteral","ArrayLiteral","ForInitializer","Conditional","Expression","Token","type","text","newlines","whitespace_before","mode","parent","this","comments_before","wanted_newline","js_beautify","js_source_text","options","output","token_pos","Tokenizer","current_token","last_type","last_last_text","indent_string","flags","previous_flags","flag_store","prefix","handlers","opt","tokens","baseIndentString","create_flags","flags_base","next_indent_level","indentation_level","just_added_newline","line_indent_level","next_flags","last_text","last_word","declaration_statement","declaration_assignment","multiline_frame","if_block","else_block","do_block","do_while","in_case_statement","in_case","case_body","start_line_index","get_line_number","ternary_depth","TK_START_EXPR","start_of_statement","next_mode","line_starters","space_before_token","set_mode","print_token","indent","space_in_paren","is_array","keep_array_indentation","print_newline","allow_wrap_or_preserved_newline","space_after_anon_function","space_before_conditional","start_of_object_property","TK_END_EXPR","restore_mode","space_in_empty_paren","remove_redundant_indentation","TK_START_BLOCK","next_token","get_token","second_token","empty_anonymous_function","brace_style","is_special_word","TK_END_BLOCK","empty_braces","TK_WORD","handle_word","TK_RESERVED","TK_SEMICOLON","TK_STRING","TK_EQUALS","TK_OPERATOR","space_before","space_after","is_expression","TK_COMMA","TK_BLOCK_COMMENT","j","lines","out","idx","indexOf","push","substring","split_newlines","javadoc","starless","lastIndent","lastIndentLength","c","line","charAt","all_lines_start_with","slice","len","each_line_matches_indent","add_token","TK_INLINE_COMMENT","TK_COMMENT","TK_DOT","break_chained_methods","TK_UNKNOWN","TK_EOF","undefined","braces_on_own_line","indent_size","parseInt","indent_char","preserve_newlines","max_preserve_newlines","jslint_happy","unescape_strings","wrap_line_length","e4x","end_with_newline","indent_with_tabs","preindent_index","handle_token","local_token","keep_whitespace","force_linewrap","proposed_line_length","current_line","get_character_count","force_newline","preserve_statement_flags","add_new_line","printable_token","set_indent","pop","word","offset","index","just_added_blankline","last","indent_cache","baseIndentLength","indent_length","_character_count","_indent_count","_items","_empty","level","is_empty","input","remove_indent","toString","result","join","get_code","sweet_code","add_space_before_token","frame","output_length","eat_newlines","beautify","opts","whitespace","split","digit","punct","n_newlines","whitespace_before_token","in_html_comment","parser_pos","input_length","reserved_words","concat","tokenize_next","resulting_string","last_token","whitespace_on_this_line","allow_decimal","allow_e","local_digit","charCodeAt","comment","inline_comment","match","sep","esc","has_char_escapes","in_char_class","xmlRegExp","xmlStr","exec","rootTag","depth","isEndTag","tagName","isSingletonTag","xmlLength","pos","s_hex","escaped","substr","unescape_string","sharp","tokenize","next","token_values","open","open_stack","comments"],"mappings":"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","file":"../../primitives/beautify-js.js","sourcesContent":["/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */\r\n/*\r\n\r\n  The MIT License (MIT)\r\n\r\n  Copyright (c) 2007-2013 Einar Lielmanis and contributors.\r\n\r\n  Permission is hereby granted, free of charge, to any person\r\n  obtaining a copy of this software and associated documentation files\r\n  (the \"Software\"), to deal in the Software without restriction,\r\n  including without limitation the rights to use, copy, modify, merge,\r\n  publish, distribute, sublicense, and/or sell copies of the Software,\r\n  and to permit persons to whom the Software is furnished to do so,\r\n  subject to the following conditions:\r\n\r\n  The above copyright notice and this permission notice shall be\r\n  included in all copies or substantial portions of the Software.\r\n\r\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\r\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\r\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n  SOFTWARE.\r\n\r\n JS Beautifier\r\n---------------\r\n\r\n\r\n  Written by Einar Lielmanis, <einar@jsbeautifier.org>\r\n      http://jsbeautifier.org/\r\n\r\n  Originally converted to javascript by Vital, <vital76@gmail.com>\r\n  \"End braces on own line\" added by Chris J. Shull, <chrisjshull@gmail.com>\r\n  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>\r\n\r\n\r\n  Usage:\r\n    js_beautify(js_source_text);\r\n    js_beautify(js_source_text, options);\r\n\r\n  The options are:\r\n    indent_size (default 4)          - indentation size,\r\n    indent_char (default space)      - character to indent with,\r\n    preserve_newlines (default true) - whether existing line breaks should be preserved,\r\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,\r\n\r\n    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.\r\n\r\n            jslint_happy        !jslint_happy\r\n            ---------------------------------\r\n            function ()         function()\r\n\r\n            switch () {         switch() {\r\n            case 1:               case 1:\r\n              break;                break;\r\n            }                   }\r\n\r\n    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, \"function()\" vs \"function ()\",\r\n          NOTE: This option is overriden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)\r\n\r\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\"\r\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\r\n\r\n    space_before_conditional (default true) - should the space before conditional statement be added, \"if(true)\" vs \"if (true)\",\r\n\r\n    unescape_strings (default false) - should printable characters in strings encoded in \\xNN notation be unescaped, \"example\" vs \"\\x65\\x78\\x61\\x6d\\x70\\x6c\\x65\"\r\n\r\n    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.\r\n          NOTE: This is not a hard limit. Lines will continue until a point where a newline would\r\n                be preserved if it were present.\r\n\r\n    end_with_newline (default false)  - end output with a newline\r\n\r\n\r\n    e.g\r\n\r\n    js_beautify(js_source_text, {\r\n      'indent_size': 1,\r\n      'indent_char': '\\t'\r\n    });\r\n\r\n*/\r\n\r\ndefine([],function() {\r\n\r\n    var acorn = {};\r\n    (function (exports) {\r\n      // This section of code is taken from acorn.\r\n      //\r\n      // Acorn was written by Marijn Haverbeke and released under an MIT\r\n      // license. The Unicode regexps (for identifiers and whitespace) were\r\n      // taken from [Esprima](http://esprima.org) by Ariya Hidayat.\r\n      //\r\n      // Git repositories for Acorn are available at\r\n      //\r\n      //     http://marijnhaverbeke.nl/git/acorn\r\n      //     https://github.com/marijnh/acorn.git\r\n\r\n      // ## Character categories\r\n\r\n      // Big ugly regular expressions that match characters in the\r\n      // whitespace, identifier, and identifier-start categories. These\r\n      // are only applied when a character is found to actually have a\r\n      // code point above 128.\r\n\r\n      var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\r\n      var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\r\n      var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\r\n      var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\r\n      var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\r\n\r\n      // Whether a single character denotes a newline.\r\n\r\n      var newline = exports.newline = /[\\n\\r\\u2028\\u2029]/;\r\n\r\n      // Matches a whole line break (where CRLF is considered a single\r\n      // line break). Used to count lines.\r\n\r\n      var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\r\n\r\n      // Test whether a given character code starts an identifier.\r\n\r\n      var isIdentifierStart = exports.isIdentifierStart = function(code) {\r\n        if (code < 65) return code === 36;\r\n        if (code < 91) return true;\r\n        if (code < 97) return code === 95;\r\n        if (code < 123)return true;\r\n        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\r\n      };\r\n\r\n      // Test whether a given character is part of an identifier.\r\n\r\n      var isIdentifierChar = exports.isIdentifierChar = function(code) {\r\n        if (code < 48) return code === 36;\r\n        if (code < 58) return true;\r\n        if (code < 65) return false;\r\n        if (code < 91) return true;\r\n        if (code < 97) return code === 95;\r\n        if (code < 123)return true;\r\n        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\r\n      };\r\n    })(acorn);\r\n\r\n    function in_array(what, arr) {\r\n        for (var i = 0; i < arr.length; i += 1) {\r\n            if (arr[i] === what) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function trim(s) {\r\n        return s.replace(/^\\s+|\\s+$/g, '');\r\n    }\r\n\r\n    function js_beautify(js_source_text, options) {\r\n        \"use strict\";\r\n        var beautifier = new Beautifier(js_source_text, options);\r\n        return beautifier.beautify();\r\n    }\r\n\r\n    var MODE = {\r\n            BlockStatement: 'BlockStatement', // 'BLOCK'\r\n            Statement: 'Statement', // 'STATEMENT'\r\n            ObjectLiteral: 'ObjectLiteral', // 'OBJECT',\r\n            ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',\r\n            ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',\r\n            Conditional: 'Conditional', //'(COND-EXPRESSION)',\r\n            Expression: 'Expression' //'(EXPRESSION)'\r\n        };\r\n\r\n    function Beautifier(js_source_text, options) {\r\n        \"use strict\";\r\n        var output\r\n        var tokens = [], token_pos;\r\n        var Tokenizer;\r\n        var current_token;\r\n        var last_type, last_last_text, indent_string;\r\n        var flags, previous_flags, flag_store;\r\n        var prefix;\r\n\r\n        var handlers, opt;\r\n        var baseIndentString = '';\r\n\r\n        handlers = {\r\n            'TK_START_EXPR': handle_start_expr,\r\n            'TK_END_EXPR': handle_end_expr,\r\n            'TK_START_BLOCK': handle_start_block,\r\n            'TK_END_BLOCK': handle_end_block,\r\n            'TK_WORD': handle_word,\r\n            'TK_RESERVED': handle_word,\r\n            'TK_SEMICOLON': handle_semicolon,\r\n            'TK_STRING': handle_string,\r\n            'TK_EQUALS': handle_equals,\r\n            'TK_OPERATOR': handle_operator,\r\n            'TK_COMMA': handle_comma,\r\n            'TK_BLOCK_COMMENT': handle_block_comment,\r\n            'TK_INLINE_COMMENT': handle_inline_comment,\r\n            'TK_COMMENT': handle_comment,\r\n            'TK_DOT': handle_dot,\r\n            'TK_UNKNOWN': handle_unknown,\r\n            'TK_EOF': handle_eof\r\n        };\r\n\r\n        function create_flags(flags_base, mode) {\r\n            var next_indent_level = 0;\r\n            if (flags_base) {\r\n                next_indent_level = flags_base.indentation_level;\r\n                if (!output.just_added_newline() &&\r\n                    flags_base.line_indent_level > next_indent_level) {\r\n                    next_indent_level = flags_base.line_indent_level;\r\n                }\r\n            }\r\n\r\n            var next_flags = {\r\n                mode: mode,\r\n                parent: flags_base,\r\n                last_text: flags_base ? flags_base.last_text : '', // last token text\r\n                last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed\r\n                declaration_statement: false,\r\n                declaration_assignment: false,\r\n                multiline_frame: false,\r\n                if_block: false,\r\n                else_block: false,\r\n                do_block: false,\r\n                do_while: false,\r\n                in_case_statement: false, // switch(..){ INSIDE HERE }\r\n                in_case: false, // we're on the exact line with \"case 0:\"\r\n                case_body: false, // the indented case-action block\r\n                indentation_level: next_indent_level,\r\n                line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,\r\n                start_line_index: output.get_line_number(),\r\n                ternary_depth: 0\r\n            };\r\n            return next_flags;\r\n        }\r\n\r\n        // Some interpreters have unexpected results with foo = baz || bar;\r\n        options = options ? options : {};\r\n        opt = {};\r\n\r\n        // compatibility\r\n        if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option\r\n            opt.brace_style = options.braces_on_own_line ? \"expand\" : \"collapse\";\r\n        }\r\n        opt.brace_style = options.brace_style ? options.brace_style : (opt.brace_style ? opt.brace_style : \"collapse\");\r\n\r\n        // graceful handling of deprecated option\r\n        if (opt.brace_style === \"expand-strict\") {\r\n            opt.brace_style = \"expand\";\r\n        }\r\n\r\n\r\n        opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;\r\n        opt.indent_char = options.indent_char ? options.indent_char : ' ';\r\n        opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;\r\n        opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;\r\n        opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);\r\n        opt.space_in_paren = (options.space_in_paren === undefined) ? false : options.space_in_paren;\r\n        opt.space_in_empty_paren = (options.space_in_empty_paren === undefined) ? false : options.space_in_empty_paren;\r\n        opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;\r\n        opt.space_after_anon_function = (options.space_after_anon_function === undefined) ? false : options.space_after_anon_function;\r\n        opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation;\r\n        opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional;\r\n        opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;\r\n        opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);\r\n        opt.e4x = (options.e4x === undefined) ? false : options.e4x;\r\n        opt.end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;\r\n\r\n\r\n        // force opt.space_after_anon_function to true if opt.jslint_happy\r\n        if(opt.jslint_happy) {\r\n            opt.space_after_anon_function = true;\r\n        }\r\n\r\n        if(options.indent_with_tabs){\r\n            opt.indent_char = '\\t';\r\n            opt.indent_size = 1;\r\n        }\r\n\r\n        //----------------------------------\r\n        indent_string = '';\r\n        while (opt.indent_size > 0) {\r\n            indent_string += opt.indent_char;\r\n            opt.indent_size -= 1;\r\n        }\r\n\r\n        var preindent_index = 0;\r\n        if(js_source_text && js_source_text.length) {\r\n            while ( (js_source_text.charAt(preindent_index) === ' ' ||\r\n                    js_source_text.charAt(preindent_index) === '\\t')) {\r\n                baseIndentString += js_source_text.charAt(preindent_index);\r\n                preindent_index += 1;\r\n            }\r\n            js_source_text = js_source_text.substring(preindent_index);\r\n        }\r\n\r\n        last_type = 'TK_START_BLOCK'; // last token type\r\n        last_last_text = ''; // pre-last token text\r\n        output = new Output(indent_string, baseIndentString);\r\n\r\n\r\n        // Stack of parsing/formatting states, including MODE.\r\n        // We tokenize, parse, and output in an almost purely a forward-only stream of token input\r\n        // and formatted output.  This makes the beautifier less accurate than full parsers\r\n        // but also far more tolerant of syntax errors.\r\n        //\r\n        // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type\r\n        // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later\r\n        // encounter a \":\", we'll switch to to MODE.ObjectLiteral.  If we then see a \";\",\r\n        // most full parsers would die, but the beautifier gracefully falls back to\r\n        // MODE.BlockStatement and continues on.\r\n        flag_store = [];\r\n        set_mode(MODE.BlockStatement);\r\n\r\n        this.beautify = function() {\r\n\r\n            /*jshint onevar:true */\r\n            var local_token, sweet_code;\r\n            Tokenizer = new tokenizer(js_source_text, opt, indent_string);\r\n            tokens = Tokenizer.tokenize();\r\n            token_pos = 0;\r\n\r\n            while (local_token = get_token()) {\r\n                for(var i = 0; i < local_token.comments_before.length; i++) {\r\n                    // The cleanest handling of inline comments is to treat them as though they aren't there.\r\n                    // Just continue formatting and the behavior should be logical.\r\n                    // Also ignore unknown tokens.  Again, this should result in better behavior.\r\n                    handle_token(local_token.comments_before[i]);\r\n                }\r\n                handle_token(local_token);\r\n\r\n                last_last_text = flags.last_text;\r\n                last_type = local_token.type;\r\n                flags.last_text = local_token.text;\r\n\r\n                token_pos += 1;\r\n            }\r\n\r\n            sweet_code = output.get_code();\r\n            if (opt.end_with_newline) {\r\n                sweet_code += '\\n';\r\n            }\r\n\r\n            return sweet_code;\r\n        };\r\n\r\n        function handle_token(local_token) {\r\n            var newlines = local_token.newlines;\r\n            var keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);\r\n\r\n            if (keep_whitespace) {\r\n                for (i = 0; i < newlines; i += 1) {\r\n                    print_newline(i > 0);\r\n                }\r\n            } else {\r\n                if (opt.max_preserve_newlines && newlines > opt.max_preserve_newlines) {\r\n                    newlines = opt.max_preserve_newlines;\r\n                }\r\n\r\n                if (opt.preserve_newlines) {\r\n                    if (local_token.newlines > 1) {\r\n                        print_newline();\r\n                        for (var i = 1; i < newlines; i += 1) {\r\n                            print_newline(true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            current_token = local_token;\r\n            handlers[current_token.type]();\r\n        }\r\n\r\n        // we could use just string.split, but\r\n        // IE doesn't like returning empty strings\r\n\r\n        function split_newlines(s) {\r\n            //return s.split(/\\x0d\\x0a|\\x0a/);\r\n\r\n            s = s.replace(/\\x0d/g, '');\r\n            var out = [],\r\n                idx = s.indexOf(\"\\n\");\r\n            while (idx !== -1) {\r\n                out.push(s.substring(0, idx));\r\n                s = s.substring(idx + 1);\r\n                idx = s.indexOf(\"\\n\");\r\n            }\r\n            if (s.length) {\r\n                out.push(s);\r\n            }\r\n            return out;\r\n        }\r\n\r\n        function allow_wrap_or_preserved_newline(force_linewrap) {\r\n            force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;\r\n\r\n            // Never wrap the first token on a line\r\n            if (output.just_added_newline()) {\r\n                return\r\n            }\r\n\r\n            if ((opt.preserve_newlines && current_token.wanted_newline) || force_linewrap) {\r\n                print_newline(false, true);\r\n            } else if (opt.wrap_line_length) {\r\n                var proposed_line_length = output.current_line.get_character_count() + current_token.text.length +\r\n                    (output.space_before_token ? 1 : 0);\r\n                if (proposed_line_length >= opt.wrap_line_length) {\r\n                    print_newline(false, true);\r\n                }\r\n            }\r\n        }\r\n\r\n        function print_newline(force_newline, preserve_statement_flags) {\r\n            if (!preserve_statement_flags) {\r\n                if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {\r\n                    while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {\r\n                        restore_mode();\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (output.add_new_line(force_newline)) {\r\n                flags.multiline_frame = true;\r\n            }\r\n        }\r\n\r\n        function print_token_line_indentation() {\r\n            if (output.just_added_newline()) {\r\n                if (opt.keep_array_indentation && is_array(flags.mode) && current_token.wanted_newline) {\r\n                    output.current_line.push(current_token.whitespace_before);\r\n                    output.space_before_token = false;\r\n                } else if (output.set_indent(flags.indentation_level)) {\r\n                    flags.line_indent_level = flags.indentation_level;\r\n                }\r\n            }\r\n        }\r\n\r\n        function print_token(printable_token) {\r\n            printable_token = printable_token || current_token.text;\r\n            print_token_line_indentation();\r\n            output.add_token(printable_token);\r\n        }\r\n\r\n        function indent() {\r\n            flags.indentation_level += 1;\r\n        }\r\n\r\n        function deindent() {\r\n            if (flags.indentation_level > 0 &&\r\n                ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level))\r\n                flags.indentation_level -= 1;\r\n        }\r\n\r\n        function set_mode(mode) {\r\n            if (flags) {\r\n                flag_store.push(flags);\r\n                previous_flags = flags;\r\n            } else {\r\n                previous_flags = create_flags(null, mode);\r\n            }\r\n\r\n            flags = create_flags(previous_flags, mode);\r\n        }\r\n\r\n        function is_array(mode) {\r\n            return mode === MODE.ArrayLiteral;\r\n        }\r\n\r\n        function is_expression(mode) {\r\n            return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);\r\n        }\r\n\r\n        function restore_mode() {\r\n            if (flag_store.length > 0) {\r\n                previous_flags = flags;\r\n                flags = flag_store.pop();\r\n                if (previous_flags.mode === MODE.Statement) {\r\n                    output.remove_redundant_indentation(previous_flags);\r\n                }\r\n            }\r\n        }\r\n\r\n        function start_of_object_property() {\r\n            return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && (\r\n                (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set'])));\r\n        }\r\n\r\n        function start_of_statement() {\r\n            if (\r\n                    (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') ||\r\n                    (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||\r\n                    (last_type === 'TK_RESERVED' && flags.last_text === 'return' && !current_token.wanted_newline) ||\r\n                    (last_type === 'TK_RESERVED' && flags.last_text === 'else' && !(current_token.type === 'TK_RESERVED' && current_token.text === 'if')) ||\r\n                    (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||\r\n                    (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement\r\n                        && !flags.in_case\r\n                        && !(current_token.text === '--' || current_token.text === '++')\r\n                        && current_token.type !== 'TK_WORD' && current_token.type !== 'TK_RESERVED') ||\r\n                    (flags.mode === MODE.ObjectLiteral && (\r\n                        (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set']))))\r\n                ) {\r\n\r\n                set_mode(MODE.Statement);\r\n                indent();\r\n\r\n                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') {\r\n                    flags.declaration_statement = true;\r\n                }\r\n\r\n                // Issue #276:\r\n                // If starting a new statement with [if, for, while, do], push to a new line.\r\n                // if (a) if (b) if(c) d(); else e(); else f();\r\n                if (!start_of_object_property()) {\r\n                    allow_wrap_or_preserved_newline(\r\n                        current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['do', 'for', 'if', 'while']));\r\n                }\r\n\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function all_lines_start_with(lines, c) {\r\n            for (var i = 0; i < lines.length; i++) {\r\n                var line = trim(lines[i]);\r\n                if (line.charAt(0) !== c) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function each_line_matches_indent(lines, indent) {\r\n            var i = 0,\r\n                len = lines.length,\r\n                line;\r\n            for (; i < len; i++) {\r\n                line = lines[i];\r\n                // allow empty lines to pass through\r\n                if (line && line.indexOf(indent) !== 0) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function is_special_word(word) {\r\n            return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);\r\n        }\r\n\r\n        function get_token(offset) {\r\n            var index = token_pos + (offset || 0);\r\n            return (index < 0 || index >= tokens.length) ? null : tokens[index];\r\n        }\r\n\r\n        function handle_start_expr() {\r\n            if (start_of_statement()) {\r\n                // The conditional starts the statement if appropriate.\r\n            }\r\n\r\n            var next_mode = MODE.Expression;\r\n            if (current_token.text === '[') {\r\n\r\n                if (last_type === 'TK_WORD' || flags.last_text === ')') {\r\n                    // this is array index specifier, break immediately\r\n                    // a[x], fn()[x]\r\n                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, Tokenizer.line_starters)) {\r\n                        output.space_before_token = true;\r\n                    }\r\n                    set_mode(next_mode);\r\n                    print_token();\r\n                    indent();\r\n                    if (opt.space_in_paren) {\r\n                        output.space_before_token = true;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                next_mode = MODE.ArrayLiteral;\r\n                if (is_array(flags.mode)) {\r\n                    if (flags.last_text === '[' ||\r\n                        (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {\r\n                        // ], [ goes to new line\r\n                        // }, [ goes to new line\r\n                        if (!opt.keep_array_indentation) {\r\n                            print_newline();\r\n                        }\r\n                    }\r\n                }\r\n\r\n            } else {\r\n                if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {\r\n                    next_mode = MODE.ForInitializer;\r\n                } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {\r\n                    next_mode = MODE.Conditional;\r\n                } else {\r\n                    // next_mode = MODE.Expression;\r\n                }\r\n            }\r\n\r\n            if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {\r\n                print_newline();\r\n            } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {\r\n                // TODO: Consider whether forcing this is required.  Review failing tests when removed.\r\n                allow_wrap_or_preserved_newline(current_token.wanted_newline);\r\n                // do nothing on (( and )( and ][ and ]( and .(\r\n            } else if (!(last_type === 'TK_RESERVED' && current_token.text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {\r\n                output.space_before_token = true;\r\n            } else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||\r\n                (flags.last_text === '*' && last_last_text === 'function')) {\r\n                // function() vs function ()\r\n                if (opt.space_after_anon_function) {\r\n                    output.space_before_token = true;\r\n                }\r\n            } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === 'catch')) {\r\n                if (opt.space_before_conditional) {\r\n                    output.space_before_token = true;\r\n                }\r\n            }\r\n\r\n            // Support of this kind of newline preservation.\r\n            // a = (b &&\r\n            //     (c || d));\r\n            if (current_token.text === '(') {\r\n                if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {\r\n                    if (!start_of_object_property()) {\r\n                        allow_wrap_or_preserved_newline();\r\n                    }\r\n                }\r\n            }\r\n\r\n            set_mode(next_mode);\r\n            print_token();\r\n            if (opt.space_in_paren) {\r\n                output.space_before_token = true;\r\n            }\r\n\r\n            // In all cases, if we newline while inside an expression it should be indented.\r\n            indent();\r\n        }\r\n\r\n        function handle_end_expr() {\r\n            // statements inside expressions are not valid syntax, but...\r\n            // statements must all be closed when their container closes\r\n            while (flags.mode === MODE.Statement) {\r\n                restore_mode();\r\n            }\r\n\r\n            if (flags.multiline_frame) {\r\n                allow_wrap_or_preserved_newline(current_token.text === ']' && is_array(flags.mode) && !opt.keep_array_indentation);\r\n            }\r\n\r\n            if (opt.space_in_paren) {\r\n                if (last_type === 'TK_START_EXPR' && ! opt.space_in_empty_paren) {\r\n                    // () [] no inner space in empty parens like these, ever, ref #320\r\n                    output.trim();\r\n                    output.space_before_token = false;\r\n                } else {\r\n                    output.space_before_token = true;\r\n                }\r\n            }\r\n            if (current_token.text === ']' && opt.keep_array_indentation) {\r\n                print_token();\r\n                restore_mode();\r\n            } else {\r\n                restore_mode();\r\n                print_token();\r\n            }\r\n            output.remove_redundant_indentation(previous_flags);\r\n\r\n            // do {} while () // no statement required after\r\n            if (flags.do_while && previous_flags.mode === MODE.Conditional) {\r\n                previous_flags.mode = MODE.Expression;\r\n                flags.do_block = false;\r\n                flags.do_while = false;\r\n\r\n            }\r\n        }\r\n\r\n        function handle_start_block() {\r\n            // Check if this is should be treated as a ObjectLiteral\r\n            var next_token = get_token(1)\r\n            var second_token = get_token(2)\r\n            if (second_token && (\r\n                    (second_token.text === ':' && in_array(next_token.type, ['TK_STRING', 'TK_WORD', 'TK_RESERVED']))\r\n                    || (in_array(next_token.text, ['get', 'set']) && in_array(second_token.type, ['TK_WORD', 'TK_RESERVED']))\r\n                )) {\r\n                // We don't support TypeScript,but we didn't break it for a very long time.\r\n                // We'll try to keep not breaking it.\r\n                if (!in_array(last_last_text, ['class','interface'])) {\r\n                    set_mode(MODE.ObjectLiteral);\r\n                } else {\r\n                    set_mode(MODE.BlockStatement);\r\n                }\r\n            } else {\r\n                set_mode(MODE.BlockStatement);\r\n            }\r\n\r\n            var empty_braces = !next_token.comments_before.length &&  next_token.text === '}';\r\n            var empty_anonymous_function = empty_braces && flags.last_word === 'function' &&\r\n                last_type === 'TK_END_EXPR';\r\n\r\n            if (opt.brace_style === \"expand\" ||\r\n                (opt.brace_style === \"none\" && current_token.wanted_newline)) {\r\n                if (last_type !== 'TK_OPERATOR' &&\r\n                    (empty_anonymous_function ||\r\n                        last_type === 'TK_EQUALS' ||\r\n                        (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {\r\n                    output.space_before_token = true;\r\n                } else {\r\n                    print_newline(false, true);\r\n                }\r\n            } else { // collapse\r\n                if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {\r\n                    if (last_type === 'TK_START_BLOCK') {\r\n                        print_newline();\r\n                    } else {\r\n                        output.space_before_token = true;\r\n                    }\r\n                } else {\r\n                    // if TK_OPERATOR or TK_START_EXPR\r\n                    if (is_array(previous_flags.mode) && flags.last_text === ',') {\r\n                        if (last_last_text === '}') {\r\n                            // }, { in array context\r\n                            output.space_before_token = true;\r\n                        } else {\r\n                            print_newline(); // [a, b, c, {\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            print_token();\r\n            indent();\r\n        }\r\n\r\n        function handle_end_block() {\r\n            // statements must all be closed when their container closes\r\n            while (flags.mode === MODE.Statement) {\r\n                restore_mode();\r\n            }\r\n            var empty_braces = last_type === 'TK_START_BLOCK';\r\n\r\n            if (opt.brace_style === \"expand\") {\r\n                if (!empty_braces) {\r\n                    print_newline();\r\n                }\r\n            } else {\r\n                // skip {}\r\n                if (!empty_braces) {\r\n                    if (is_array(flags.mode) && opt.keep_array_indentation) {\r\n                        // we REALLY need a newline here, but newliner would skip that\r\n                        opt.keep_array_indentation = false;\r\n                        print_newline();\r\n                        opt.keep_array_indentation = true;\r\n\r\n                    } else {\r\n                        print_newline();\r\n                    }\r\n                }\r\n            }\r\n            restore_mode();\r\n            print_token();\r\n        }\r\n\r\n        function handle_word() {\r\n            if (current_token.type === 'TK_RESERVED' && flags.mode !== MODE.ObjectLiteral &&\r\n                in_array(current_token.text, ['set', 'get'])) {\r\n                current_token.type = 'TK_WORD';\r\n            }\r\n\r\n            if (current_token.type === 'TK_RESERVED' && flags.mode === MODE.ObjectLiteral) {\r\n                var next_token = get_token(1);\r\n                if (next_token.text == ':') {\r\n                    current_token.type = 'TK_WORD';\r\n                }\r\n            }\r\n\r\n            if (start_of_statement()) {\r\n                // The conditional starts the statement if appropriate.\r\n            } else if (current_token.wanted_newline && !is_expression(flags.mode) &&\r\n                (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&\r\n                last_type !== 'TK_EQUALS' &&\r\n                (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {\r\n\r\n                print_newline();\r\n            }\r\n\r\n            if (flags.do_block && !flags.do_while) {\r\n                if (current_token.type === 'TK_RESERVED' && current_token.text === 'while') {\r\n                    // do {} ## while ()\r\n                    output.space_before_token = true;\r\n                    print_token();\r\n                    output.space_before_token = true;\r\n                    flags.do_while = true;\r\n                    return;\r\n                } else {\r\n                    // do {} should always have while as the next word.\r\n                    // if we don't see the expected while, recover\r\n                    print_newline();\r\n                    flags.do_block = false;\r\n                }\r\n            }\r\n\r\n            // if may be followed by else, or not\r\n            // Bare/inline ifs are tricky\r\n            // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();\r\n            if (flags.if_block) {\r\n                if (!flags.else_block && (current_token.type === 'TK_RESERVED' && current_token.text === 'else')) {\r\n                    flags.else_block = true;\r\n                } else {\r\n                    while (flags.mode === MODE.Statement) {\r\n                        restore_mode();\r\n                    }\r\n                    flags.if_block = false;\r\n                    flags.else_block = false;\r\n                }\r\n            }\r\n\r\n            if (current_token.type === 'TK_RESERVED' && (current_token.text === 'case' || (current_token.text === 'default' && flags.in_case_statement))) {\r\n                print_newline();\r\n                if (flags.case_body || opt.jslint_happy) {\r\n                    // switch cases following one another\r\n                    deindent();\r\n                    flags.case_body = false;\r\n                }\r\n                print_token();\r\n                flags.in_case = true;\r\n                flags.in_case_statement = true;\r\n                return;\r\n            }\r\n\r\n            if (current_token.type === 'TK_RESERVED' && current_token.text === 'function') {\r\n                if (in_array(flags.last_text, ['}', ';']) || (output.just_added_newline() && ! in_array(flags.last_text, ['[', '{', ':', '=', ',']))) {\r\n                    // make sure there is a nice clean space of at least one blank line\r\n                    // before a new function definition\r\n                    if ( !output.just_added_blankline() && !current_token.comments_before.length) {\r\n                        print_newline();\r\n                        print_newline(true);\r\n                    }\r\n                }\r\n                if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {\r\n                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set', 'new', 'return', 'export'])) {\r\n                        output.space_before_token = true;\r\n                    } else if (last_type === 'TK_RESERVED' && flags.last_text === 'default' && last_last_text === 'export') {\r\n                        output.space_before_token = true;\r\n                    } else {\r\n                        print_newline();\r\n                    }\r\n                } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {\r\n                    // foo = function\r\n                    output.space_before_token = true;\r\n                } else if (!flags.multiline_frame && (is_expression(flags.mode) || is_array(flags.mode))) {\r\n                    // (function\r\n                } else {\r\n                    print_newline();\r\n                }\r\n            }\r\n\r\n            if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {\r\n                if (!start_of_object_property()) {\r\n                    allow_wrap_or_preserved_newline();\r\n                }\r\n            }\r\n\r\n            if (current_token.type === 'TK_RESERVED' &&  in_array(current_token.text, ['function', 'get', 'set'])) {\r\n                print_token();\r\n                flags.last_word = current_token.text;\r\n                return;\r\n            }\r\n\r\n            prefix = 'NONE';\r\n\r\n            if (last_type === 'TK_END_BLOCK') {\r\n                if (!(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally']))) {\r\n                    prefix = 'NEWLINE';\r\n                } else {\r\n                    if (opt.brace_style === \"expand\" ||\r\n                        opt.brace_style === \"end-expand\" ||\r\n                        (opt.brace_style === \"none\" && current_token.wanted_newline)) {\r\n                        prefix = 'NEWLINE';\r\n                    } else {\r\n                        prefix = 'SPACE';\r\n                        output.space_before_token = true;\r\n                    }\r\n                }\r\n            } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {\r\n                // TODO: Should this be for STATEMENT as well?\r\n                prefix = 'NEWLINE';\r\n            } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {\r\n                prefix = 'SPACE';\r\n            } else if (last_type === 'TK_STRING') {\r\n                prefix = 'NEWLINE';\r\n            } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||\r\n                (flags.last_text === '*' && last_last_text === 'function')) {\r\n                prefix = 'SPACE';\r\n            } else if (last_type === 'TK_START_BLOCK') {\r\n                prefix = 'NEWLINE';\r\n            } else if (last_type === 'TK_END_EXPR') {\r\n                output.space_before_token = true;\r\n                prefix = 'NEWLINE';\r\n            }\r\n\r\n            if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {\r\n                if (flags.last_text === 'else' || flags.last_text === 'export') {\r\n                    prefix = 'SPACE';\r\n                } else {\r\n                    prefix = 'NEWLINE';\r\n                }\r\n\r\n            }\r\n\r\n            if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally'])) {\r\n                if (last_type !== 'TK_END_BLOCK' ||\r\n                    opt.brace_style === \"expand\" ||\r\n                    opt.brace_style === \"end-expand\" ||\r\n                    (opt.brace_style === \"none\" && current_token.wanted_newline)) {\r\n                    print_newline();\r\n                } else {\r\n                    output.trim(true);\r\n                    var line = output.current_line;\r\n                    // If we trimmed and there's something other than a close block before us\r\n                    // put a newline back in.  Handles '} // comment' scenario.\r\n                    if (line.last() !== '}') {\r\n                        print_newline();\r\n                    }\r\n                    output.space_before_token = true;\r\n                }\r\n            } else if (prefix === 'NEWLINE') {\r\n                if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {\r\n                    // no newline between 'return nnn'\r\n                    output.space_before_token = true;\r\n                } else if (last_type !== 'TK_END_EXPR') {\r\n                    if ((last_type !== 'TK_START_EXPR' || !(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['var', 'let', 'const']))) && flags.last_text !== ':') {\r\n                        // no need to force newline on 'var': for (var x = 0...)\r\n                        if (current_token.type === 'TK_RESERVED' && current_token.text === 'if' && flags.last_text === 'else') {\r\n                            // no newline for } else if {\r\n                            output.space_before_token = true;\r\n                        } else {\r\n                            print_newline();\r\n                        }\r\n                    }\r\n                } else if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {\r\n                    print_newline();\r\n                }\r\n            } else if (flags.multiline_frame && is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {\r\n                print_newline(); // }, in lists get a newline treatment\r\n            } else if (prefix === 'SPACE') {\r\n                output.space_before_token = true;\r\n            }\r\n            print_token();\r\n            flags.last_word = current_token.text;\r\n\r\n            if (current_token.type === 'TK_RESERVED' && current_token.text === 'do') {\r\n                flags.do_block = true;\r\n            }\r\n\r\n            if (current_token.type === 'TK_RESERVED' && current_token.text === 'if') {\r\n                flags.if_block = true;\r\n            }\r\n        }\r\n\r\n        function handle_semicolon() {\r\n            if (start_of_statement()) {\r\n                // The conditional starts the statement if appropriate.\r\n                // Semicolon can be the start (and end) of a statement\r\n                output.space_before_token = false;\r\n            }\r\n            while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {\r\n                restore_mode();\r\n            }\r\n            print_token();\r\n        }\r\n\r\n        function handle_string() {\r\n            if (start_of_statement()) {\r\n                // The conditional starts the statement if appropriate.\r\n                // One difference - strings want at least a space before\r\n                output.space_before_token = true;\r\n            } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {\r\n                output.space_before_token = true;\r\n            } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {\r\n                if (!start_of_object_property()) {\r\n                    allow_wrap_or_preserved_newline();\r\n                }\r\n            } else {\r\n                print_newline();\r\n            }\r\n            print_token();\r\n        }\r\n\r\n        function handle_equals() {\r\n            if (start_of_statement()) {\r\n                // The conditional starts the statement if appropriate.\r\n            }\r\n\r\n            if (flags.declaration_statement) {\r\n                // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done\r\n                flags.declaration_assignment = true;\r\n            }\r\n            output.space_before_token = true;\r\n            print_token();\r\n            output.space_before_token = true;\r\n        }\r\n\r\n        function handle_comma() {\r\n            if (flags.declaration_statement) {\r\n                if (is_expression(flags.parent.mode)) {\r\n                    // do not break on comma, for(var a = 1, b = 2)\r\n                    flags.declaration_assignment = false;\r\n                }\r\n\r\n                print_token();\r\n\r\n                if (flags.declaration_assignment) {\r\n                    flags.declaration_assignment = false;\r\n                    print_newline(false, true);\r\n                } else {\r\n                    output.space_before_token = true;\r\n                }\r\n                return;\r\n            }\r\n\r\n            print_token();\r\n            if (flags.mode === MODE.ObjectLiteral ||\r\n                (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {\r\n                if (flags.mode === MODE.Statement) {\r\n                    restore_mode();\r\n                }\r\n                print_newline();\r\n            } else {\r\n                // EXPR or DO_BLOCK\r\n                output.space_before_token = true;\r\n            }\r\n\r\n        }\r\n\r\n        function handle_operator() {\r\n            if (start_of_statement()) {\r\n                // The conditional starts the statement if appropriate.\r\n            }\r\n\r\n            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {\r\n                // \"return\" had a special handling in TK_WORD. Now we need to return the favor\r\n                output.space_before_token = true;\r\n                print_token();\r\n                return;\r\n            }\r\n\r\n            // hack for actionscript's import .*;\r\n            if (current_token.text === '*' && last_type === 'TK_DOT') {\r\n                print_token();\r\n                return;\r\n            }\r\n\r\n            if (current_token.text === ':' && flags.in_case) {\r\n                flags.case_body = true;\r\n                indent();\r\n                print_token();\r\n                print_newline();\r\n                flags.in_case = false;\r\n                return;\r\n            }\r\n\r\n            if (current_token.text === '::') {\r\n                // no spaces around exotic namespacing syntax operator\r\n                print_token();\r\n                return;\r\n            }\r\n\r\n            // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1\r\n            // if there is a newline between -- or ++ and anything else we should preserve it.\r\n            if (current_token.wanted_newline && (current_token.text === '--' || current_token.text === '++')) {\r\n                print_newline(false, true);\r\n            }\r\n\r\n            // Allow line wrapping between operators\r\n            if (last_type === 'TK_OPERATOR') {\r\n                allow_wrap_or_preserved_newline();\r\n            }\r\n\r\n            var space_before = true;\r\n            var space_after = true;\r\n\r\n            if (in_array(current_token.text, ['--', '++', '!', '~']) || (in_array(current_token.text, ['-', '+']) && (in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) || in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === ','))) {\r\n                // unary operators (and binary +/- pretending to be unary) special cases\r\n\r\n                space_before = false;\r\n                space_after = false;\r\n\r\n                if (flags.last_text === ';' && is_expression(flags.mode)) {\r\n                    // for (;; ++i)\r\n                    //        ^^^\r\n                    space_before = true;\r\n                }\r\n\r\n                if (last_type === 'TK_RESERVED' || last_type === 'TK_END_EXPR') {\r\n                    space_before = true;\r\n                } else if (last_type === 'TK_OPERATOR') {\r\n                    space_before =\r\n                        (in_array(current_token.text, ['--', '-']) && in_array(flags.last_text, ['--', '-'])) ||\r\n                        (in_array(current_token.text, ['++', '+']) && in_array(flags.last_text, ['++', '+']));\r\n                }\r\n\r\n                if ((flags.mode === MODE.BlockStatement || flags.mode === MODE.Statement) && (flags.last_text === '{' || flags.last_text === ';')) {\r\n                    // { foo; --i }\r\n                    // foo(); --bar;\r\n                    print_newline();\r\n                }\r\n            } else if (current_token.text === ':') {\r\n                if (flags.ternary_depth === 0) {\r\n                    // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.\r\n                    space_before = false;\r\n                } else {\r\n                    flags.ternary_depth -= 1;\r\n                }\r\n            } else if (current_token.text === '?') {\r\n                flags.ternary_depth += 1;\r\n            } else if (current_token.text === '*' && last_type === 'TK_RESERVED' && flags.last_text === 'function') {\r\n                space_before = false;\r\n                space_after = false;\r\n            }\r\n            output.space_before_token = output.space_before_token || space_before;\r\n            print_token();\r\n            output.space_before_token = space_after;\r\n        }\r\n\r\n        function handle_block_comment() {\r\n            var lines = split_newlines(current_token.text);\r\n            var j; // iterator for this case\r\n            var javadoc = false;\r\n            var starless = false;\r\n            var lastIndent = current_token.whitespace_before;\r\n            var lastIndentLength = lastIndent.length;\r\n\r\n            // block comment starts with a new line\r\n            print_newline(false, true);\r\n            if (lines.length > 1) {\r\n                if (all_lines_start_with(lines.slice(1), '*')) {\r\n                    javadoc = true;\r\n                }\r\n                else if (each_line_matches_indent(lines.slice(1), lastIndent)) {\r\n                    starless = true;\r\n                }\r\n            }\r\n\r\n            // first line always indented\r\n            print_token(lines[0]);\r\n            for (j = 1; j < lines.length; j++) {\r\n                print_newline(false, true);\r\n                if (javadoc) {\r\n                    // javadoc: reformat and re-indent\r\n                    print_token(' ' + trim(lines[j]));\r\n                } else if (starless && lines[j].length > lastIndentLength) {\r\n                    // starless: re-indent non-empty content, avoiding trim\r\n                    print_token(lines[j].substring(lastIndentLength));\r\n                } else {\r\n                    // normal comments output raw\r\n                    output.add_token(lines[j]);\r\n                }\r\n            }\r\n\r\n            // for comments of more than one line, make sure there's a new line after\r\n            print_newline(false, true);\r\n        }\r\n\r\n        function handle_inline_comment() {\r\n            output.space_before_token = true;\r\n            print_token();\r\n            output.space_before_token = true;\r\n        }\r\n\r\n        function handle_comment() {\r\n            if (current_token.wanted_newline) {\r\n                print_newline(false, true);\r\n            } else {\r\n                output.trim(true);\r\n            }\r\n\r\n            output.space_before_token = true;\r\n            print_token();\r\n            print_newline(false, true);\r\n        }\r\n\r\n        function handle_dot() {\r\n            if (start_of_statement()) {\r\n                // The conditional starts the statement if appropriate.\r\n            }\r\n\r\n            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {\r\n                output.space_before_token = true;\r\n            } else {\r\n                // allow preserved newlines before dots in general\r\n                // force newlines on dots after close paren when break_chained - for bar().baz()\r\n                allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);\r\n            }\r\n\r\n            print_token();\r\n        }\r\n\r\n        function handle_unknown() {\r\n            print_token();\r\n\r\n            if (current_token.text[current_token.text.length - 1] === '\\n') {\r\n                print_newline();\r\n            }\r\n        }\r\n\r\n        function handle_eof() {\r\n            // Unwind any open statements\r\n            while (flags.mode === MODE.Statement) {\r\n                restore_mode();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function OutputLine(parent) {\r\n        var _character_count = 0;\r\n        // use indent_count as a marker for lines that have preserved indentation\r\n        var _indent_count = -1;\r\n\r\n        var _items = [];\r\n        var _empty = true;\r\n\r\n        this.set_indent = function(level) {\r\n            _character_count = parent.baseIndentLength + level * parent.indent_length\r\n            _indent_count = level;\r\n        }\r\n\r\n        this.get_character_count = function() {\r\n            return _character_count;\r\n        }\r\n\r\n        this.is_empty = function() {\r\n            return _empty;\r\n        }\r\n\r\n        this.last = function() {\r\n            if (!this._empty) {\r\n              return _items[_items.length - 1];\r\n            } else {\r\n              return null;\r\n            }\r\n        }\r\n\r\n        this.push = function(input) {\r\n            _items.push(input);\r\n            _character_count += input.length;\r\n            _empty = false;\r\n        }\r\n\r\n        this.remove_indent = function() {\r\n            if (_indent_count > 0) {\r\n                _indent_count -= 1;\r\n                _character_count -= parent.indent_length\r\n            }\r\n        }\r\n\r\n        this.trim = function() {\r\n            while (this.last() === ' ') {\r\n                var item = _items.pop();\r\n                _character_count -= 1;\r\n            }\r\n            _empty = _items.length === 0;\r\n        }\r\n\r\n        this.toString = function() {\r\n            var result = '';\r\n            if (!this._empty) {\r\n                if (_indent_count >= 0) {\r\n                    result = parent.indent_cache[_indent_count];\r\n                }\r\n                result += _items.join('')\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function Output(indent_string, baseIndentString) {\r\n        baseIndentString = baseIndentString || '';\r\n        this.indent_cache = [ baseIndentString ];\r\n        this.baseIndentLength = baseIndentString.length;\r\n        this.indent_length = indent_string.length;\r\n\r\n        var lines =[];\r\n        this.baseIndentString = baseIndentString;\r\n        this.indent_string = indent_string;\r\n        this.current_line = null;\r\n        this.space_before_token = false;\r\n\r\n        this.get_line_number = function() {\r\n            return lines.length;\r\n        }\r\n\r\n        // Using object instead of string to allow for later expansion of info about each line\r\n        this.add_new_line = function(force_newline) {\r\n            if (this.get_line_number() === 1 && this.just_added_newline()) {\r\n                return false; // no newline on start of file\r\n            }\r\n\r\n            if (force_newline || !this.just_added_newline()) {\r\n                this.current_line = new OutputLine(this);\r\n                lines.push(this.current_line);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        // initialize\r\n        this.add_new_line(true);\r\n\r\n        this.get_code = function() {\r\n            var sweet_code = lines.join('\\n').replace(/[\\r\\n\\t ]+$/, '');\r\n            return sweet_code;\r\n        }\r\n\r\n        this.set_indent = function(level) {\r\n            // Never indent your first output indent at the start of the file\r\n            if (lines.length > 1) {\r\n                while(level >= this.indent_cache.length) {\r\n                    this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);\r\n                }\r\n\r\n                this.current_line.set_indent(level);\r\n                return true;\r\n            }\r\n            this.current_line.set_indent(0);\r\n            return false;\r\n        }\r\n\r\n        this.add_token = function(printable_token) {\r\n            this.add_space_before_token();\r\n            this.current_line.push(printable_token);\r\n        }\r\n\r\n        this.add_space_before_token = function() {\r\n            if (this.space_before_token && !this.just_added_newline()) {\r\n                this.current_line.push(' ');\r\n            }\r\n            this.space_before_token = false;\r\n        }\r\n\r\n        this.remove_redundant_indentation = function (frame) {\r\n            // This implementation is effective but has some issues:\r\n            //     - can cause line wrap to happen too soon due to indent removal\r\n            //           after wrap points are calculated\r\n            // These issues are minor compared to ugly indentation.\r\n\r\n            if (frame.multiline_frame ||\r\n                frame.mode === MODE.ForInitializer ||\r\n                frame.mode === MODE.Conditional) {\r\n                return;\r\n            }\r\n\r\n            // remove one indent from each line inside this section\r\n            var index = frame.start_line_index;\r\n            var line;\r\n\r\n            var output_length = lines.length;\r\n            while (index < output_length) {\r\n                lines[index].remove_indent();\r\n                index++;\r\n            }\r\n        }\r\n\r\n        this.trim = function(eat_newlines) {\r\n            eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;\r\n\r\n            this.current_line.trim(indent_string, baseIndentString);\r\n\r\n            while (eat_newlines && lines.length > 1 &&\r\n                this.current_line.is_empty()) {\r\n                lines.pop();\r\n                this.current_line = lines[lines.length - 1]\r\n                this.current_line.trim();\r\n            }\r\n        }\r\n\r\n        this.just_added_newline = function() {\r\n            return this.current_line.is_empty();\r\n        }\r\n\r\n        this.just_added_blankline = function() {\r\n            if (this.just_added_newline()) {\r\n                if (lines.length === 1) {\r\n                    return true; // start of the file and newline = blank\r\n                }\r\n\r\n                var line = lines[lines.length - 2];\r\n                return line.is_empty();\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    var Token = function(type, text, newlines, whitespace_before, mode, parent) {\r\n        this.type = type;\r\n        this.text = text;\r\n        this.comments_before = [];\r\n        this.newlines = newlines || 0;\r\n        this.wanted_newline = newlines > 0;\r\n        this.whitespace_before = whitespace_before || '';\r\n        this.parent = null;\r\n    }\r\n\r\n    function tokenizer(input, opts, indent_string) {\r\n\r\n        var whitespace = \"\\n\\r\\t \".split('');\r\n        var digit = /[0-9]/;\r\n\r\n        var punct = ('+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! ~ , : ? ^ ^= |= :: =>'\r\n                +' <%= <% %> <?= <? ?>').split(' '); // try to be a good boy and try not to break the markup language identifiers\r\n\r\n        // words which should always start on new line.\r\n        this.line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,yield,import,export'.split(',');\r\n        var reserved_words = this.line_starters.concat(['do', 'in', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof']);\r\n\r\n        var n_newlines, whitespace_before_token, in_html_comment, tokens, parser_pos;\r\n        var input_length;\r\n\r\n        this.tokenize = function() {\r\n            // cache the source's length.\r\n            input_length = input.length\r\n            parser_pos = 0;\r\n            in_html_comment = false\r\n            tokens = [];\r\n\r\n            var next, last;\r\n            var token_values;\r\n            var open = null;\r\n            var open_stack = [];\r\n            var comments = [];\r\n\r\n            while (!(last && last.type === 'TK_EOF')) {\r\n                token_values = tokenize_next();\r\n                next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);\r\n                while(next.type === 'TK_INLINE_COMMENT' || next.type === 'TK_COMMENT' ||\r\n                    next.type === 'TK_BLOCK_COMMENT' || next.type === 'TK_UNKNOWN') {\r\n                    comments.push(next);\r\n                    token_values = tokenize_next();\r\n                    next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);\r\n                }\r\n\r\n                if (comments.length) {\r\n                    next.comments_before = comments;\r\n                    comments = [];\r\n                }\r\n\r\n                if (next.type === 'TK_START_BLOCK' || next.type === 'TK_START_EXPR') {\r\n                    next.parent = last;\r\n                    open = next;\r\n                    open_stack.push(next);\r\n                }  else if ((next.type === 'TK_END_BLOCK' || next.type === 'TK_END_EXPR') &&\r\n                    (open && (\r\n                        (next.text === ']' && open.text === '[') ||\r\n                        (next.text === ')' && open.text === '(') ||\r\n                        (next.text === '}' && open.text === '}')))) {\r\n                    next.parent = open.parent;\r\n                    open = open_stack.pop();\r\n                }\r\n\r\n                tokens.push(next);\r\n                last = next;\r\n            }\r\n\r\n            return tokens;\r\n        }\r\n\r\n        function tokenize_next() {\r\n            var i, resulting_string;\r\n            var whitespace_on_this_line = [];\r\n\r\n            n_newlines = 0;\r\n            whitespace_before_token = '';\r\n\r\n            if (parser_pos >= input_length) {\r\n                return ['', 'TK_EOF'];\r\n            }\r\n\r\n            var last_token;\r\n            if (tokens.length) {\r\n                last_token = tokens[tokens.length-1];\r\n            } else {\r\n                // For the sake of tokenizing we can pretend that there was on open brace to start\r\n                last_token = new Token('TK_START_BLOCK', '{');\r\n            }\r\n\r\n\r\n            var c = input.charAt(parser_pos);\r\n            parser_pos += 1;\r\n\r\n            while (in_array(c, whitespace)) {\r\n\r\n                if (c === '\\n') {\r\n                    n_newlines += 1;\r\n                    whitespace_on_this_line = [];\r\n                } else if (n_newlines) {\r\n                    if (c === indent_string) {\r\n                        whitespace_on_this_line.push(indent_string);\r\n                    } else if (c !== '\\r') {\r\n                        whitespace_on_this_line.push(' ');\r\n                    }\r\n                }\r\n\r\n                if (parser_pos >= input_length) {\r\n                    return ['', 'TK_EOF'];\r\n                }\r\n\r\n                c = input.charAt(parser_pos);\r\n                parser_pos += 1;\r\n            }\r\n\r\n            if(whitespace_on_this_line.length) {\r\n                whitespace_before_token = whitespace_on_this_line.join('');\r\n            }\r\n\r\n            if (digit.test(c)) {\r\n                var allow_decimal = true;\r\n                var allow_e = true;\r\n                var local_digit = digit;\r\n\r\n                if (c === '0' && parser_pos < input_length && /[Xx]/.test(input.charAt(parser_pos))) {\r\n                    // switch to hex number, no decimal or e, just hex digits\r\n                    allow_decimal = false;\r\n                    allow_e = false;\r\n                    c += input.charAt(parser_pos);\r\n                    parser_pos += 1;\r\n                    local_digit = /[0123456789abcdefABCDEF]/\r\n                } else {\r\n                    // we know this first loop will run.  It keeps the logic simpler.\r\n                    c = '';\r\n                    parser_pos -= 1\r\n                }\r\n\r\n                // Add the digits\r\n                while (parser_pos < input_length && local_digit.test(input.charAt(parser_pos))) {\r\n                    c += input.charAt(parser_pos);\r\n                    parser_pos += 1;\r\n\r\n                    if (allow_decimal && parser_pos < input_length && input.charAt(parser_pos) === '.') {\r\n                        c += input.charAt(parser_pos);\r\n                        parser_pos += 1;\r\n                        allow_decimal = false;\r\n                    }\r\n\r\n                    if (allow_e && parser_pos < input_length && /[Ee]/.test(input.charAt(parser_pos))) {\r\n                        c += input.charAt(parser_pos);\r\n                        parser_pos += 1;\r\n\r\n                        if (parser_pos < input_length && /[+-]/.test(input.charAt(parser_pos))) {\r\n                            c += input.charAt(parser_pos);\r\n                            parser_pos += 1;\r\n                        }\r\n\r\n                        allow_e = false;\r\n                        allow_decimal = false;\r\n                    }\r\n                }\r\n\r\n                return [c, 'TK_WORD'];\r\n            }\r\n\r\n            if (acorn.isIdentifierStart(input.charCodeAt(parser_pos-1))) {\r\n                if (parser_pos < input_length) {\r\n                    while (acorn.isIdentifierChar(input.charCodeAt(parser_pos))) {\r\n                        c += input.charAt(parser_pos);\r\n                        parser_pos += 1;\r\n                        if (parser_pos === input_length) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!(last_token.type === 'TK_DOT' ||\r\n                        (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['set', 'get'])))\r\n                    && in_array(c, reserved_words)) {\r\n                    if (c === 'in') { // hack for 'in' operator\r\n                        return [c, 'TK_OPERATOR'];\r\n                    }\r\n                    return [c, 'TK_RESERVED'];\r\n                }\r\n\r\n                return [c, 'TK_WORD'];\r\n            }\r\n\r\n            if (c === '(' || c === '[') {\r\n                return [c, 'TK_START_EXPR'];\r\n            }\r\n\r\n            if (c === ')' || c === ']') {\r\n                return [c, 'TK_END_EXPR'];\r\n            }\r\n\r\n            if (c === '{') {\r\n                return [c, 'TK_START_BLOCK'];\r\n            }\r\n\r\n            if (c === '}') {\r\n                return [c, 'TK_END_BLOCK'];\r\n            }\r\n\r\n            if (c === ';') {\r\n                return [c, 'TK_SEMICOLON'];\r\n            }\r\n\r\n            if (c === '/') {\r\n                var comment = '';\r\n                // peek for comment /* ... */\r\n                var inline_comment = true;\r\n                if (input.charAt(parser_pos) === '*') {\r\n                    parser_pos += 1;\r\n                    if (parser_pos < input_length) {\r\n                        while (parser_pos < input_length && !(input.charAt(parser_pos) === '*' && input.charAt(parser_pos + 1) && input.charAt(parser_pos + 1) === '/')) {\r\n                            c = input.charAt(parser_pos);\r\n                            comment += c;\r\n                            if (c === \"\\n\" || c === \"\\r\") {\r\n                                inline_comment = false;\r\n                            }\r\n                            parser_pos += 1;\r\n                            if (parser_pos >= input_length) {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    parser_pos += 2;\r\n                    if (inline_comment && n_newlines === 0) {\r\n                        return ['/*' + comment + '*/', 'TK_INLINE_COMMENT'];\r\n                    } else {\r\n                        return ['/*' + comment + '*/', 'TK_BLOCK_COMMENT'];\r\n                    }\r\n                }\r\n                // peek for comment // ...\r\n                if (input.charAt(parser_pos) === '/') {\r\n                    comment = c;\r\n                    while (input.charAt(parser_pos) !== '\\r' && input.charAt(parser_pos) !== '\\n') {\r\n                        comment += input.charAt(parser_pos);\r\n                        parser_pos += 1;\r\n                        if (parser_pos >= input_length) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    return [comment, 'TK_COMMENT'];\r\n                }\r\n\r\n            }\r\n\r\n            if (c === '`' || c === \"'\" || c === '\"' || // string\r\n                (\r\n                    (c === '/') || // regexp\r\n                    (opts.e4x && c === \"<\" && input.slice(parser_pos - 1).match(/^<([-a-zA-Z:0-9_.]+|{[^{}]*}|!\\[CDATA\\[[\\s\\S]*?\\]\\])\\s*([-a-zA-Z:0-9_.]+=('[^']*'|\"[^\"]*\"|{[^{}]*})\\s*)*\\/?\\s*>/)) // xml\r\n                ) && ( // regex and xml can only appear in specific locations during parsing\r\n                    (last_token.type === 'TK_RESERVED' && in_array(last_token.text , ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||\r\n                    (last_token.type === 'TK_END_EXPR' && last_token.text === ')' &&\r\n                        last_token.parent && last_token.parent.type === 'TK_RESERVED' && in_array(last_token.parent.text, ['if', 'while', 'for'])) ||\r\n                    (in_array(last_token.type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',\r\n                        'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'\r\n                    ]))\r\n                )) {\r\n\r\n                var sep = c,\r\n                    esc = false,\r\n                    has_char_escapes = false;\r\n\r\n                resulting_string = c;\r\n\r\n                if (sep === '/') {\r\n                    //\r\n                    // handle regexp\r\n                    //\r\n                    var in_char_class = false;\r\n                    while (parser_pos < input_length &&\r\n                            ((esc || in_char_class || input.charAt(parser_pos) !== sep) &&\r\n                            !acorn.newline.test(input.charAt(parser_pos)))) {\r\n                        resulting_string += input.charAt(parser_pos);\r\n                        if (!esc) {\r\n                            esc = input.charAt(parser_pos) === '\\\\';\r\n                            if (input.charAt(parser_pos) === '[') {\r\n                                in_char_class = true;\r\n                            } else if (input.charAt(parser_pos) === ']') {\r\n                                in_char_class = false;\r\n                            }\r\n                        } else {\r\n                            esc = false;\r\n                        }\r\n                        parser_pos += 1;\r\n                    }\r\n                } else if (opts.e4x && sep === '<') {\r\n                    //\r\n                    // handle e4x xml literals\r\n                    //\r\n                    var xmlRegExp = /<(\\/?)([-a-zA-Z:0-9_.]+|{[^{}]*}|!\\[CDATA\\[[\\s\\S]*?\\]\\])\\s*([-a-zA-Z:0-9_.]+=('[^']*'|\"[^\"]*\"|{[^{}]*})\\s*)*(\\/?)\\s*>/g;\r\n                    var xmlStr = input.slice(parser_pos - 1);\r\n                    var match = xmlRegExp.exec(xmlStr);\r\n                    if (match && match.index === 0) {\r\n                        var rootTag = match[2];\r\n                        var depth = 0;\r\n                        while (match) {\r\n                            var isEndTag = !! match[1];\r\n                            var tagName = match[2];\r\n                            var isSingletonTag = ( !! match[match.length - 1]) || (tagName.slice(0, 8) === \"![CDATA[\");\r\n                            if (tagName === rootTag && !isSingletonTag) {\r\n                                if (isEndTag) {\r\n                                    --depth;\r\n                                } else {\r\n                                    ++depth;\r\n                                }\r\n                            }\r\n                            if (depth <= 0) {\r\n                                break;\r\n                            }\r\n                            match = xmlRegExp.exec(xmlStr);\r\n                        }\r\n                        var xmlLength = match ? match.index + match[0].length : xmlStr.length;\r\n                        parser_pos += xmlLength - 1;\r\n                        return [xmlStr.slice(0, xmlLength), \"TK_STRING\"];\r\n                    }\r\n                } else {\r\n                    //\r\n                    // handle string\r\n                    //\r\n                    // Template strings can travers lines without escape characters.\r\n                    // Other strings cannot\r\n                    while (parser_pos < input_length &&\r\n                            (esc || (input.charAt(parser_pos) !== sep &&\r\n                            (sep === '`' || !acorn.newline.test(input.charAt(parser_pos)))))) {\r\n                        resulting_string += input.charAt(parser_pos);\r\n                        if (esc) {\r\n                            if (input.charAt(parser_pos) === 'x' || input.charAt(parser_pos) === 'u') {\r\n                                has_char_escapes = true;\r\n                            }\r\n                            esc = false;\r\n                        } else {\r\n                            esc = input.charAt(parser_pos) === '\\\\';\r\n                        }\r\n                        parser_pos += 1;\r\n                    }\r\n\r\n                }\r\n\r\n                if (has_char_escapes && opts.unescape_strings) {\r\n                    resulting_string = unescape_string(resulting_string);\r\n                }\r\n\r\n                if (parser_pos < input_length && input.charAt(parser_pos) === sep) {\r\n                    resulting_string += sep;\r\n                    parser_pos += 1;\r\n\r\n                    if (sep === '/') {\r\n                        // regexps may have modifiers /regexp/MOD , so fetch those, too\r\n                        // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.\r\n                        while (parser_pos < input_length && acorn.isIdentifierStart(input.charCodeAt(parser_pos))) {\r\n                            resulting_string += input.charAt(parser_pos);\r\n                            parser_pos += 1;\r\n                        }\r\n                    }\r\n                }\r\n                return [resulting_string, 'TK_STRING'];\r\n            }\r\n\r\n            if (c === '#') {\r\n\r\n                if (tokens.length === 0 && input.charAt(parser_pos) === '!') {\r\n                    // shebang\r\n                    resulting_string = c;\r\n                    while (parser_pos < input_length && c !== '\\n') {\r\n                        c = input.charAt(parser_pos);\r\n                        resulting_string += c;\r\n                        parser_pos += 1;\r\n                    }\r\n                    return [trim(resulting_string) + '\\n', 'TK_UNKNOWN'];\r\n                }\r\n\r\n\r\n\r\n                // Spidermonkey-specific sharp variables for circular references\r\n                // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript\r\n                // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935\r\n                var sharp = '#';\r\n                if (parser_pos < input_length && digit.test(input.charAt(parser_pos))) {\r\n                    do {\r\n                        c = input.charAt(parser_pos);\r\n                        sharp += c;\r\n                        parser_pos += 1;\r\n                    } while (parser_pos < input_length && c !== '#' && c !== '=');\r\n                    if (c === '#') {\r\n                        //\r\n                    } else if (input.charAt(parser_pos) === '[' && input.charAt(parser_pos + 1) === ']') {\r\n                        sharp += '[]';\r\n                        parser_pos += 2;\r\n                    } else if (input.charAt(parser_pos) === '{' && input.charAt(parser_pos + 1) === '}') {\r\n                        sharp += '{}';\r\n                        parser_pos += 2;\r\n                    }\r\n                    return [sharp, 'TK_WORD'];\r\n                }\r\n            }\r\n\r\n            if (c === '<' && input.substring(parser_pos - 1, parser_pos + 3) === '<!--') {\r\n                parser_pos += 3;\r\n                c = '<!--';\r\n                while (input.charAt(parser_pos) !== '\\n' && parser_pos < input_length) {\r\n                    c += input.charAt(parser_pos);\r\n                    parser_pos++;\r\n                }\r\n                in_html_comment = true;\r\n                return [c, 'TK_COMMENT'];\r\n            }\r\n\r\n            if (c === '-' && in_html_comment && input.substring(parser_pos - 1, parser_pos + 2) === '-->') {\r\n                in_html_comment = false;\r\n                parser_pos += 2;\r\n                return ['-->', 'TK_COMMENT'];\r\n            }\r\n\r\n            if (c === '.') {\r\n                return [c, 'TK_DOT'];\r\n            }\r\n\r\n            if (in_array(c, punct)) {\r\n                while (parser_pos < input_length && in_array(c + input.charAt(parser_pos), punct)) {\r\n                    c += input.charAt(parser_pos);\r\n                    parser_pos += 1;\r\n                    if (parser_pos >= input_length) {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (c === ',') {\r\n                    return [c, 'TK_COMMA'];\r\n                } else if (c === '=') {\r\n                    return [c, 'TK_EQUALS'];\r\n                } else {\r\n                    return [c, 'TK_OPERATOR'];\r\n                }\r\n            }\r\n\r\n            return [c, 'TK_UNKNOWN'];\r\n        }\r\n\r\n\r\n        function unescape_string(s) {\r\n            var esc = false,\r\n                out = '',\r\n                pos = 0,\r\n                s_hex = '',\r\n                escaped = 0,\r\n                c;\r\n\r\n            while (esc || pos < s.length) {\r\n\r\n                c = s.charAt(pos);\r\n                pos++;\r\n\r\n                if (esc) {\r\n                    esc = false;\r\n                    if (c === 'x') {\r\n                        // simple hex-escape \\x24\r\n                        s_hex = s.substr(pos, 2);\r\n                        pos += 2;\r\n                    } else if (c === 'u') {\r\n                        // unicode-escape, \\u2134\r\n                        s_hex = s.substr(pos, 4);\r\n                        pos += 4;\r\n                    } else {\r\n                        // some common escape, e.g \\n\r\n                        out += '\\\\' + c;\r\n                        continue;\r\n                    }\r\n                    if (!s_hex.match(/^[0123456789abcdefABCDEF]+$/)) {\r\n                        // some weird escaping, bail out,\r\n                        // leaving whole string intact\r\n                        return s;\r\n                    }\r\n\r\n                    escaped = parseInt(s_hex, 16);\r\n\r\n                    if (escaped >= 0x00 && escaped < 0x20) {\r\n                        // leave 0x00...0x1f escaped\r\n                        if (c === 'x') {\r\n                            out += '\\\\x' + s_hex;\r\n                        } else {\r\n                            out += '\\\\u' + s_hex;\r\n                        }\r\n                        continue;\r\n                    } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {\r\n                        // single-quote, apostrophe, backslash - escape these\r\n                        out += '\\\\' + String.fromCharCode(escaped);\r\n                    } else if (c === 'x' && escaped > 0x7e && escaped <= 0xff) {\r\n                        // we bail out on \\x7f..\\xff,\r\n                        // leaving whole string escaped,\r\n                        // as it's probably completely binary\r\n                        return s;\r\n                    } else {\r\n                        out += String.fromCharCode(escaped);\r\n                    }\r\n                } else if (c === '\\\\') {\r\n                    esc = true;\r\n                } else {\r\n                    out += c;\r\n                }\r\n            }\r\n            return out;\r\n        }\r\n\r\n    }\r\n\r\n    return { js_beautify: js_beautify };\r\n});\r\n"]}