{"version":3,"sources":["primitives/beautify-html.js"],"names":["define","beautifyCss","beautifyJs","rtrim","s","replace","html_beautify","html_source","options","js_beautify","css_beautify","multi_parser","indent_inner_html","indent_size","indent_character","wrap_line_length","brace_style","unformatted","preserve_newlines","max_preserve_newlines","indent_handlebars","end_with_newline","undefined","parseInt","max_char","indent_char","isNaN","this","pos","token","current_mode","tags","parent","parentcount","parent1","tag_type","token_text","last_token","last_text","token_type","newlines","indent_content","Utils","whitespace","split","single_token","extra_liners","in_array","what","arr","i","length","is_whitespace","text","charAt","traverse_whitespace","input_char","input","space_or_wrap","content","line_char_count","print_newline","print_indentation","push","get_content","join","peek3","substr","get_tag","get_contents_to","name","reg_match","RegExp","lastIndex","reg_array","exec","end_script","index","substring","record_tag","tag","indent_level","retrieve_tag","temp_parent","indent_to_tag","peek","tag_start","tag_start_char","comment","space","orig_pos","orig_line_char_count","get_unformatted","get_comment","tag_index","tag_offset","tag_complete","indexOf","tag_check","toLowerCase","is_unformatted","search","output","start_pos","delimiter","matched","orig_tag","min_index","get_token","type","get_full_indent","level","Array","indent_string","match","printer","js_source","force","print_token","print_token_raw","slice","n","indent","unindent","t","tag_name","tag_extracted_from_last_output","_beautifier","script_indent_level","indent_scripts","indentation","_level","reindent","sweet_code","style_html"],"mappings":"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","file":"../../primitives/beautify-html.js","sourcesContent":["/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */\r\n/*\r\n\r\n  The MIT License (MIT)\r\n\r\n  Copyright (c) 2007-2013 Einar Lielmanis and contributors.\r\n\r\n  Permission is hereby granted, free of charge, to any person\r\n  obtaining a copy of this software and associated documentation files\r\n  (the \"Software\"), to deal in the Software without restriction,\r\n  including without limitation the rights to use, copy, modify, merge,\r\n  publish, distribute, sublicense, and/or sell copies of the Software,\r\n  and to permit persons to whom the Software is furnished to do so,\r\n  subject to the following conditions:\r\n\r\n  The above copyright notice and this permission notice shall be\r\n  included in all copies or substantial portions of the Software.\r\n\r\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\r\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\r\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n  SOFTWARE.\r\n\r\n\r\n Style HTML\r\n---------------\r\n\r\n  Written by Nochum Sossonko, (nsossonko@hotmail.com)\r\n\r\n  Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>\r\n    http://jsbeautifier.org/\r\n\r\n  Usage:\r\n    style_html(html_source);\r\n\r\n    style_html(html_source, options);\r\n\r\n  The options are:\r\n    indent_inner_html (default false)  — indent <head> and <body> sections,\r\n    indent_size (default 4)          — indentation size,\r\n    indent_char (default space)      — character to indent with,\r\n    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)\r\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\"\r\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\r\n    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted\r\n    indent_scripts (default normal)  - \"keep\"|\"separate\"|\"normal\"\r\n    preserve_newlines (default true) - whether existing line breaks before elements should be preserved\r\n                                        Only works before elements, not inside tags or for text.\r\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk\r\n    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}\r\n    end_with_newline (false)          - end with a newline\r\n\r\n\r\n    e.g.\r\n\r\n    style_html(html_source, {\r\n      'indent_inner_html': false,\r\n      'indent_size': 2,\r\n      'indent_char': ' ',\r\n      'wrap_line_length': 78,\r\n      'brace_style': 'expand',\r\n      'unformatted': ['a', 'sub', 'sup', 'b', 'i', 'u'],\r\n      'preserve_newlines': true,\r\n      'max_preserve_newlines': 5,\r\n      'indent_handlebars': false\r\n    });\r\n*/\r\n\r\ndefine([\r\n    \"skylark-texts-css/beautify\",\r\n    \"skylark-scripts-javascript/beautify\"\r\n], function(beautifyCss, beautifyJs) {\r\n\r\n    function trim(s) {\r\n        return s.replace(/^\\s+|\\s+$/g, '');\r\n    }\r\n\r\n    function ltrim(s) {\r\n        return s.replace(/^\\s+/g, '');\r\n    }\r\n\r\n    function rtrim(s) {\r\n        return s.replace(/\\s+$/g,'');\r\n    }\r\n\r\n    function style_html(html_source, options, js_beautify, css_beautify) {\r\n        //Wrapper function to invoke all the necessary constructors and deal with the output.\r\n\r\n        var multi_parser,\r\n            indent_inner_html,\r\n            indent_size,\r\n            indent_character,\r\n            wrap_line_length,\r\n            brace_style,\r\n            unformatted,\r\n            preserve_newlines,\r\n            max_preserve_newlines,\r\n            indent_handlebars,\r\n            end_with_newline;\r\n\r\n        options = options || {};\r\n\r\n        // backwards compatibility to 1.3.4\r\n        if ((options.wrap_line_length === undefined || parseInt(options.wrap_line_length, 10) === 0) &&\r\n                (options.max_char !== undefined && parseInt(options.max_char, 10) !== 0)) {\r\n            options.wrap_line_length = options.max_char;\r\n        }\r\n\r\n        indent_inner_html = (options.indent_inner_html === undefined) ? false : options.indent_inner_html;\r\n        indent_size = (options.indent_size === undefined) ? 4 : parseInt(options.indent_size, 10);\r\n        indent_character = (options.indent_char === undefined) ? ' ' : options.indent_char;\r\n        brace_style = (options.brace_style === undefined) ? 'collapse' : options.brace_style;\r\n        wrap_line_length =  parseInt(options.wrap_line_length, 10) === 0 ? 32786 : parseInt(options.wrap_line_length || 250, 10);\r\n        unformatted = options.unformatted || ['a', 'span', 'img', 'bdo', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'q', 'sub', 'sup', 'tt', 'i', 'b', 'big', 'small', 'u', 's', 'strike', 'font', 'ins', 'del', 'pre', 'address', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];\r\n        preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;\r\n        max_preserve_newlines = preserve_newlines ?\r\n            (isNaN(parseInt(options.max_preserve_newlines, 10)) ? 32786 : parseInt(options.max_preserve_newlines, 10))\r\n            : 0;\r\n        indent_handlebars = (options.indent_handlebars === undefined) ? false : options.indent_handlebars;\r\n        end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;\r\n\r\n        function Parser() {\r\n\r\n            this.pos = 0; //Parser position\r\n            this.token = '';\r\n            this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT\r\n            this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values\r\n                parent: 'parent1',\r\n                parentcount: 1,\r\n                parent1: ''\r\n            };\r\n            this.tag_type = '';\r\n            this.token_text = this.last_token = this.last_text = this.token_type = '';\r\n            this.newlines = 0;\r\n            this.indent_content = indent_inner_html;\r\n\r\n            this.Utils = { //Uilities made available to the various functions\r\n                whitespace: \"\\n\\r\\t \".split(''),\r\n                single_token: 'br,input,link,meta,!doctype,basefont,base,area,hr,wbr,param,img,isindex,?xml,embed,?php,?,?='.split(','), //all the single tags for HTML\r\n                extra_liners: 'head,body,/html'.split(','), //for tags that need a line of whitespace before them\r\n                in_array: function(what, arr) {\r\n                    for (var i = 0; i < arr.length; i++) {\r\n                        if (what === arr[i]) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    return false;\r\n                }\r\n            };\r\n\r\n            // Return true iff the given text is composed entirely of\r\n            // whitespace.\r\n            this.is_whitespace = function(text) {\r\n                for (var n = 0; n < text.length; text++) {\r\n                    if (!this.Utils.in_array(text.charAt(n), this.Utils.whitespace)) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n\r\n            this.traverse_whitespace = function() {\r\n                var input_char = '';\r\n\r\n                input_char = this.input.charAt(this.pos);\r\n                if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\r\n                    this.newlines = 0;\r\n                    while (this.Utils.in_array(input_char, this.Utils.whitespace)) {\r\n                        if (preserve_newlines && input_char === '\\n' && this.newlines <= max_preserve_newlines) {\r\n                            this.newlines += 1;\r\n                        }\r\n\r\n                        this.pos++;\r\n                        input_char = this.input.charAt(this.pos);\r\n                    }\r\n                    return true;\r\n                }\r\n                return false;\r\n            };\r\n\r\n            // Append a space to the given content (string array) or, if we are\r\n            // at the wrap_line_length, append a newline/indentation.\r\n            this.space_or_wrap = function(content) {\r\n                if (this.line_char_count >= this.wrap_line_length) { //insert a line when the wrap_line_length is reached\r\n                    this.print_newline(false, content);\r\n                    this.print_indentation(content);\r\n                } else {\r\n                    this.line_char_count++;\r\n                    content.push(' ');\r\n                }\r\n            };\r\n\r\n            this.get_content = function() { //function to capture regular content between tags\r\n                var input_char = '',\r\n                    content = [],\r\n                    space = false; //if a space is needed\r\n\r\n                while (this.input.charAt(this.pos) !== '<') {\r\n                    if (this.pos >= this.input.length) {\r\n                        return content.length ? content.join('') : ['', 'TK_EOF'];\r\n                    }\r\n\r\n                    if (this.traverse_whitespace()) {\r\n                        this.space_or_wrap(content);\r\n                        continue;\r\n                    }\r\n\r\n                    if (indent_handlebars) {\r\n                        // Handlebars parsing is complicated.\r\n                        // {{#foo}} and {{/foo}} are formatted tags.\r\n                        // {{something}} should get treated as content, except:\r\n                        // {{else}} specifically behaves like {{#if}} and {{/if}}\r\n                        var peek3 = this.input.substr(this.pos, 3);\r\n                        if (peek3 === '{{#' || peek3 === '{{/') {\r\n                            // These are tags and not content.\r\n                            break;\r\n                        } else if (this.input.substr(this.pos, 2) === '{{') {\r\n                            if (this.get_tag(true) === '{{else}}') {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    input_char = this.input.charAt(this.pos);\r\n                    this.pos++;\r\n                    this.line_char_count++;\r\n                    content.push(input_char); //letter at-a-time (or string) inserted to an array\r\n                }\r\n                return content.length ? content.join('') : '';\r\n            };\r\n\r\n            this.get_contents_to = function(name) { //get the full content of a script or style to pass to js_beautify\r\n                if (this.pos === this.input.length) {\r\n                    return ['', 'TK_EOF'];\r\n                }\r\n                var input_char = '';\r\n                var content = '';\r\n                var reg_match = new RegExp('</' + name + '\\\\s*>', 'igm');\r\n                reg_match.lastIndex = this.pos;\r\n                var reg_array = reg_match.exec(this.input);\r\n                var end_script = reg_array ? reg_array.index : this.input.length; //absolute end of script\r\n                if (this.pos < end_script) { //get everything in between the script tags\r\n                    content = this.input.substring(this.pos, end_script);\r\n                    this.pos = end_script;\r\n                }\r\n                return content;\r\n            };\r\n\r\n            this.record_tag = function(tag) { //function to record a tag and its parent in this.tags Object\r\n                if (this.tags[tag + 'count']) { //check for the existence of this tag type\r\n                    this.tags[tag + 'count']++;\r\n                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\r\n                } else { //otherwise initialize this tag type\r\n                    this.tags[tag + 'count'] = 1;\r\n                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\r\n                }\r\n                this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)\r\n                this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')\r\n            };\r\n\r\n            this.retrieve_tag = function(tag) { //function to retrieve the opening tag to the corresponding closer\r\n                if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it\r\n                    var temp_parent = this.tags.parent; //check to see if it's a closable tag.\r\n                    while (temp_parent) { //till we reach '' (the initial value);\r\n                        if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it\r\n                            break;\r\n                        }\r\n                        temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree\r\n                    }\r\n                    if (temp_parent) { //if we caught something\r\n                        this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly\r\n                        this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent\r\n                    }\r\n                    delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...\r\n                    delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself\r\n                    if (this.tags[tag + 'count'] === 1) {\r\n                        delete this.tags[tag + 'count'];\r\n                    } else {\r\n                        this.tags[tag + 'count']--;\r\n                    }\r\n                }\r\n            };\r\n\r\n            this.indent_to_tag = function(tag) {\r\n                // Match the indentation level to the last use of this tag, but don't remove it.\r\n                if (!this.tags[tag + 'count']) {\r\n                    return;\r\n                }\r\n                var temp_parent = this.tags.parent;\r\n                while (temp_parent) {\r\n                    if (tag + this.tags[tag + 'count'] === temp_parent) {\r\n                        break;\r\n                    }\r\n                    temp_parent = this.tags[temp_parent + 'parent'];\r\n                }\r\n                if (temp_parent) {\r\n                    this.indent_level = this.tags[tag + this.tags[tag + 'count']];\r\n                }\r\n            };\r\n\r\n            this.get_tag = function(peek) { //function to get a full tag and parse its type\r\n                var input_char = '',\r\n                    content = [],\r\n                    comment = '',\r\n                    space = false,\r\n                    tag_start, tag_end,\r\n                    tag_start_char,\r\n                    orig_pos = this.pos,\r\n                    orig_line_char_count = this.line_char_count;\r\n\r\n                peek = peek !== undefined ? peek : false;\r\n\r\n                do {\r\n                    if (this.pos >= this.input.length) {\r\n                        if (peek) {\r\n                            this.pos = orig_pos;\r\n                            this.line_char_count = orig_line_char_count;\r\n                        }\r\n                        return content.length ? content.join('') : ['', 'TK_EOF'];\r\n                    }\r\n\r\n                    input_char = this.input.charAt(this.pos);\r\n                    this.pos++;\r\n\r\n                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space\r\n                        space = true;\r\n                        continue;\r\n                    }\r\n\r\n                    if (input_char === \"'\" || input_char === '\"') {\r\n                        input_char += this.get_unformatted(input_char);\r\n                        space = true;\r\n\r\n                    }\r\n\r\n                    if (input_char === '=') { //no space before =\r\n                        space = false;\r\n                    }\r\n\r\n                    if (content.length && content[content.length - 1] !== '=' && input_char !== '>' && space) {\r\n                        //no space after = or before >\r\n                        this.space_or_wrap(content);\r\n                        space = false;\r\n                    }\r\n\r\n                    if (indent_handlebars && tag_start_char === '<') {\r\n                        // When inside an angle-bracket tag, put spaces around\r\n                        // handlebars not inside of strings.\r\n                        if ((input_char + this.input.charAt(this.pos)) === '{{') {\r\n                            input_char += this.get_unformatted('}}');\r\n                            if (content.length && content[content.length - 1] !== ' ' && content[content.length - 1] !== '<') {\r\n                                input_char = ' ' + input_char;\r\n                            }\r\n                            space = true;\r\n                        }\r\n                    }\r\n\r\n                    if (input_char === '<' && !tag_start_char) {\r\n                        tag_start = this.pos - 1;\r\n                        tag_start_char = '<';\r\n                    }\r\n\r\n                    if (indent_handlebars && !tag_start_char) {\r\n                        if (content.length >= 2 && content[content.length - 1] === '{' && content[content.length - 2] == '{') {\r\n                            if (input_char === '#' || input_char === '/') {\r\n                                tag_start = this.pos - 3;\r\n                            } else {\r\n                                tag_start = this.pos - 2;\r\n                            }\r\n                            tag_start_char = '{';\r\n                        }\r\n                    }\r\n\r\n                    this.line_char_count++;\r\n                    content.push(input_char); //inserts character at-a-time (or string)\r\n\r\n                    if (content[1] && content[1] === '!') { //if we're in a comment, do something special\r\n                        // We treat all comments as literals, even more than preformatted tags\r\n                        // we just look for the appropriate close tag\r\n                        content = [this.get_comment(tag_start)];\r\n                        break;\r\n                    }\r\n\r\n                    if (indent_handlebars && tag_start_char === '{' && content.length > 2 && content[content.length - 2] === '}' && content[content.length - 1] === '}') {\r\n                        break;\r\n                    }\r\n                } while (input_char !== '>');\r\n\r\n                var tag_complete = content.join('');\r\n                var tag_index;\r\n                var tag_offset;\r\n\r\n                if (tag_complete.indexOf(' ') !== -1) { //if there's whitespace, thats where the tag name ends\r\n                    tag_index = tag_complete.indexOf(' ');\r\n                } else if (tag_complete[0] === '{') {\r\n                    tag_index = tag_complete.indexOf('}');\r\n                } else { //otherwise go with the tag ending\r\n                    tag_index = tag_complete.indexOf('>');\r\n                }\r\n                if (tag_complete[0] === '<' || !indent_handlebars) {\r\n                    tag_offset = 1;\r\n                } else {\r\n                    tag_offset = tag_complete[2] === '#' ? 3 : 2;\r\n                }\r\n                var tag_check = tag_complete.substring(tag_offset, tag_index).toLowerCase();\r\n                if (tag_complete.charAt(tag_complete.length - 2) === '/' ||\r\n                    this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)\r\n                    if (!peek) {\r\n                        this.tag_type = 'SINGLE';\r\n                    }\r\n                } else if (indent_handlebars && tag_complete[0] === '{' && tag_check === 'else') {\r\n                    if (!peek) {\r\n                        this.indent_to_tag('if');\r\n                        this.tag_type = 'HANDLEBARS_ELSE';\r\n                        this.indent_content = true;\r\n                        this.traverse_whitespace();\r\n                    }\r\n                } else if (this.is_unformatted(tag_check, unformatted)) { // do not reformat the \"unformatted\" tags\r\n                    comment = this.get_unformatted('</' + tag_check + '>', tag_complete); //...delegate to get_unformatted function\r\n                    content.push(comment);\r\n                    tag_end = this.pos - 1;\r\n                    this.tag_type = 'SINGLE';\r\n                } else if (tag_check === 'script' &&\r\n                    (tag_complete.search('type') === -1 ||\r\n                    (tag_complete.search('type') > -1 &&\r\n                    tag_complete.search(/\\b(text|application)\\/(x-)?(javascript|ecmascript|jscript|livescript)/) > -1))) {\r\n                    if (!peek) {\r\n                        this.record_tag(tag_check);\r\n                        this.tag_type = 'SCRIPT';\r\n                    }\r\n                } else if (tag_check === 'style' &&\r\n                    (tag_complete.search('type') === -1 ||\r\n                    (tag_complete.search('type') > -1 && tag_complete.search('text/css') > -1))) {\r\n                    if (!peek) {\r\n                        this.record_tag(tag_check);\r\n                        this.tag_type = 'STYLE';\r\n                    }\r\n                } else if (tag_check.charAt(0) === '!') { //peek for <! comment\r\n                    // for comments content is already correct.\r\n                    if (!peek) {\r\n                        this.tag_type = 'SINGLE';\r\n                        this.traverse_whitespace();\r\n                    }\r\n                } else if (!peek) {\r\n                    if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending\r\n                        this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors\r\n                        this.tag_type = 'END';\r\n                    } else { //otherwise it's a start-tag\r\n                        this.record_tag(tag_check); //push it on the tag stack\r\n                        if (tag_check.toLowerCase() !== 'html') {\r\n                            this.indent_content = true;\r\n                        }\r\n                        this.tag_type = 'START';\r\n                    }\r\n\r\n                    // Allow preserving of newlines after a start or end tag\r\n                    if (this.traverse_whitespace()) {\r\n                        this.space_or_wrap(content);\r\n                    }\r\n\r\n                    if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line\r\n                        this.print_newline(false, this.output);\r\n                        if (this.output.length && this.output[this.output.length - 2] !== '\\n') {\r\n                            this.print_newline(true, this.output);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (peek) {\r\n                    this.pos = orig_pos;\r\n                    this.line_char_count = orig_line_char_count;\r\n                }\r\n\r\n                return content.join(''); //returns fully formatted tag\r\n            };\r\n\r\n            this.get_comment = function(start_pos) { //function to return comment content in its entirety\r\n                // this is will have very poor perf, but will work for now.\r\n                var comment = '',\r\n                    delimiter = '>',\r\n                    matched = false;\r\n\r\n                this.pos = start_pos;\r\n                input_char = this.input.charAt(this.pos);\r\n                this.pos++;\r\n\r\n                while (this.pos <= this.input.length) {\r\n                    comment += input_char;\r\n\r\n                    // only need to check for the delimiter if the last chars match\r\n                    if (comment[comment.length - 1] === delimiter[delimiter.length - 1] &&\r\n                        comment.indexOf(delimiter) !== -1) {\r\n                        break;\r\n                    }\r\n\r\n                    // only need to search for custom delimiter for the first few characters\r\n                    if (!matched && comment.length < 10) {\r\n                        if (comment.indexOf('<![if') === 0) { //peek for <![if conditional comment\r\n                            delimiter = '<![endif]>';\r\n                            matched = true;\r\n                        } else if (comment.indexOf('<![cdata[') === 0) { //if it's a <[cdata[ comment...\r\n                            delimiter = ']]>';\r\n                            matched = true;\r\n                        } else if (comment.indexOf('<![') === 0) { // some other ![ comment? ...\r\n                            delimiter = ']>';\r\n                            matched = true;\r\n                        } else if (comment.indexOf('<!--') === 0) { // <!-- comment ...\r\n                            delimiter = '-->';\r\n                            matched = true;\r\n                        }\r\n                    }\r\n\r\n                    input_char = this.input.charAt(this.pos);\r\n                    this.pos++;\r\n                }\r\n\r\n                return comment;\r\n            };\r\n\r\n            this.get_unformatted = function(delimiter, orig_tag) { //function to return unformatted content in its entirety\r\n\r\n                if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) !== -1) {\r\n                    return '';\r\n                }\r\n                var input_char = '';\r\n                var content = '';\r\n                var min_index = 0;\r\n                var space = true;\r\n                do {\r\n\r\n                    if (this.pos >= this.input.length) {\r\n                        return content;\r\n                    }\r\n\r\n                    input_char = this.input.charAt(this.pos);\r\n                    this.pos++;\r\n\r\n                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\r\n                        if (!space) {\r\n                            this.line_char_count--;\r\n                            continue;\r\n                        }\r\n                        if (input_char === '\\n' || input_char === '\\r') {\r\n                            content += '\\n';\r\n                            /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'\r\n                for (var i=0; i<this.indent_level; i++) {\r\n                  content += this.indent_string;\r\n                }\r\n                space = false; //...and make sure other indentation is erased\r\n                */\r\n                            this.line_char_count = 0;\r\n                            continue;\r\n                        }\r\n                    }\r\n                    content += input_char;\r\n                    this.line_char_count++;\r\n                    space = true;\r\n\r\n                    if (indent_handlebars && input_char === '{' && content.length && content[content.length - 2] === '{') {\r\n                        // Handlebars expressions in strings should also be unformatted.\r\n                        content += this.get_unformatted('}}');\r\n                        // These expressions are opaque.  Ignore delimiters found in them.\r\n                        min_index = content.length;\r\n                    }\r\n                } while (content.toLowerCase().indexOf(delimiter, min_index) === -1);\r\n                return content;\r\n            };\r\n\r\n            this.get_token = function() { //initial handler for token-retrieval\r\n                var token;\r\n\r\n                if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript\r\n                    var type = this.last_token.substr(7);\r\n                    token = this.get_contents_to(type);\r\n                    if (typeof token !== 'string') {\r\n                        return token;\r\n                    }\r\n                    return [token, 'TK_' + type];\r\n                }\r\n                if (this.current_mode === 'CONTENT') {\r\n                    token = this.get_content();\r\n                    if (typeof token !== 'string') {\r\n                        return token;\r\n                    } else {\r\n                        return [token, 'TK_CONTENT'];\r\n                    }\r\n                }\r\n\r\n                if (this.current_mode === 'TAG') {\r\n                    token = this.get_tag();\r\n                    if (typeof token !== 'string') {\r\n                        return token;\r\n                    } else {\r\n                        var tag_name_type = 'TK_TAG_' + this.tag_type;\r\n                        return [token, tag_name_type];\r\n                    }\r\n                }\r\n            };\r\n\r\n            this.get_full_indent = function(level) {\r\n                level = this.indent_level + level || 0;\r\n                if (level < 1) {\r\n                    return '';\r\n                }\r\n\r\n                return Array(level + 1).join(this.indent_string);\r\n            };\r\n\r\n            this.is_unformatted = function(tag_check, unformatted) {\r\n                //is this an HTML5 block-level link?\r\n                if (!this.Utils.in_array(tag_check, unformatted)) {\r\n                    return false;\r\n                }\r\n\r\n                if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)) {\r\n                    return true;\r\n                }\r\n\r\n                //at this point we have an  tag; is its first child something we want to remain\r\n                //unformatted?\r\n                var next_tag = this.get_tag(true /* peek. */ );\r\n\r\n                // test next_tag to see if it is just html tag (no external content)\r\n                var tag = (next_tag || \"\").match(/^\\s*<\\s*\\/?([a-z]*)\\s*[^>]*>\\s*$/);\r\n\r\n                // if next_tag comes back but is not an isolated tag, then\r\n                // let's treat the 'a' tag as having content\r\n                // and respect the unformatted option\r\n                if (!tag || this.Utils.in_array(tag, unformatted)) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            };\r\n\r\n            this.printer = function(js_source, indent_character, indent_size, wrap_line_length, brace_style) { //handles input/output and some other printing functions\r\n\r\n                this.input = js_source || ''; //gets the input for the Parser\r\n                this.output = [];\r\n                this.indent_character = indent_character;\r\n                this.indent_string = '';\r\n                this.indent_size = indent_size;\r\n                this.brace_style = brace_style;\r\n                this.indent_level = 0;\r\n                this.wrap_line_length = wrap_line_length;\r\n                this.line_char_count = 0; //count to see if wrap_line_length was exceeded\r\n\r\n                for (var i = 0; i < this.indent_size; i++) {\r\n                    this.indent_string += this.indent_character;\r\n                }\r\n\r\n                this.print_newline = function(force, arr) {\r\n                    this.line_char_count = 0;\r\n                    if (!arr || !arr.length) {\r\n                        return;\r\n                    }\r\n                    if (force || (arr[arr.length - 1] !== '\\n')) { //we might want the extra line\r\n                        if ((arr[arr.length - 1] !== '\\n')) {\r\n                            arr[arr.length - 1] = rtrim(arr[arr.length - 1]);\r\n                        }\r\n                        arr.push('\\n');\r\n                    }\r\n                };\r\n\r\n                this.print_indentation = function(arr) {\r\n                    for (var i = 0; i < this.indent_level; i++) {\r\n                        arr.push(this.indent_string);\r\n                        this.line_char_count += this.indent_string.length;\r\n                    }\r\n                };\r\n\r\n                this.print_token = function(text) {\r\n                    // Avoid printing initial whitespace.\r\n                    if (this.is_whitespace(text) && !this.output.length) {\r\n                        return;\r\n                    }\r\n                    if (text || text !== '') {\r\n                        if (this.output.length && this.output[this.output.length - 1] === '\\n') {\r\n                            this.print_indentation(this.output);\r\n                            text = ltrim(text);\r\n                        }\r\n                    }\r\n                    this.print_token_raw(text);\r\n                };\r\n\r\n                this.print_token_raw = function(text) {\r\n                    // If we are going to print newlines, truncate trailing\r\n                    // whitespace, as the newlines will represent the space.\r\n                    if (this.newlines > 0) {\r\n                        text = rtrim(text);\r\n                    }\r\n\r\n                    if (text && text !== '') {\r\n                        if (text.length > 1 && text[text.length - 1] === '\\n') {\r\n                            // unformatted tags can grab newlines as their last character\r\n                            this.output.push(text.slice(0, -1));\r\n                            this.print_newline(false, this.output);\r\n                        } else {\r\n                            this.output.push(text);\r\n                        }\r\n                    }\r\n\r\n                    for (var n = 0; n < this.newlines; n++) {\r\n                        this.print_newline(n > 0, this.output);\r\n                    }\r\n                    this.newlines = 0;\r\n                };\r\n\r\n                this.indent = function() {\r\n                    this.indent_level++;\r\n                };\r\n\r\n                this.unindent = function() {\r\n                    if (this.indent_level > 0) {\r\n                        this.indent_level--;\r\n                    }\r\n                };\r\n            };\r\n            return this;\r\n        }\r\n\r\n        /*_____________________--------------------_____________________*/\r\n\r\n        multi_parser = new Parser(); //wrapping functions Parser\r\n        multi_parser.printer(html_source, indent_character, indent_size, wrap_line_length, brace_style); //initialize starting values\r\n\r\n        while (true) {\r\n            var t = multi_parser.get_token();\r\n            multi_parser.token_text = t[0];\r\n            multi_parser.token_type = t[1];\r\n\r\n            if (multi_parser.token_type === 'TK_EOF') {\r\n                break;\r\n            }\r\n\r\n            switch (multi_parser.token_type) {\r\n                case 'TK_TAG_START':\r\n                    multi_parser.print_newline(false, multi_parser.output);\r\n                    multi_parser.print_token(multi_parser.token_text);\r\n                    if (multi_parser.indent_content) {\r\n                        multi_parser.indent();\r\n                        multi_parser.indent_content = false;\r\n                    }\r\n                    multi_parser.current_mode = 'CONTENT';\r\n                    break;\r\n                case 'TK_TAG_STYLE':\r\n                case 'TK_TAG_SCRIPT':\r\n                    multi_parser.print_newline(false, multi_parser.output);\r\n                    multi_parser.print_token(multi_parser.token_text);\r\n                    multi_parser.current_mode = 'CONTENT';\r\n                    break;\r\n                case 'TK_TAG_END':\r\n                    //Print new line only if the tag has no content and has child\r\n                    if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {\r\n                        var tag_name = multi_parser.token_text.match(/\\w+/)[0];\r\n                        var tag_extracted_from_last_output = null;\r\n                        if (multi_parser.output.length) {\r\n                            tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/(?:<|{{#)\\s*(\\w+)/);\r\n                        }\r\n                        if (tag_extracted_from_last_output === null ||\r\n                            tag_extracted_from_last_output[1] !== tag_name) {\r\n                            multi_parser.print_newline(false, multi_parser.output);\r\n                        }\r\n                    }\r\n                    multi_parser.print_token(multi_parser.token_text);\r\n                    multi_parser.current_mode = 'CONTENT';\r\n                    break;\r\n                case 'TK_TAG_SINGLE':\r\n                    // Don't add a newline before elements that should remain unformatted.\r\n                    var tag_check = multi_parser.token_text.match(/^\\s*<([a-z-]+)/i);\r\n                    if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {\r\n                        multi_parser.print_newline(false, multi_parser.output);\r\n                    }\r\n                    multi_parser.print_token(multi_parser.token_text);\r\n                    multi_parser.current_mode = 'CONTENT';\r\n                    break;\r\n                case 'TK_TAG_HANDLEBARS_ELSE':\r\n                    multi_parser.print_token(multi_parser.token_text);\r\n                    if (multi_parser.indent_content) {\r\n                        multi_parser.indent();\r\n                        multi_parser.indent_content = false;\r\n                    }\r\n                    multi_parser.current_mode = 'CONTENT';\r\n                    break;\r\n                case 'TK_CONTENT':\r\n                    multi_parser.print_token(multi_parser.token_text);\r\n                    multi_parser.current_mode = 'TAG';\r\n                    break;\r\n                case 'TK_STYLE':\r\n                case 'TK_SCRIPT':\r\n                    if (multi_parser.token_text !== '') {\r\n                        multi_parser.print_newline(false, multi_parser.output);\r\n                        var text = multi_parser.token_text,\r\n                            _beautifier,\r\n                            script_indent_level = 1;\r\n                        if (multi_parser.token_type === 'TK_SCRIPT') {\r\n                            _beautifier = typeof js_beautify === 'function' && js_beautify;\r\n                        } else if (multi_parser.token_type === 'TK_STYLE') {\r\n                            _beautifier = typeof css_beautify === 'function' && css_beautify;\r\n                        }\r\n\r\n                        if (options.indent_scripts === \"keep\") {\r\n                            script_indent_level = 0;\r\n                        } else if (options.indent_scripts === \"separate\") {\r\n                            script_indent_level = -multi_parser.indent_level;\r\n                        }\r\n\r\n                        var indentation = multi_parser.get_full_indent(script_indent_level);\r\n                        if (_beautifier) {\r\n                            // call the Beautifier if avaliable\r\n                            text = _beautifier(text.replace(/^\\s*/, indentation), options);\r\n                        } else {\r\n                            // simply indent the string otherwise\r\n                            var white = text.match(/^\\s*/)[0];\r\n                            var _level = white.match(/[^\\n\\r]*$/)[0].split(multi_parser.indent_string).length - 1;\r\n                            var reindent = multi_parser.get_full_indent(script_indent_level - _level);\r\n                            text = text.replace(/^\\s*/, indentation)\r\n                                .replace(/\\r\\n|\\r|\\n/g, '\\n' + reindent)\r\n                                .replace(/\\s+$/, '');\r\n                        }\r\n                        if (text) {\r\n                            multi_parser.print_token_raw(text);\r\n                            multi_parser.print_newline(true, multi_parser.output);\r\n                        }\r\n                    }\r\n                    multi_parser.current_mode = 'TAG';\r\n                    break;\r\n                default:\r\n                    // We should not be getting here but we don't want to drop input on the floor\r\n                    // Just output the text and move on\r\n                    if (multi_parser.token_text !== '') {\r\n                        multi_parser.print_token(multi_parser.token_text);\r\n                    }\r\n                    break;\r\n            }\r\n            multi_parser.last_token = multi_parser.token_type;\r\n            multi_parser.last_text = multi_parser.token_text;\r\n        }\r\n        var sweet_code = multi_parser.output.join('').replace(/[\\r\\n\\t ]+$/, '');\r\n        if (end_with_newline) {\r\n            sweet_code += '\\n';\r\n        }\r\n        return sweet_code;\r\n    }\r\n\r\n\r\n    return {\r\n      html_beautify: function(html_source, options) {\r\n        return style_html(html_source, options, beautifyJs, beautifyCss);\r\n      }\r\n    };\r\n\r\n});\r\n"]}