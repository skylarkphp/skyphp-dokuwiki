{"version":3,"sources":["util.js"],"names":["define","langx","Xhr","seqRunner","index","params","arr","errors","callback","err","res","push","length","apply","this","arguments","defaultModemap","html","css","js","less","styl","coffee","fetch","url","get","then","e","seq","log","console","getMode","type","file","customModemap","modemap","mixin","key","keyLength","slice"],"mappings":";;;;;;;AAAAA,QACI,sBACA,wBACF,SAAUC,EAAMC,GACd,aAyCA,SAASC,EAAUC,EAAOC,EAAQC,EAAKC,EAAQC,GAC3CF,EAAIF,GAAOC,EAdf,SAAqBD,EAAOC,EAAQC,EAAKC,EAAQC,GAC7C,OAAO,SAAUC,EAAKC,GACdD,GACAF,EAAOI,KAAKF,KAEhBL,EACYE,EAAIM,OACZT,EAAUC,EAAOM,EAAKJ,EAAKC,EAAQC,GAEnCA,EAASD,EAAQG,KAKMG,MAAMC,KAAMC,YAe/C,IAAIC,GACAC,KAAQ,OACRC,IAAO,MACPC,GAAM,aACNC,KAAQ,OACRC,KAAQ,SACRC,OAAU,gBAiBd,OACIC,MA/EJ,SAAeC,EAAKhB,GAiBhBN,EAAIuB,IAAID,GAAKE,KACT,SAAShB,GACLF,EAAS,KAAKE,IAElB,SAASiB,GACLnB,EAASmB,MA0DjBC,IAtCJ,SAAatB,EAAKD,EAAQG,EAAW,cAEjC,IAAID,KACJ,IAAKD,EAAIM,OACL,OAAOJ,EAASD,EAAQF,GAE5BF,EAAU,EAAGE,EAAQC,EAAKC,EAAQC,IAiClCqB,IA/BJ,WACIC,QAAQD,IAAId,YA+BZgB,QAnBJ,SAAiBC,EAAO,GAAIC,EAAO,GAAIC,MACnC,IAAIC,EAAUlC,EAAMmC,SAAUpB,EAAekB,GAC7C,IAAK,IAAIG,KAAOF,EAAS,CACrB,IAAIG,EAAYD,EAAIzB,OACpB,GAAIqB,EAAKM,OAAOD,OAAiB,IAAMD,EACnC,OAAOF,EAAQE,GAGvB,IAAK,IAAIA,KAAOF,EACZ,GAAIH,IAASK,EACT,OAAOF,EAAQE,GAGvB,OAAOL","file":"../util.js","sourcesContent":["define([\n    \"skylark-langx/langx\",\n    \"skylark-net-http/Xhr\"\n],function (langx,Xhr) {\n    'use strict';\n\n    function fetch(url, callback) {\n        /*\n        var xhr = new window.XMLHttpRequest();\n        xhr.open('GET', url);\n        xhr.responseType = 'text';\n        xhr.onload = function () {\n            if (xhr.status === 200) {\n                callback(null, xhr.responseText);\n            } else {\n                callback(url, xhr);\n            }\n        };\n        xhr.onerror = function (err) {\n            callback(err);\n        };\n        xhr.send();\n        */\n        Xhr.get(url).then(\n            function(res) {\n                callback(null,res);\n            },\n            function(e){\n                callback(e);\n            }\n        )\n    }\n    function runCallback(index, params, arr, errors, callback) {\n        return function (err, res) {\n            if (err) {\n                errors.push(err);\n            }\n            index++;\n            if (index < arr.length) {\n                seqRunner(index, res, arr, errors, callback);\n            } else {\n                callback(errors, res);\n            }\n        };\n    }\n    function seqRunner(index, params, arr, errors, callback) {\n        arr[index](params, runCallback.apply(this, arguments));\n    }\n    function seq(arr, params, callback = function () {\n    }) {\n        var errors = [];\n        if (!arr.length) {\n            return callback(errors, params);\n        }\n        seqRunner(0, params, arr, errors, callback);\n    }\n    function log() {\n        console.log(arguments);\n    }\n\n\n    var defaultModemap = {\n        'html': 'html',\n        'css': 'css',\n        'js': 'javascript',\n        'less': 'less',\n        'styl': 'stylus',\n        'coffee': 'coffeescript'\n    };\n    function getMode(type = '', file = '', customModemap = {}) {\n        var modemap = langx.mixin({}, defaultModemap,customModemap);\n        for (let key in modemap) {\n            let keyLength = key.length;\n            if (file.slice(-keyLength++) === '.' + key) {\n                return modemap[key];\n            }\n        }\n        for (let key in modemap) {\n            if (type === key) {\n                return modemap[key];\n            }\n        }\n        return type;\n    }\n    return {\n        fetch,\n        seq,\n        log,\n        getMode\n    };\n});"]}