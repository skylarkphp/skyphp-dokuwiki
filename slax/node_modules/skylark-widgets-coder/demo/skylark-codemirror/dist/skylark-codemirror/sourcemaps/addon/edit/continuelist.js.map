{"version":3,"sources":["addon/edit/continuelist.js"],"names":["define","CodeMirror","listRE","emptyListRE","unorderedListRE","incrementRemainingMarkdownListNumbers","cm","pos","startLine","line","lookAhead","skipCount","startItem","exec","getLine","startIndent","nextLineNumber","nextLine","nextItem","nextIndent","newNumber","parseInt","nextNumber","itemNumber","isNaN","length","replaceRange","replace","ch","commands","newlineAndIndentContinueMarkdownList","getOption","Pass","ranges","listSelections","replacements","i","head","eolState","getStateAfter","inner","getMode","innerMode","mode","name","execCommand","inList","state","list","inQuote","quote","match","cursorBeforeBullet","test","slice","empty","indent","after","numbered","indexOf","bullet","replaceSelections"],"mappings":";;;;;;;AAGAA,QAAQ,oBAAqB,SAASC,GACpC,aAEA,IAAIC,EAAS,2DACTC,EAAc,sDACdC,EAAkB,UAiDtB,SAASC,EAAsCC,EAAIC,GACjD,IAAIC,EAAYD,EAAIE,KAAMC,EAAY,EAAGC,EAAY,EACjDC,EAAYV,EAAOW,KAAKP,EAAGQ,QAAQN,IAAaO,EAAcH,EAAU,GAE5E,EAAG,CAED,IAAII,EAAiBR,GADrBE,GAAa,GAETO,EAAWX,EAAGQ,QAAQE,GAAiBE,EAAWhB,EAAOW,KAAKI,GAElE,GAAIC,EAAU,CACZ,IAAIC,EAAaD,EAAS,GACtBE,EAAaC,SAAST,EAAU,GAAI,IAAMF,EAAYC,EACtDW,EAAcD,SAASH,EAAS,GAAI,IAAMK,EAAaD,EAE3D,GAAIP,IAAgBI,GAAeK,MAAMF,GAUlC,CACL,GAAIP,EAAYU,OAASN,EAAWM,OAAQ,OAG5C,GAAKV,EAAYU,OAASN,EAAWM,QAA0B,IAAdf,EAAkB,OACnEC,GAAa,OAdTS,IAAcE,IAAYC,EAAaD,EAAa,GACpDF,EAAYE,IAAYC,EAAaH,EAAY,GACrDd,EAAGoB,aACDT,EAASU,QAAQzB,EAAQiB,EAAaI,EAAaL,EAAS,GAAKA,EAAS,KAE1ET,KAAMO,EAAgBY,GAAI,IAE1BnB,KAAMO,EAAgBY,GAAIX,EAASQ,gBAUlCP,GA/EXjB,EAAW4B,SAASC,qCAAuC,SAASxB,GAClE,GAAIA,EAAGyB,UAAU,gBAAiB,OAAO9B,EAAW+B,KAEpD,IADA,IAAIC,EAAS3B,EAAG4B,iBAAkBC,KACzBC,EAAI,EAAGA,EAAIH,EAAOR,OAAQW,IAAK,CACtC,IAAI7B,EAAM0B,EAAOG,GAAGC,KAGhBC,EAAWhC,EAAGiC,cAAchC,EAAIE,MAChC+B,EAAQlC,EAAGmC,UAAUC,UAAUJ,GACnC,GAAwB,aAApBE,EAAMG,KAAKC,KAEb,YADAtC,EAAGuC,YAAY,oBAMjB,IAAIC,GAA2B,KAH7BR,EAAWE,EAAMO,OAGGC,KAClBC,EAA6B,IAAnBX,EAASY,MAEnBzC,EAAOH,EAAGQ,QAAQP,EAAIE,MAAO0C,EAAQjD,EAAOW,KAAKJ,GACjD2C,EAAqB,QAAQC,KAAK5C,EAAK6C,MAAM,EAAG/C,EAAIqB,KACxD,IAAKK,EAAOG,GAAGmB,UAAaT,IAAWG,IAAaE,GAASC,EAE3D,YADA9C,EAAGuC,YAAY,oBAGjB,GAAI1C,EAAYkD,KAAK5C,GACd,QAAQ4C,KAAK5C,IAAOH,EAAGoB,aAAa,IACvCjB,KAAMF,EAAIE,KAAMmB,GAAI,IAEpBnB,KAAMF,EAAIE,KAAMmB,GAAIrB,EAAIqB,GAAK,IAE/BO,EAAaC,GAAK,SACb,CACL,IAAIoB,EAASL,EAAM,GAAIM,EAAQN,EAAM,GACjCO,IAAatD,EAAgBiD,KAAKF,EAAM,KAAOA,EAAM,GAAGQ,QAAQ,MAAQ,GACxEC,EAASF,EAAYrC,SAAS8B,EAAM,GAAI,IAAM,EAAKA,EAAM,GAAKA,EAAM,GAAGxB,QAAQ,IAAK,KACxFQ,EAAaC,GAAK,KAAOoB,EAASI,EAASH,EAEvCC,GAAUrD,EAAsCC,EAAIC,IAI5DD,EAAGuD,kBAAkB1B","file":"../../../addon/edit/continuelist.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\ndefine([\"../../CodeMirror\"], function(CodeMirror) {\n  \"use strict\";\n\n  var listRE = /^(\\s*)(>[> ]*|[*+-] \\[[x ]\\]\\s|[*+-]\\s|(\\d+)([.)]))(\\s*)/,\n      emptyListRE = /^(\\s*)(>[> ]*|[*+-] \\[[x ]\\]|[*+-]|(\\d+)[.)])(\\s*)$/,\n      unorderedListRE = /[*+-]\\s/;\n\n  CodeMirror.commands.newlineAndIndentContinueMarkdownList = function(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    var ranges = cm.listSelections(), replacements = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var pos = ranges[i].head;\n\n      // If we're not in Markdown mode, fall back to normal newlineAndIndent\n      var eolState = cm.getStateAfter(pos.line);\n      var inner = cm.getMode().innerMode(eolState);\n      if (inner.mode.name !== \"markdown\") {\n        cm.execCommand(\"newlineAndIndent\");\n        return;\n      } else {\n        eolState = inner.state;\n      }\n\n      var inList = eolState.list !== false;\n      var inQuote = eolState.quote !== 0;\n\n      var line = cm.getLine(pos.line), match = listRE.exec(line);\n      var cursorBeforeBullet = /^\\s*$/.test(line.slice(0, pos.ch));\n      if (!ranges[i].empty() || (!inList && !inQuote) || !match || cursorBeforeBullet) {\n        cm.execCommand(\"newlineAndIndent\");\n        return;\n      }\n      if (emptyListRE.test(line)) {\n        if (!/>\\s*$/.test(line)) cm.replaceRange(\"\", {\n          line: pos.line, ch: 0\n        }, {\n          line: pos.line, ch: pos.ch + 1\n        });\n        replacements[i] = \"\\n\";\n      } else {\n        var indent = match[1], after = match[5];\n        var numbered = !(unorderedListRE.test(match[2]) || match[2].indexOf(\">\") >= 0);\n        var bullet = numbered ? (parseInt(match[3], 10) + 1) + match[4] : match[2].replace(\"x\", \" \");\n        replacements[i] = \"\\n\" + indent + bullet + after;\n\n        if (numbered) incrementRemainingMarkdownListNumbers(cm, pos);\n      }\n    }\n\n    cm.replaceSelections(replacements);\n  };\n\n  // Auto-updating Markdown list numbers when a new item is added to the\n  // middle of a list\n  function incrementRemainingMarkdownListNumbers(cm, pos) {\n    var startLine = pos.line, lookAhead = 0, skipCount = 0;\n    var startItem = listRE.exec(cm.getLine(startLine)), startIndent = startItem[1];\n\n    do {\n      lookAhead += 1;\n      var nextLineNumber = startLine + lookAhead;\n      var nextLine = cm.getLine(nextLineNumber), nextItem = listRE.exec(nextLine);\n\n      if (nextItem) {\n        var nextIndent = nextItem[1];\n        var newNumber = (parseInt(startItem[3], 10) + lookAhead - skipCount);\n        var nextNumber = (parseInt(nextItem[3], 10)), itemNumber = nextNumber;\n\n        if (startIndent === nextIndent && !isNaN(nextNumber)) {\n          if (newNumber === nextNumber) itemNumber = nextNumber + 1;\n          if (newNumber > nextNumber) itemNumber = newNumber + 1;\n          cm.replaceRange(\n            nextLine.replace(listRE, nextIndent + itemNumber + nextItem[4] + nextItem[5]),\n          {\n            line: nextLineNumber, ch: 0\n          }, {\n            line: nextLineNumber, ch: nextLine.length\n          });\n        } else {\n          if (startIndent.length > nextIndent.length) return;\n          // This doesn't run if the next line immediatley indents, as it is\n          // not clear of the users intention (new indented item or same level)\n          if ((startIndent.length < nextIndent.length) && (lookAhead === 1)) return;\n          skipCount += 1;\n        }\n      }\n    } while (nextItem);\n  }\n});\n"]}