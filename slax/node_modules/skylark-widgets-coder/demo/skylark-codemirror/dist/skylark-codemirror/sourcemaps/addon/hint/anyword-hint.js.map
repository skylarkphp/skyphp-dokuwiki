{"version":3,"sources":["addon/hint/anyword-hint.js"],"names":["define","CodeMirror","WORD","registerHelper","editor","options","word","range","cur","getCursor","curLine","getLine","line","end","ch","start","test","charAt","curWord","slice","list","seen","re","RegExp","source","dir","endLine","Math","min","max","firstLine","lastLine","m","text","exec","lastIndexOf","Object","prototype","hasOwnProperty","call","push","from","Pos","to"],"mappings":";;;;;;;AAGAA,QAAQ,oBAAqB,SAASC,GACpC,aAEA,IAAIC,EAAO,SAEXD,EAAWE,eAAe,OAAQ,UAAW,SAASC,EAAQC,GAK5D,IAJA,IAAIC,EAAOD,GAAWA,EAAQC,MAAQJ,EAClCK,EAAQF,GAAWA,EAAQE,OAJJ,IAKvBC,EAAMJ,EAAOK,YAAaC,EAAUN,EAAOO,QAAQH,EAAII,MACvDC,EAAML,EAAIM,GAAIC,EAAQF,EACnBE,GAAST,EAAKU,KAAKN,EAAQO,OAAOF,EAAQ,OAAOA,EAKxD,IAJA,IAAIG,EAAUH,GAASF,GAAOH,EAAQS,MAAMJ,EAAOF,GAE/CO,EAAOf,GAAWA,EAAQe,SAAYC,KACtCC,EAAK,IAAIC,OAAOjB,EAAKkB,OAAQ,KACxBC,GAAO,EAAGA,GAAO,EAAGA,GAAO,EAElC,IADA,IAAIb,EAAOJ,EAAII,KAAMc,EAAUC,KAAKC,IAAID,KAAKE,IAAIjB,EAAOa,EAAMlB,EAAOH,EAAO0B,aAAc1B,EAAO2B,YAAcN,EACxGb,GAAQc,EAASd,GAAQa,EAE9B,IADA,IAAiCO,EAA7BC,EAAO7B,EAAOO,QAAQC,GACnBoB,EAAIV,EAAGY,KAAKD,IACbrB,GAAQJ,EAAII,MAAQoB,EAAE,KAAOd,GAC3BA,GAA2C,GAAhCc,EAAE,GAAGG,YAAYjB,EAAS,IAAakB,OAAOC,UAAUC,eAAeC,KAAKlB,EAAMW,EAAE,MACnGX,EAAKW,EAAE,KAAM,EACbZ,EAAKoB,KAAKR,EAAE,KAKpB,OAAQZ,KAAMA,EAAMqB,KAAMxC,EAAWyC,IAAIlC,EAAII,KAAMG,GAAQ4B,GAAI1C,EAAWyC,IAAIlC,EAAII,KAAMC","file":"../../../addon/hint/anyword-hint.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\ndefine([\"../../CodeMirror\"], function(CodeMirror) {\n  \"use strict\";\n\n  var WORD = /[\\w$]+/, RANGE = 500;\n\n  CodeMirror.registerHelper(\"hint\", \"anyword\", function(editor, options) {\n    var word = options && options.word || WORD;\n    var range = options && options.range || RANGE;\n    var cur = editor.getCursor(), curLine = editor.getLine(cur.line);\n    var end = cur.ch, start = end;\n    while (start && word.test(curLine.charAt(start - 1))) --start;\n    var curWord = start != end && curLine.slice(start, end);\n\n    var list = options && options.list || [], seen = {};\n    var re = new RegExp(word.source, \"g\");\n    for (var dir = -1; dir <= 1; dir += 2) {\n      var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir;\n      for (; line != endLine; line += dir) {\n        var text = editor.getLine(line), m;\n        while (m = re.exec(text)) {\n          if (line == cur.line && m[0] === curWord) continue;\n          if ((!curWord || m[0].lastIndexOf(curWord, 0) == 0) && !Object.prototype.hasOwnProperty.call(seen, m[0])) {\n            seen[m[0]] = true;\n            list.push(m[0]);\n          }\n        }\n      }\n    }\n    return {list: list, from: CodeMirror.Pos(cur.line, start), to: CodeMirror.Pos(cur.line, end)};\n  });\n});\n"]}