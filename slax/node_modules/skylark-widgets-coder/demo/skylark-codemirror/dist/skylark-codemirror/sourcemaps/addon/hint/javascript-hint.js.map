{"version":3,"sources":["addon/hint/javascript-hint.js"],"names":["define","CodeMirror","Pos","forEach","arr","f","i","e","length","scriptHint","editor","keywords","getToken","options","cur","getCursor","token","test","type","innerMode","getMode","state","mode","helperType","string","end","ch","slice","start","tprop","line","context","push","list","found","global","globalScope","window","maybeAdd","str","lastIndexOf","item","Array","prototype","indexOf","arrayContains","gatherCompletions","obj","stringProps","arrayProps","Function","funcProps","callback","Object","getOwnPropertyNames","getPrototypeOf","o","name","forAllProps","base","pop","additionalContext","useGlobalScope","jQuery","_","v","localVars","next","globalVars","getCompletions","from","to","getCoffeeScriptToken","getTokenAt","charAt","replace","registerHelper","javascriptKeywords","coffeescriptKeywords","split"],"mappings":"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","file":"../../../addon/hint/javascript-hint.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\ndefine([\"../../CodeMirror\"], function(CodeMirror) {\n  var Pos = CodeMirror.Pos;\n\n  function forEach(arr, f) {\n    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);\n  }\n\n  function arrayContains(arr, item) {\n    if (!Array.prototype.indexOf) {\n      var i = arr.length;\n      while (i--) {\n        if (arr[i] === item) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return arr.indexOf(item) != -1;\n  }\n\n  function scriptHint(editor, keywords, getToken, options) {\n    // Find the token at the cursor\n    var cur = editor.getCursor(), token = getToken(editor, cur);\n    if (/\\b(?:string|comment)\\b/.test(token.type)) return;\n    var innerMode = CodeMirror.innerMode(editor.getMode(), token.state);\n    if (innerMode.mode.helperType === \"json\") return;\n    token.state = innerMode.state;\n\n    // If it's not a 'word-style' token, ignore the token.\n    if (!/^[\\w$_]*$/.test(token.string)) {\n      token = {start: cur.ch, end: cur.ch, string: \"\", state: token.state,\n               type: token.string == \".\" ? \"property\" : null};\n    } else if (token.end > cur.ch) {\n      token.end = cur.ch;\n      token.string = token.string.slice(0, cur.ch - token.start);\n    }\n\n    var tprop = token;\n    // If it is a property, find out what it is a property of.\n    while (tprop.type == \"property\") {\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (tprop.string != \".\") return;\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (!context) var context = [];\n      context.push(tprop);\n    }\n    return {list: getCompletions(token, context, keywords, options),\n            from: Pos(cur.line, token.start),\n            to: Pos(cur.line, token.end)};\n  }\n\n  function javascriptHint(editor, options) {\n    return scriptHint(editor, javascriptKeywords,\n                      function (e, cur) {return e.getTokenAt(cur);},\n                      options);\n  };\n  CodeMirror.registerHelper(\"hint\", \"javascript\", javascriptHint);\n\n  function getCoffeeScriptToken(editor, cur) {\n  // This getToken, it is for coffeescript, imitates the behavior of\n  // getTokenAt method in javascript.js, that is, returning \"property\"\n  // type and treat \".\" as indepenent token.\n    var token = editor.getTokenAt(cur);\n    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {\n      token.end = token.start;\n      token.string = '.';\n      token.type = \"property\";\n    }\n    else if (/^\\.[\\w$_]*$/.test(token.string)) {\n      token.type = \"property\";\n      token.start++;\n      token.string = token.string.replace(/\\./, '');\n    }\n    return token;\n  }\n\n  function coffeescriptHint(editor, options) {\n    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);\n  }\n  CodeMirror.registerHelper(\"hint\", \"coffeescript\", coffeescriptHint);\n\n  var stringProps = (\"charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight \" +\n                     \"toUpperCase toLowerCase split concat match replace search\").split(\" \");\n  var arrayProps = (\"length concat join splice push pop shift unshift slice reverse sort indexOf \" +\n                    \"lastIndexOf every some filter forEach map reduce reduceRight \").split(\" \");\n  var funcProps = \"prototype apply call bind\".split(\" \");\n  var javascriptKeywords = (\"break case catch class const continue debugger default delete do else export extends false finally for function \" +\n                  \"if in import instanceof new null return super switch this throw true try typeof var void while with yield\").split(\" \");\n  var coffeescriptKeywords = (\"and break catch class continue delete do else extends false finally for \" +\n                  \"if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes\").split(\" \");\n\n  function forAllProps(obj, callback) {\n    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\n      for (var name in obj) callback(name)\n    } else {\n      for (var o = obj; o; o = Object.getPrototypeOf(o))\n        Object.getOwnPropertyNames(o).forEach(callback)\n    }\n  }\n\n  function getCompletions(token, context, keywords, options) {\n    var found = [], start = token.string, global = options && options.globalScope || window;\n    function maybeAdd(str) {\n      if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);\n    }\n    function gatherCompletions(obj) {\n      if (typeof obj == \"string\") forEach(stringProps, maybeAdd);\n      else if (obj instanceof Array) forEach(arrayProps, maybeAdd);\n      else if (obj instanceof Function) forEach(funcProps, maybeAdd);\n      forAllProps(obj, maybeAdd)\n    }\n\n    if (context && context.length) {\n      // If this is a property, see if it belongs to some object we can\n      // find in the current environment.\n      var obj = context.pop(), base;\n      if (obj.type && obj.type.indexOf(\"variable\") === 0) {\n        if (options && options.additionalContext)\n          base = options.additionalContext[obj.string];\n        if (!options || options.useGlobalScope !== false)\n          base = base || global[obj.string];\n      } else if (obj.type == \"string\") {\n        base = \"\";\n      } else if (obj.type == \"atom\") {\n        base = 1;\n      } else if (obj.type == \"function\") {\n        if (global.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') &&\n            (typeof global.jQuery == 'function'))\n          base = global.jQuery();\n        else if (global._ != null && (obj.string == '_') && (typeof global._ == 'function'))\n          base = global._();\n      }\n      while (base != null && context.length)\n        base = base[context.pop().string];\n      if (base != null) gatherCompletions(base);\n    } else {\n      // If not, just look in the global object and any local scope\n      // (reading into JS mode internals to get at the local and global variables)\n      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);\n      for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);\n      if (!options || options.useGlobalScope !== false)\n        gatherCompletions(global);\n      forEach(keywords, maybeAdd);\n    }\n    return found;\n  }\n});\n"]}