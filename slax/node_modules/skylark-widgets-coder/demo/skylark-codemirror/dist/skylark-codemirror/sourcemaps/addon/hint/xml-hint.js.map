{"version":3,"sources":["addon/hint/xml-hint.js"],"names":["define","CodeMirror","Pos","matches","hint","typed","matchInMiddle","indexOf","lastIndexOf","registerHelper","cm","options","tags","schemaInfo","quote","quoteChar","cur","getCursor","token","getTokenAt","end","ch","string","slice","start","inner","innerMode","getMode","state","mode","name","prefix","tagStart","result","replaceToken","tag","test","type","tagName","before","getLine","line","Math","max","tagType","cx","context","curTag","childList","children","i","length","push","hasOwnProperty","attrs","globalAttrs","set","nm","atValues","atName","getRange","match","call","this","n","charAt","len","substr","attr","list","from","to"],"mappings":";;;;;;;AAGAA,QAAQ,oBAAqB,SAASC,GACpC,aAEA,IAAIC,EAAMD,EAAWC,IAErB,SAASC,EAAQC,EAAMC,EAAOC,GAC5B,OAAIA,EAAsBF,EAAKG,QAAQF,IAAU,EACP,GAA9BD,EAAKI,YAAYH,EAAO,GAiGtCJ,EAAWQ,eAAe,OAAQ,MA9FlC,SAAkBC,EAAIC,GACpB,IAAIC,EAAOD,GAAWA,EAAQE,WAC1BC,EAASH,GAAWA,EAAQI,WAAc,IAC1CT,EAAgBK,GAAWA,EAAQL,cACvC,GAAKM,EAAL,CACA,IAAII,EAAMN,EAAGO,YAAaC,EAAQR,EAAGS,WAAWH,GAC5CE,EAAME,IAAMJ,EAAIK,KAClBH,EAAME,IAAMJ,EAAIK,GAChBH,EAAMI,OAASJ,EAAMI,OAAOC,MAAM,EAAGP,EAAIK,GAAKH,EAAMM,QAEtD,IAAIC,EAAQxB,EAAWyB,UAAUhB,EAAGiB,UAAWT,EAAMU,OACrD,GAAuB,OAAnBH,EAAMI,KAAKC,KAAf,CACA,IAAuCC,EAEQC,EAF3CC,KAAaC,GAAe,EAC5BC,EAAM,UAAUC,KAAKlB,EAAMmB,QAAU,KAAKD,KAAKlB,EAAMI,QACrDgB,EAAUH,GAAO,MAAMC,KAAKlB,EAAMI,QAEtC,GAAIgB,EAAS,CACX,IAAIC,EAAS7B,EAAG8B,QAAQxB,EAAIyB,MAAMlB,MAAMmB,KAAKC,IAAI,EAAGzB,EAAMM,MAAQ,GAAIN,EAAMM,OACxEoB,EAAU,OAAOR,KAAKG,GAAU,QAAU,KAAKH,KAAKG,GAAU,OAAS,KACvEK,IAASZ,EAAWd,EAAMM,OAAoB,SAAXoB,EAAqB,EAAI,SACvDT,GAAuB,KAAhBjB,EAAMI,OACtBsB,EAAU,OACDT,GAAuB,MAAhBjB,EAAMI,SACtBsB,EAAU,SAGZ,IAAKT,IAAQV,EAAMG,MAAMU,SAAWM,EAAS,CACvCN,IACFP,EAASb,EAAMI,QACjBY,EAAeU,EACf,IAAIC,EAAKpB,EAAMG,MAAMkB,QAASC,EAASF,GAAMjC,EAAKiC,EAAGP,SACjDU,EAAYH,EAAKE,GAAUA,EAAOE,SAAWrC,EAAK,QACtD,GAAIoC,GAAwB,SAAXJ,EACf,IAAK,IAAIM,EAAI,EAAGA,EAAIF,EAAUG,SAAUD,EAAQnB,IAAU5B,EAAQ6C,EAAUE,GAAInB,EAAQzB,IACtF2B,EAAOmB,KAAK,IAAMJ,EAAUE,SACzB,GAAe,SAAXN,EACT,IAAK,IAAId,KAAQlB,GACXA,EAAKyC,eAAevB,IAAiB,QAARA,GAA0B,UAARA,GAAsBC,IAAU5B,EAAQ2B,EAAMC,EAAQzB,IACvG2B,EAAOmB,KAAK,IAAMtB,GAEpBe,KAAQd,GAAqB,SAAXa,GAAsBzC,EAAQ0C,EAAGP,QAASP,EAAQzB,KACtE2B,EAAOmB,KAAK,KAAOP,EAAGP,QAAU,SAC7B,CAEL,IAAwCgB,GAApCP,EAASnC,EAAKa,EAAMG,MAAMU,WAA4BS,EAAOO,MAC7DC,EAAc3C,EAAK,UACvB,IAAK0C,IAAUC,EAAa,OAC5B,GAAKD,GAEE,GAAIC,EAAa,CACtB,IAAIC,KACJ,IAAK,IAAIC,KAAMF,EAAiBA,EAAYF,eAAeI,KAAKD,EAAIC,GAAMF,EAAYE,IACtF,IAAK,IAAIA,KAAMH,EAAWA,EAAMD,eAAeI,KAAKD,EAAIC,GAAMH,EAAMG,IACpEH,EAAQE,QALRF,EAAQC,EAOV,GAAkB,UAAdrC,EAAMmB,MAAoC,KAAhBnB,EAAMI,OAAe,CACjD,IAEsDoC,EAAlDC,GAFApB,EAAS7B,EAAGkD,SAAS1D,EAAIc,EAAIyB,KAAMC,KAAKC,IAAI,EAAG3B,EAAIK,GAAK,KACnCnB,EAAIc,EAAIyB,KAAoB,UAAdvB,EAAMmB,KAAmBnB,EAAMM,MAAQN,EAAME,OAChEyC,MAAM,2BAC1B,IAAKF,IAAWL,EAAMD,eAAeM,EAAO,OAASD,EAAWJ,EAAMK,EAAO,KAAM,OAEnF,GADuB,mBAAZD,IAAwBA,EAAWA,EAASI,KAAKC,KAAMrD,IAChD,UAAdQ,EAAMmB,KAAkB,CAC1BN,EAASb,EAAMI,OACf,IAAI0C,EAAI,EACJ,OAAO5B,KAAKlB,EAAMI,OAAO2C,OAAO,MAClCnD,EAAQI,EAAMI,OAAO2C,OAAO,GAC5BlC,EAASb,EAAMI,OAAOC,MAAM,GAC5ByC,KAEF,IAAIE,EAAMhD,EAAMI,OAAO6B,OACnB,OAAOf,KAAKlB,EAAMI,OAAO2C,OAAOC,EAAM,MACxCpD,EAAQI,EAAMI,OAAO2C,OAAOC,EAAM,GAClCnC,EAASb,EAAMI,OAAO6C,OAAOH,EAAGE,EAAM,IAExChC,GAAe,EAEjB,IAASgB,EAAI,EAAGA,EAAIQ,EAASP,SAAUD,EAAQnB,IAAU5B,EAAQuD,EAASR,GAAInB,EAAQzB,IACpF2B,EAAOmB,KAAKtC,EAAQ4C,EAASR,GAAKpC,QAMpC,IAAK,IAAIsD,IAJS,aAAdlD,EAAMmB,OACRN,EAASb,EAAMI,OACfY,GAAe,GAEAoB,GAAWA,EAAMD,eAAee,IAAWrC,IAAU5B,EAAQiE,EAAMrC,EAAQzB,IAC1F2B,EAAOmB,KAAKgB,GAGlB,OACEC,KAAMpC,EACNqC,KAAMpC,EAAehC,EAAIc,EAAIyB,KAAkB,MAAZT,EAAmBd,EAAMM,MAAQQ,GAAYhB,EAChFuD,GAAIrC,EAAehC,EAAIc,EAAIyB,KAAMvB,EAAME,KAAOJ","file":"../../../addon/hint/xml-hint.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\ndefine([\"../../CodeMirror\"], function(CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n\n  function matches(hint, typed, matchInMiddle) {\n    if (matchInMiddle) return hint.indexOf(typed) >= 0;\n    else return hint.lastIndexOf(typed, 0) == 0;\n  }\n\n  function getHints(cm, options) {\n    var tags = options && options.schemaInfo;\n    var quote = (options && options.quoteChar) || '\"';\n    var matchInMiddle = options && options.matchInMiddle;\n    if (!tags) return;\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur);\n    if (token.end > cur.ch) {\n      token.end = cur.ch;\n      token.string = token.string.slice(0, cur.ch - token.start);\n    }\n    var inner = CodeMirror.innerMode(cm.getMode(), token.state);\n    if (inner.mode.name != \"xml\") return;\n    var result = [], replaceToken = false, prefix;\n    var tag = /\\btag\\b/.test(token.type) && !/>$/.test(token.string);\n    var tagName = tag && /^\\w/.test(token.string), tagStart;\n\n    if (tagName) {\n      var before = cm.getLine(cur.line).slice(Math.max(0, token.start - 2), token.start);\n      var tagType = /<\\/$/.test(before) ? \"close\" : /<$/.test(before) ? \"open\" : null;\n      if (tagType) tagStart = token.start - (tagType == \"close\" ? 2 : 1);\n    } else if (tag && token.string == \"<\") {\n      tagType = \"open\";\n    } else if (tag && token.string == \"</\") {\n      tagType = \"close\";\n    }\n\n    if (!tag && !inner.state.tagName || tagType) {\n      if (tagName)\n        prefix = token.string;\n      replaceToken = tagType;\n      var cx = inner.state.context, curTag = cx && tags[cx.tagName];\n      var childList = cx ? curTag && curTag.children : tags[\"!top\"];\n      if (childList && tagType != \"close\") {\n        for (var i = 0; i < childList.length; ++i) if (!prefix || matches(childList[i], prefix, matchInMiddle))\n          result.push(\"<\" + childList[i]);\n      } else if (tagType != \"close\") {\n        for (var name in tags)\n          if (tags.hasOwnProperty(name) && name != \"!top\" && name != \"!attrs\" && (!prefix || matches(name, prefix, matchInMiddle)))\n            result.push(\"<\" + name);\n      }\n      if (cx && (!prefix || tagType == \"close\" && matches(cx.tagName, prefix, matchInMiddle)))\n        result.push(\"</\" + cx.tagName + \">\");\n    } else {\n      // Attribute completion\n      var curTag = tags[inner.state.tagName], attrs = curTag && curTag.attrs;\n      var globalAttrs = tags[\"!attrs\"];\n      if (!attrs && !globalAttrs) return;\n      if (!attrs) {\n        attrs = globalAttrs;\n      } else if (globalAttrs) { // Combine tag-local and global attributes\n        var set = {};\n        for (var nm in globalAttrs) if (globalAttrs.hasOwnProperty(nm)) set[nm] = globalAttrs[nm];\n        for (var nm in attrs) if (attrs.hasOwnProperty(nm)) set[nm] = attrs[nm];\n        attrs = set;\n      }\n      if (token.type == \"string\" || token.string == \"=\") { // A value\n        var before = cm.getRange(Pos(cur.line, Math.max(0, cur.ch - 60)),\n                                 Pos(cur.line, token.type == \"string\" ? token.start : token.end));\n        var atName = before.match(/([^\\s\\u00a0=<>\\\"\\']+)=$/), atValues;\n        if (!atName || !attrs.hasOwnProperty(atName[1]) || !(atValues = attrs[atName[1]])) return;\n        if (typeof atValues == 'function') atValues = atValues.call(this, cm); // Functions can be used to supply values for autocomplete widget\n        if (token.type == \"string\") {\n          prefix = token.string;\n          var n = 0;\n          if (/['\"]/.test(token.string.charAt(0))) {\n            quote = token.string.charAt(0);\n            prefix = token.string.slice(1);\n            n++;\n          }\n          var len = token.string.length;\n          if (/['\"]/.test(token.string.charAt(len - 1))) {\n            quote = token.string.charAt(len - 1);\n            prefix = token.string.substr(n, len - 2);\n          }\n          replaceToken = true;\n        }\n        for (var i = 0; i < atValues.length; ++i) if (!prefix || matches(atValues[i], prefix, matchInMiddle))\n          result.push(quote + atValues[i] + quote);\n      } else { // An attribute name\n        if (token.type == \"attribute\") {\n          prefix = token.string;\n          replaceToken = true;\n        }\n        for (var attr in attrs) if (attrs.hasOwnProperty(attr) && (!prefix || matches(attr, prefix, matchInMiddle)))\n          result.push(attr);\n      }\n    }\n    return {\n      list: result,\n      from: replaceToken ? Pos(cur.line, tagStart == null ? token.start : tagStart) : cur,\n      to: replaceToken ? Pos(cur.line, token.end) : cur\n    };\n  }\n\n  CodeMirror.registerHelper(\"hint\", \"xml\", getHints);\n});\n"]}