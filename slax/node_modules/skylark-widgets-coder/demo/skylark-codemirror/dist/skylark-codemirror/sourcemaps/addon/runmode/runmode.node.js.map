{"version":3,"sources":["addon/runmode/runmode.node.js"],"names":["splitLines","string","split","countColumn","exports","end","tabSize","startIndex","startValue","search","length","i","n","nextTab","indexOf","StringStream","context","this","pos","start","lastColumnPos","lastColumnValue","lineStart","prototype","eol","sol","peek","charAt","undefined","next","eat","match","ch","ok","test","eatWhile","eatSpace","skipToEnd","skipTo","found","backUp","column","indentation","pattern","consume","caseInsensitive","slice","index","cased","str","toLowerCase","substr","current","hideFirstChars","inner","lookAhead","line","lines","startState","mode","a1","a2","modes","mimeModes","copyObj","obj","target","overwrite","prop","hasOwnProperty","defineMode","name","arguments","dependencies","Array","call","defineMIME","mime","spec","token","stream","resolveMode","modeExtensions","extendMode","properties","getMode","options","mfactory","modeObj","exts","helperType","modeProps","innerMode","state","info","registerHelper","registerGlobalHelper","Math","min","runMode","modespec","callback","indentUnit","e","blankLine","style","require","cache","resolve"],"mappings":"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","file":"../../../addon/runmode/runmode.node.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/* Just enough of CodeMirror to run runMode under node.js */\n\nfunction splitLines(string){return string.split(/\\r\\n?|\\n/);};\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nvar countColumn = exports.countColumn = function(string, end, tabSize, startIndex, startValue) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) end = string.length;\n  }\n  for (var i = startIndex || 0, n = startValue || 0;;) {\n    var nextTab = string.indexOf(\"\\t\", i);\n    if (nextTab < 0 || nextTab >= end)\n      return n + (end - i);\n    n += nextTab - i;\n    n += tabSize - (n % tabSize);\n    i = nextTab + 1;\n  }\n};\n\nfunction StringStream(string, tabSize, context) {\n  this.pos = this.start = 0;\n  this.string = string;\n  this.tabSize = tabSize || 8;\n  this.lastColumnPos = this.lastColumnValue = 0;\n  this.lineStart = 0;\n  this.context = context\n};\n\nStringStream.prototype = {\n  eol: function() {return this.pos >= this.string.length;},\n  sol: function() {return this.pos == this.lineStart;},\n  peek: function() {return this.string.charAt(this.pos) || undefined;},\n  next: function() {\n    if (this.pos < this.string.length)\n      return this.string.charAt(this.pos++);\n  },\n  eat: function(match) {\n    var ch = this.string.charAt(this.pos);\n    if (typeof match == \"string\") var ok = ch == match;\n    else var ok = ch && (match.test ? match.test(ch) : match(ch));\n    if (ok) {++this.pos; return ch;}\n  },\n  eatWhile: function(match) {\n    var start = this.pos;\n    while (this.eat(match)){}\n    return this.pos > start;\n  },\n  eatSpace: function() {\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n    return this.pos > start;\n  },\n  skipToEnd: function() {this.pos = this.string.length;},\n  skipTo: function(ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {this.pos = found; return true;}\n  },\n  backUp: function(n) {this.pos -= n;},\n  column: function() {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n  },\n  indentation: function() {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n  },\n  match: function(pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) this.pos += pattern.length;\n        return true;\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) return null;\n      if (match && consume !== false) this.pos += match[0].length;\n      return match;\n    }\n  },\n  current: function(){return this.string.slice(this.start, this.pos);},\n  hideFirstChars: function(n, inner) {\n    this.lineStart += n;\n    try { return inner(); }\n    finally { this.lineStart -= n; }\n  },\n  lookAhead: function(n) {\n    var line = this.context.line + n\n    return line >= this.context.lines.length ? null : this.context.lines[line]\n  }\n};\nexports.StringStream = StringStream;\n\nexports.startState = function(mode, a1, a2) {\n  return mode.startState ? mode.startState(a1, a2) : true;\n};\n\nvar modes = exports.modes = {}, mimeModes = exports.mimeModes = {};\nexports.defineMode = function(name, mode) {\n  if (arguments.length > 2)\n    mode.dependencies = Array.prototype.slice.call(arguments, 2);\n  modes[name] = mode;\n};\nexports.defineMIME = function(mime, spec) { mimeModes[mime] = spec; };\n\nexports.defineMode(\"null\", function() {\n  return {token: function(stream) {stream.skipToEnd();}};\n});\nexports.defineMIME(\"text/plain\", \"null\");\n\nexports.resolveMode = function(spec) {\n  if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n    spec = mimeModes[spec];\n  } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n    spec = mimeModes[spec.name];\n  }\n  if (typeof spec == \"string\") return {name: spec};\n  else return spec || {name: \"null\"};\n};\n\nfunction copyObj(obj, target, overwrite) {\n  if (!target) target = {};\n  for (var prop in obj)\n    if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n      target[prop] = obj[prop];\n  return target;\n}\n\n// This can be used to attach properties to mode objects from\n// outside the actual mode definition.\nvar modeExtensions = exports.modeExtensions = {};\nexports.extendMode = function(mode, properties) {\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n  copyObj(properties, exts);\n};\n\nexports.getMode = function(options, spec) {\n  var spec = exports.resolveMode(spec);\n  var mfactory = modes[spec.name];\n  if (!mfactory) return exports.getMode(options, \"text/plain\");\n  var modeObj = mfactory(options, spec);\n  if (modeExtensions.hasOwnProperty(spec.name)) {\n    var exts = modeExtensions[spec.name];\n    for (var prop in exts) {\n      if (!exts.hasOwnProperty(prop)) continue;\n      if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n      modeObj[prop] = exts[prop];\n    }\n  }\n  modeObj.name = spec.name;\n  if (spec.helperType) modeObj.helperType = spec.helperType;\n  if (spec.modeProps) for (var prop in spec.modeProps)\n    modeObj[prop] = spec.modeProps[prop];\n\n  return modeObj;\n};\n\nexports.innerMode = function(mode, state) {\n  var info;\n  while (mode.innerMode) {\n    info = mode.innerMode(state);\n    if (!info || info.mode == mode) break;\n    state = info.state;\n    mode = info.mode;\n  }\n  return info || {mode: mode, state: state};\n}\n\nexports.registerHelper = exports.registerGlobalHelper = Math.min;\n\nexports.runMode = function(string, modespec, callback, options) {\n  var mode = exports.getMode({indentUnit: 2}, modespec);\n  var lines = splitLines(string), state = (options && options.state) || exports.startState(mode);\n  var context = {lines: lines, line: 0}\n  for (var i = 0, e = lines.length; i < e; ++i, ++context.line) {\n    if (i) callback(\"\\n\");\n    var stream = new exports.StringStream(lines[i], 4, context);\n    if (!stream.string && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol()) {\n      var style = mode.token(stream, state);\n      callback(stream.current(), style, i, stream.start, state);\n      stream.start = stream.pos;\n    }\n  }\n};\n\nrequire.cache[require.resolve(\"../../lib/codemirror\")] = require.cache[require.resolve(\"./runmode.node\")];\nrequire.cache[require.resolve(\"../../addon/runmode/runmode\")] = require.cache[require.resolve(\"./runmode.node\")];\n"]}