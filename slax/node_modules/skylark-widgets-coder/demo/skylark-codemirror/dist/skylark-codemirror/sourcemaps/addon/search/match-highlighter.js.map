{"version":3,"sources":["addon/search/match-highlighter.js"],"names":["define","CodeMirror","defaults","style","minChars","delay","wordsOnly","annotateScrollbar","showToken","trim","cursorActivity","cm","state","matchHighlighter","active","hasFocus","scheduleHighlight","onFocus","clearTimeout","timeout","setTimeout","highlightMatches","options","addOverlay","query","hasBoundary","overlay","token","stream","match","re","start","test","string","charAt","pos","length","boundariesAround","next","skipTo","skipToEnd","makeOverlay","showMatchesOnScrollbar","searchFor","RegExp","replace","matchesonscroll","className","removeOverlay","clear","operation","somethingSelected","from","getCursor","to","line","getRange","ch","chr","getLine","isWord","selection","cur","end","slice","defineOption","val","old","Init","off","name","this","hasOwnProperty","on"],"mappings":"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","file":"../../../addon/search/match-highlighter.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Highlighting text that matches the selection\n//\n// Defines an option highlightSelectionMatches, which, when enabled,\n// will style strings that match the selection throughout the\n// document.\n//\n// The option can be set to true to simply enable it, or to a\n// {minChars, style, wordsOnly, showToken, delay} object to explicitly\n// configure it. minChars is the minimum amount of characters that should be\n// selected for the behavior to occur, and style is the token style to\n// apply to the matches. This will be prefixed by \"cm-\" to create an\n// actual CSS class name. If wordsOnly is enabled, the matches will be\n// highlighted only if the selected text is a word. showToken, when enabled,\n// will cause the current token to be highlighted when nothing is selected.\n// delay is used to specify how much time to wait, in milliseconds, before\n// highlighting the matches. If annotateScrollbar is enabled, the occurences\n// will be highlighted on the scrollbar via the matchesonscrollbar addon.\n\ndefine([\"../../CodeMirror\", \"./matchesonscrollbar\"], function(CodeMirror) {\n  \"use strict\";\n\n  var defaults = {\n    style: \"matchhighlight\",\n    minChars: 2,\n    delay: 100,\n    wordsOnly: false,\n    annotateScrollbar: false,\n    showToken: false,\n    trim: true\n  }\n\n  function State(options) {\n    this.options = {}\n    for (var name in defaults)\n      this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name]\n    this.overlay = this.timeout = null;\n    this.matchesonscroll = null;\n    this.active = false;\n  }\n\n  CodeMirror.defineOption(\"highlightSelectionMatches\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      removeOverlay(cm);\n      clearTimeout(cm.state.matchHighlighter.timeout);\n      cm.state.matchHighlighter = null;\n      cm.off(\"cursorActivity\", cursorActivity);\n      cm.off(\"focus\", onFocus)\n    }\n    if (val) {\n      var state = cm.state.matchHighlighter = new State(val);\n      if (cm.hasFocus()) {\n        state.active = true\n        highlightMatches(cm)\n      } else {\n        cm.on(\"focus\", onFocus)\n      }\n      cm.on(\"cursorActivity\", cursorActivity);\n    }\n  });\n\n  function cursorActivity(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.active || cm.hasFocus()) scheduleHighlight(cm, state)\n  }\n\n  function onFocus(cm) {\n    var state = cm.state.matchHighlighter\n    if (!state.active) {\n      state.active = true\n      scheduleHighlight(cm, state)\n    }\n  }\n\n  function scheduleHighlight(cm, state) {\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function() {highlightMatches(cm);}, state.options.delay);\n  }\n\n  function addOverlay(cm, query, hasBoundary, style) {\n    var state = cm.state.matchHighlighter;\n    cm.addOverlay(state.overlay = makeOverlay(query, hasBoundary, style));\n    if (state.options.annotateScrollbar && cm.showMatchesOnScrollbar) {\n      var searchFor = hasBoundary ? new RegExp(\"\\\\b\" + query.replace(/[\\\\\\[.+*?(){|^$]/g, \"\\\\$&\") + \"\\\\b\") : query;\n      state.matchesonscroll = cm.showMatchesOnScrollbar(searchFor, false,\n        {className: \"CodeMirror-selection-highlight-scrollbar\"});\n    }\n  }\n\n  function removeOverlay(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.overlay) {\n      cm.removeOverlay(state.overlay);\n      state.overlay = null;\n      if (state.matchesonscroll) {\n        state.matchesonscroll.clear();\n        state.matchesonscroll = null;\n      }\n    }\n  }\n\n  function highlightMatches(cm) {\n    cm.operation(function() {\n      var state = cm.state.matchHighlighter;\n      removeOverlay(cm);\n      if (!cm.somethingSelected() && state.options.showToken) {\n        var re = state.options.showToken === true ? /[\\w$]/ : state.options.showToken;\n        var cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start;\n        while (start && re.test(line.charAt(start - 1))) --start;\n        while (end < line.length && re.test(line.charAt(end))) ++end;\n        if (start < end)\n          addOverlay(cm, line.slice(start, end), re, state.options.style);\n        return;\n      }\n      var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n      if (from.line != to.line) return;\n      if (state.options.wordsOnly && !isWord(cm, from, to)) return;\n      var selection = cm.getRange(from, to)\n      if (state.options.trim) selection = selection.replace(/^\\s+|\\s+$/g, \"\")\n      if (selection.length >= state.options.minChars)\n        addOverlay(cm, selection, false, state.options.style);\n    });\n  }\n\n  function isWord(cm, from, to) {\n    var str = cm.getRange(from, to);\n    if (str.match(/^\\w+$/) !== null) {\n        if (from.ch > 0) {\n            var pos = {line: from.line, ch: from.ch - 1};\n            var chr = cm.getRange(pos, from);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        if (to.ch < cm.getLine(from.line).length) {\n            var pos = {line: to.line, ch: to.ch + 1};\n            var chr = cm.getRange(to, pos);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        return true;\n    } else return false;\n  }\n\n  function boundariesAround(stream, re) {\n    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) &&\n      (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));\n  }\n\n  function makeOverlay(query, hasBoundary, style) {\n    return {token: function(stream) {\n      if (stream.match(query) &&\n          (!hasBoundary || boundariesAround(stream, hasBoundary)))\n        return style;\n      stream.next();\n      stream.skipTo(query.charAt(0)) || stream.skipToEnd();\n    }};\n  }\n});\n"]}