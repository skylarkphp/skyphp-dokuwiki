{"version":3,"sources":["addon/search/searchcursor.js"],"names":["define","CodeMirror","doFold","noFold","Pos","ensureFlags","regexp","flags","current","ignoreCase","global","multiline","regexpFlags","target","i","length","indexOf","charAt","RegExp","source","searchRegexpForward","doc","start","line","ch","last","lastLine","lastIndex","string","getLine","match","exec","from","index","to","lastMatchIn","cutOff","newMatch","adjustPos","orig","folded","pos","foldFunc","min","max","Math","mid","len","slice","SearchCursor","query","options","caseFold","this","atOccurrence","clipPos","matches","reverse","fold","lines","split","search","first","firstLine","found","lastIndexOf","top","topString","cutFrom","end","endString","chunk","curLine","before","inside","startLine","startCh","test","maybeMultiline","String","prototype","normalize","str","toLowerCase","findNext","find","findPrevious","result","cmpPos","replace","newText","origin","splitLines","replaceRange","defineExtension","defineDocExtension","ranges","cur","getSearchCursor","getCursor","push","anchor","head","setSelections"],"mappings":"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","file":"../../../addon/search/searchcursor.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\ndefine([\"../../CodeMirror\"],function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureFlags(regexp, flags) {\n    var current = regexpFlags(regexp), target = current\n    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)\n      target += flags.charAt(i)\n    return current == target ? regexp : new RegExp(regexp.source, target)\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        if (line > last) break\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp) {\n    var cutOff = 0, match\n    for (;;) {\n      regexp.lastIndex = cutOff\n      var newMatch = regexp.exec(string)\n      if (!newMatch) return match\n      match = newMatch\n      cutOff = match.index + (match[0].length || 1)\n      if (cutOff == string.length) return match\n    }\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      if (ch > -1) string = string.slice(0, ch)\n      var match = lastMatchIn(string, regexp)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunk; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine.slice(0, start.ch) : curLine + \"\\n\" + string\n      }\n      chunk *= 2\n\n      var match = lastMatchIn(string, regexp)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) >> 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len > pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (endString.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch > -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureFlags(query, \"gm\")\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to))\n\n      // Implements weird auto-growing behavior on null-matches for\n      // backwards-compatiblity with the vim code (unfortunately)\n      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {\n        if (reverse) {\n          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1)\n          else if (result.from.line == this.doc.firstLine()) result = null\n          else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)))\n        } else {\n          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1)\n          else if (result.to.line == this.doc.lastLine()) result = null\n          else result = this.matches(reverse, Pos(result.to.line + 1, 0))\n        }\n      }\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n"]}