{"version":3,"sources":["addon/selection/mark-selection.js"],"names":["define","CodeMirror","onCursorActivity","cm","state","markedSelection","operation","somethingSelected","clear","listSelections","length","reset","from","getCursor","to","array","coverRange","coverStart","find","coverEnd","line","CHUNK_SIZE","cmp","shift","pop","update","onChange","defineOption","val","old","prev","Init","markedSelectionStyle","on","off","Pos","cmpPos","addAt","cls","start","endLine","atEnd","end","mark","markText","className","push","splice","i","ranges"],"mappings":"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","file":"../../../addon/selection/mark-selection.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Because sometimes you need to mark the selected *text*.\n//\n// Adds an option 'styleSelectedText' which, when enabled, gives\n// selected text the CSS class given as option value, or\n// \"CodeMirror-selectedtext\" when the value is not a string.\n\ndefine([\"../../CodeMirror\"], function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"styleSelectedText\", false, function(cm, val, old) {\n    var prev = old && old != CodeMirror.Init;\n    if (val && !prev) {\n      cm.state.markedSelection = [];\n      cm.state.markedSelectionStyle = typeof val == \"string\" ? val : \"CodeMirror-selectedtext\";\n      reset(cm);\n      cm.on(\"cursorActivity\", onCursorActivity);\n      cm.on(\"change\", onChange);\n    } else if (!val && prev) {\n      cm.off(\"cursorActivity\", onCursorActivity);\n      cm.off(\"change\", onChange);\n      clear(cm);\n      cm.state.markedSelection = cm.state.markedSelectionStyle = null;\n    }\n  });\n\n  function onCursorActivity(cm) {\n    if (cm.state.markedSelection)\n      cm.operation(function() { update(cm); });\n  }\n\n  function onChange(cm) {\n    if (cm.state.markedSelection && cm.state.markedSelection.length)\n      cm.operation(function() { clear(cm); });\n  }\n\n  var CHUNK_SIZE = 8;\n  var Pos = CodeMirror.Pos;\n  var cmp = CodeMirror.cmpPos;\n\n  function coverRange(cm, from, to, addAt) {\n    if (cmp(from, to) == 0) return;\n    var array = cm.state.markedSelection;\n    var cls = cm.state.markedSelectionStyle;\n    for (var line = from.line;;) {\n      var start = line == from.line ? from : Pos(line, 0);\n      var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;\n      var end = atEnd ? to : Pos(endLine, 0);\n      var mark = cm.markText(start, end, {className: cls});\n      if (addAt == null) array.push(mark);\n      else array.splice(addAt++, 0, mark);\n      if (atEnd) break;\n      line = endLine;\n    }\n  }\n\n  function clear(cm) {\n    var array = cm.state.markedSelection;\n    for (var i = 0; i < array.length; ++i) array[i].clear();\n    array.length = 0;\n  }\n\n  function reset(cm) {\n    clear(cm);\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++)\n      coverRange(cm, ranges[i].from(), ranges[i].to());\n  }\n\n  function update(cm) {\n    if (!cm.somethingSelected()) return clear(cm);\n    if (cm.listSelections().length > 1) return reset(cm);\n\n    var from = cm.getCursor(\"start\"), to = cm.getCursor(\"end\");\n\n    var array = cm.state.markedSelection;\n    if (!array.length) return coverRange(cm, from, to);\n\n    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();\n    if (!coverStart || !coverEnd || to.line - from.line <= CHUNK_SIZE ||\n        cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)\n      return reset(cm);\n\n    while (cmp(from, coverStart.from) > 0) {\n      array.shift().clear();\n      coverStart = array[0].find();\n    }\n    if (cmp(from, coverStart.from) < 0) {\n      if (coverStart.to.line - from.line < CHUNK_SIZE) {\n        array.shift().clear();\n        coverRange(cm, from, coverStart.to, 0);\n      } else {\n        coverRange(cm, from, coverStart.from, 0);\n      }\n    }\n\n    while (cmp(to, coverEnd.to) < 0) {\n      array.pop().clear();\n      coverEnd = array[array.length - 1].find();\n    }\n    if (cmp(to, coverEnd.to) > 0) {\n      if (to.line - coverEnd.from.line < CHUNK_SIZE) {\n        array.pop().clear();\n        coverRange(cm, coverEnd.from, to);\n      } else {\n        coverRange(cm, coverEnd.to, to);\n      }\n    }\n  }\n});\n"]}