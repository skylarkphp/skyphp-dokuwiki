{"version":3,"sources":["addon/wrap/hardwrap.js"],"names":["define","CodeMirror","Pos","findParagraph","cm","pos","options","startRE","paragraphStart","getHelper","start","line","first","firstLine","getLine","test","endRE","paragraphEnd","end","last","lastLine","from","to","findBreakPoint","text","column","wrapOn","killTrailingSpace","at","length","charAt","slice","endOfText","wrapRange","clipPos","killTrailing","changes","curLine","curNo","lines","getRange","leadingSpace","match","i","oldLen","spaceInserted","spaceTrimmed","firstBreak","push","bp","operation","change","cmpPos","replaceRange","changeEnd","defineExtension","this","getCursor","para","commands","wrapLines","ranges","listSelections","span","range","empty","head","paras","madeChange"],"mappings":"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","file":"../../../addon/wrap/hardwrap.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\ndefine([\"../../CodeMirror\"], function(CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n\n  function findParagraph(cm, pos, options) {\n    var startRE = options.paragraphStart || cm.getHelper(pos, \"paragraphStart\");\n    for (var start = pos.line, first = cm.firstLine(); start > first; --start) {\n      var line = cm.getLine(start);\n      if (startRE && startRE.test(line)) break;\n      if (!/\\S/.test(line)) { ++start; break; }\n    }\n    var endRE = options.paragraphEnd || cm.getHelper(pos, \"paragraphEnd\");\n    for (var end = pos.line + 1, last = cm.lastLine(); end <= last; ++end) {\n      var line = cm.getLine(end);\n      if (endRE && endRE.test(line)) { ++end; break; }\n      if (!/\\S/.test(line)) break;\n    }\n    return {from: start, to: end};\n  }\n\n  function findBreakPoint(text, column, wrapOn, killTrailingSpace) {\n    var at = column\n    while (at < text.length && text.charAt(at) == \" \") at++\n    for (; at > 0; --at)\n      if (wrapOn.test(text.slice(at - 1, at + 1))) break;\n    for (var first = true;; first = false) {\n      var endOfText = at;\n      if (killTrailingSpace)\n        while (text.charAt(endOfText - 1) == \" \") --endOfText;\n      if (endOfText == 0 && first) at = column;\n      else return {from: endOfText, to: at};\n    }\n  }\n\n  function wrapRange(cm, from, to, options) {\n    from = cm.clipPos(from); to = cm.clipPos(to);\n    var column = options.column || 80;\n    var wrapOn = options.wrapOn || /\\s\\S|-[^\\.\\d]/;\n    var killTrailing = options.killTrailingSpace !== false;\n    var changes = [], curLine = \"\", curNo = from.line;\n    var lines = cm.getRange(from, to, false);\n    if (!lines.length) return null;\n    var leadingSpace = lines[0].match(/^[ \\t]*/)[0];\n    if (leadingSpace.length >= column) column = leadingSpace.length + 1\n\n    for (var i = 0; i < lines.length; ++i) {\n      var text = lines[i], oldLen = curLine.length, spaceInserted = 0;\n      if (curLine && text && !wrapOn.test(curLine.charAt(curLine.length - 1) + text.charAt(0))) {\n        curLine += \" \";\n        spaceInserted = 1;\n      }\n      var spaceTrimmed = \"\";\n      if (i) {\n        spaceTrimmed = text.match(/^\\s*/)[0];\n        text = text.slice(spaceTrimmed.length);\n      }\n      curLine += text;\n      if (i) {\n        var firstBreak = curLine.length > column && leadingSpace == spaceTrimmed &&\n          findBreakPoint(curLine, column, wrapOn, killTrailing);\n        // If this isn't broken, or is broken at a different point, remove old break\n        if (!firstBreak || firstBreak.from != oldLen || firstBreak.to != oldLen + spaceInserted) {\n          changes.push({text: [spaceInserted ? \" \" : \"\"],\n                        from: Pos(curNo, oldLen),\n                        to: Pos(curNo + 1, spaceTrimmed.length)});\n        } else {\n          curLine = leadingSpace + text;\n          ++curNo;\n        }\n      }\n      while (curLine.length > column) {\n        var bp = findBreakPoint(curLine, column, wrapOn, killTrailing);\n        changes.push({text: [\"\", leadingSpace],\n                      from: Pos(curNo, bp.from),\n                      to: Pos(curNo, bp.to)});\n        curLine = leadingSpace + curLine.slice(bp.to);\n        ++curNo;\n      }\n    }\n    if (changes.length) cm.operation(function() {\n      for (var i = 0; i < changes.length; ++i) {\n        var change = changes[i];\n        if (change.text || CodeMirror.cmpPos(change.from, change.to))\n          cm.replaceRange(change.text, change.from, change.to);\n      }\n    });\n    return changes.length ? {from: changes[0].from, to: CodeMirror.changeEnd(changes[changes.length - 1])} : null;\n  }\n\n  CodeMirror.defineExtension(\"wrapParagraph\", function(pos, options) {\n    options = options || {};\n    if (!pos) pos = this.getCursor();\n    var para = findParagraph(this, pos, options);\n    return wrapRange(this, Pos(para.from, 0), Pos(para.to - 1), options);\n  });\n\n  CodeMirror.commands.wrapLines = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections(), at = cm.lastLine() + 1;\n      for (var i = ranges.length - 1; i >= 0; i--) {\n        var range = ranges[i], span;\n        if (range.empty()) {\n          var para = findParagraph(cm, range.head, {});\n          span = {from: Pos(para.from, 0), to: Pos(para.to - 1)};\n        } else {\n          span = {from: range.from(), to: range.to()};\n        }\n        if (span.to.line >= at) continue;\n        at = span.from.line;\n        wrapRange(cm, span.from, span.to, {});\n      }\n    });\n  };\n\n  CodeMirror.defineExtension(\"wrapRange\", function(from, to, options) {\n    return wrapRange(this, from, to, options || {});\n  });\n\n  CodeMirror.defineExtension(\"wrapParagraphsInRange\", function(from, to, options) {\n    options = options || {};\n    var cm = this, paras = [];\n    for (var line = from.line; line <= to.line;) {\n      var para = findParagraph(cm, Pos(line, 0), options);\n      paras.push(para);\n      line = para.to;\n    }\n    var madeChange = false;\n    if (paras.length) cm.operation(function() {\n      for (var i = paras.length - 1; i >= 0; --i)\n        madeChange = madeChange || wrapRange(cm, Pos(paras[i].from, 0), Pos(paras[i].to - 1), options);\n    });\n    return madeChange;\n  });\n});\n"]}