{"version":3,"sources":["mode/haml/haml.js"],"names":["define","CodeMirror","defineMode","config","htmlMode","getMode","name","rubyMode","rubyInQuote","endQuote","stream","state","peek","rubyState","tokenize","length","next","html","ruby","match","skipToEnd","token","ch","previousToken","style","indented","startOfLine","htmlState","startState","copyState","sol","indentation","eatSpace","eol","backUp","defineMIME"],"mappings":"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","file":"../../../mode/haml/haml.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\ndefine([\"../../CodeMirror\", \"../htmlmixed/htmlmixed\", \"../ruby/ruby\"], function(CodeMirror) {\n\"use strict\";\n\n  // full haml mode. This handled embedded ruby and html fragments too\n  CodeMirror.defineMode(\"haml\", function(config) {\n    var htmlMode = CodeMirror.getMode(config, {name: \"htmlmixed\"});\n    var rubyMode = CodeMirror.getMode(config, \"ruby\");\n\n    function rubyInQuote(endQuote) {\n      return function(stream, state) {\n        var ch = stream.peek();\n        if (ch == endQuote && state.rubyState.tokenize.length == 1) {\n          // step out of ruby context as it seems to complete processing all the braces\n          stream.next();\n          state.tokenize = html;\n          return \"closeAttributeTag\";\n        } else {\n          return ruby(stream, state);\n        }\n      };\n    }\n\n    function ruby(stream, state) {\n      if (stream.match(\"-#\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      return rubyMode.token(stream, state.rubyState);\n    }\n\n    function html(stream, state) {\n      var ch = stream.peek();\n\n      // handle haml declarations. All declarations that cant be handled here\n      // will be passed to html mode\n      if (state.previousToken.style == \"comment\" ) {\n        if (state.indented > state.previousToken.indented) {\n          stream.skipToEnd();\n          return \"commentLine\";\n        }\n      }\n\n      if (state.startOfLine) {\n        if (ch == \"!\" && stream.match(\"!!\")) {\n          stream.skipToEnd();\n          return \"tag\";\n        } else if (stream.match(/^%[\\w:#\\.]+=/)) {\n          state.tokenize = ruby;\n          return \"hamlTag\";\n        } else if (stream.match(/^%[\\w:]+/)) {\n          return \"hamlTag\";\n        } else if (ch == \"/\" ) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n      }\n\n      if (state.startOfLine || state.previousToken.style == \"hamlTag\") {\n        if ( ch == \"#\" || ch == \".\") {\n          stream.match(/[\\w-#\\.]*/);\n          return \"hamlAttribute\";\n        }\n      }\n\n      // donot handle --> as valid ruby, make it HTML close comment instead\n      if (state.startOfLine && !stream.match(\"-->\", false) && (ch == \"=\" || ch == \"-\" )) {\n        state.tokenize = ruby;\n        return state.tokenize(stream, state);\n      }\n\n      if (state.previousToken.style == \"hamlTag\" ||\n          state.previousToken.style == \"closeAttributeTag\" ||\n          state.previousToken.style == \"hamlAttribute\") {\n        if (ch == \"(\") {\n          state.tokenize = rubyInQuote(\")\");\n          return state.tokenize(stream, state);\n        } else if (ch == \"{\") {\n          if (!stream.match(/^\\{%.*/)) {\n            state.tokenize = rubyInQuote(\"}\");\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n\n      return htmlMode.token(stream, state.htmlState);\n    }\n\n    return {\n      // default to html mode\n      startState: function() {\n        var htmlState = CodeMirror.startState(htmlMode);\n        var rubyState = CodeMirror.startState(rubyMode);\n        return {\n          htmlState: htmlState,\n          rubyState: rubyState,\n          indented: 0,\n          previousToken: { style: null, indented: 0},\n          tokenize: html\n        };\n      },\n\n      copyState: function(state) {\n        return {\n          htmlState : CodeMirror.copyState(htmlMode, state.htmlState),\n          rubyState: CodeMirror.copyState(rubyMode, state.rubyState),\n          indented: state.indented,\n          previousToken: state.previousToken,\n          tokenize: state.tokenize\n        };\n      },\n\n      token: function(stream, state) {\n        if (stream.sol()) {\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n        }\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        state.startOfLine = false;\n        // dont record comment line as we only want to measure comment line with\n        // the opening comment block\n        if (style && style != \"commentLine\") {\n          state.previousToken = { style: style, indented: state.indented };\n        }\n        // if current state is ruby and the previous token is not `,` reset the\n        // tokenize to html\n        if (stream.eol() && state.tokenize == ruby) {\n          stream.backUp(1);\n          var ch = stream.peek();\n          stream.next();\n          if (ch && ch != \",\") {\n            state.tokenize = html;\n          }\n        }\n        // reprocess some of the specific style tag when finish setting previousToken\n        if (style == \"hamlTag\") {\n          style = \"tag\";\n        } else if (style == \"commentLine\") {\n          style = \"comment\";\n        } else if (style == \"hamlAttribute\") {\n          style = \"attribute\";\n        } else if (style == \"closeAttributeTag\") {\n          style = null;\n        }\n        return style;\n      }\n    };\n  }, \"htmlmixed\", \"ruby\");\n\n  CodeMirror.defineMIME(\"text/x-haml\", \"haml\");\n});\n"]}