{"version":3,"sources":["mode/haxe/haxe.js"],"names":["define","CodeMirror","defineMode","config","parserConfig","indentUnit","kw","type","style","content","A","B","C","operator","atom","attribute","keywords","if","while","else","do","try","return","break","continue","new","throw","var","inline","static","using","public","private","cast","import","macro","function","catch","untyped","callback","for","switch","case","default","in","never","trace","class","abstract","enum","interface","typedef","extends","implements","dynamic","true","false","null","isOperatorChar","chain","stream","state","f","tokenize","toUnescaped","end","next","escaped","ret","tp","cont","haxeTokenBase","ch","quote","test","eat","eatWhile","match","reAllowed","haxeTokenComment","skipToEnd","current","word","known","propertyIsEnumerable","kwAllowed","maybeEnd","atomicTypes","number","variable","string","regexp","HaxeLexical","indented","column","align","prev","info","this","inScope","varname","v","localVars","name","imported","typename","charAt","len","importedtypes","length","i","registerimport","importname","cx","t","marked","cc","pass","arguments","push","apply","inList","list","register","context","globalVars","defaultVars","pushcontext","vars","popcontext","pushlex","result","lexical","lex","poplex","expect","wanted","statement","metadef","vardef1","expression","block","maybeattribute","functiondef","forspec1","maybelabel","funarg","importdef","hasOwnProperty","maybeoperator","maybeexpression","commasep","objprop","value","property","metaargs","what","proceed","typeuse","vardef2","forin","_type","typestring","typeprop","startState","basecolumn","token","sol","indentation","eatSpace","pop","parseHaxe","indent","textAfter","firstChar","closing","electricChars","blockCommentStart","blockCommentEnd","lineComment","defineMIME","inString","peek","skipTo"],"mappings":"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","file":"../../../mode/haxe/haxe.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\ndefine([\"../../CodeMirror\"], function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"haxe\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n\n  // Tokenizer\n\n  function kw(type) {return {type: type, style: \"keyword\"};}\n  var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n  var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"}, attribute = {type:\"attribute\", style: \"attribute\"};\n  var type = kw(\"typedef\");\n  var keywords = {\n    \"if\": A, \"while\": A, \"else\": B, \"do\": B, \"try\": B,\n    \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"throw\": C,\n    \"var\": kw(\"var\"), \"inline\":attribute, \"static\": attribute, \"using\":kw(\"import\"),\n    \"public\": attribute, \"private\": attribute, \"cast\": kw(\"cast\"), \"import\": kw(\"import\"), \"macro\": kw(\"macro\"),\n    \"function\": kw(\"function\"), \"catch\": kw(\"catch\"), \"untyped\": kw(\"untyped\"), \"callback\": kw(\"cb\"),\n    \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n    \"in\": operator, \"never\": kw(\"property_access\"), \"trace\":kw(\"trace\"),\n    \"class\": type, \"abstract\":type, \"enum\":type, \"interface\":type, \"typedef\":type, \"extends\":type, \"implements\":type, \"dynamic\":type,\n    \"true\": atom, \"false\": atom, \"null\": atom\n  };\n\n  var isOperatorChar = /[+\\-*&%=<>!?|]/;\n\n  function chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n  }\n\n  function toUnescaped(stream, end) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (next == end && !escaped)\n        return true;\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n\n  function haxeTokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      return chain(stream, state, haxeTokenString(ch));\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n      stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (state.reAllowed && (ch == \"~\" && stream.eat(/\\//))) {\n      toUnescaped(stream, \"/\");\n      stream.eatWhile(/[gimsu]/);\n      return ret(\"regexp\", \"string-2\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        return chain(stream, state, haxeTokenComment);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", null, stream.current());\n      }\n    } else if (ch == \"#\") {\n        stream.skipToEnd();\n        return ret(\"conditional\", \"meta\");\n    } else if (ch == \"@\") {\n      stream.eat(/:/);\n      stream.eatWhile(/[\\w_]/);\n      return ret (\"metadata\", \"meta\");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    } else {\n      var word;\n      if(/[A-Z]/.test(ch)) {\n        stream.eatWhile(/[\\w_<>]/);\n        word = stream.current();\n        return ret(\"type\", \"variable-3\", word);\n      } else {\n        stream.eatWhile(/[\\w_]/);\n        var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n        return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n                       ret(\"variable\", \"variable\", word);\n      }\n    }\n  }\n\n  function haxeTokenString(quote) {\n    return function(stream, state) {\n      if (toUnescaped(stream, quote))\n        state.tokenize = haxeTokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function haxeTokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = haxeTokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\n  function HaxeLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n  }\n\n  function parseHaxe(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        if (type == \"variable\" && imported(state, content)) return \"variable-3\";\n        return style;\n      }\n    }\n  }\n\n  function imported(state, typename) {\n    if (/[a-z]/.test(typename.charAt(0)))\n      return false;\n    var len = state.importedtypes.length;\n    for (var i = 0; i<len; i++)\n      if(state.importedtypes[i]==typename) return true;\n  }\n\n  function registerimport(importname) {\n    var state = cx.state;\n    for (var t = state.importedtypes; t; t = t.next)\n      if(t.name == importname) return;\n    state.importedtypes = { name: importname, next: state.importedtypes };\n  }\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next)\n      if (v.name == name) return true;\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = \"def\";\n      if (inList(varname, state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else if (state.globalVars) {\n      if (inList(varname, state.globalVars)) return;\n      state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: null};\n  function pushcontext() {\n    if (!cx.state.context) cx.state.localVars = defaultVars;\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  popcontext.lex = true;\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state;\n      state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function f(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(f);\n    }\n    return f;\n  }\n\n  function statement(type) {\n    if (type == \"@\") return cont(metadef);\n    if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"attribute\") return cont(maybeattribute);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                   poplex, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"import\") return cont(importdef, expect(\";\"));\n    if (type == \"typedef\") return cont(typedef);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n    if (type == \"type\" ) return cont(maybeoperator);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"keyword c\") return cont(maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n    if (type == \"operator\") return cont(expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperator(type, value) {\n    if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n    if (type == \"operator\" || type == \":\") return cont(expression);\n    if (type == \";\") return;\n    if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n    if (type == \".\") return cont(property, maybeoperator);\n    if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n  }\n\n  function maybeattribute(type) {\n    if (type == \"attribute\") return cont(maybeattribute);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"var\") return cont(vardef1);\n  }\n\n  function metadef(type) {\n    if(type == \":\") return cont(metadef);\n    if(type == \"variable\") return cont(metadef);\n    if(type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n  }\n  function metaargs(type) {\n    if(type == \"variable\") return cont();\n  }\n\n  function importdef (type, value) {\n    if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n    else if(type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n  }\n\n  function typedef (type, value)\n  {\n    if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n    else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) { return cont(); }\n  }\n\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperator, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type) {\n    if (type == \"variable\") cx.marked = \"property\";\n    if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == \",\") return cont(what, proceed);\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      else return pass(what, proceed);\n    };\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function vardef1(type, value) {\n    if (type == \"variable\"){register(value); return cont(typeuse, vardef2);}\n    return cont();\n  }\n  function vardef2(type, value) {\n    if (value == \"=\") return cont(expression, vardef2);\n    if (type == \",\") return cont(vardef1);\n  }\n  function forspec1(type, value) {\n    if (type == \"variable\") {\n      register(value);\n      return cont(forin, expression)\n    } else {\n      return pass()\n    }\n  }\n  function forin(_type, value) {\n    if (value == \"in\") return cont();\n  }\n  function functiondef(type, value) {\n    //function names starting with upper-case letters are recognised as types, so cludging them together here.\n    if (type == \"variable\" || type == \"type\") {register(value); return cont(functiondef);}\n    if (value == \"new\") return cont(functiondef);\n    if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n  }\n  function typeuse(type) {\n    if(type == \":\") return cont(typestring);\n  }\n  function typestring(type) {\n    if(type == \"type\") return cont();\n    if(type == \"variable\") return cont();\n    if(type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n  }\n  function typeprop(type) {\n    if(type == \"variable\") return cont(typeuse);\n  }\n  function funarg(type, value) {\n    if (type == \"variable\") {register(value); return cont(typeuse);}\n  }\n\n  // Interface\n  return {\n    startState: function(basecolumn) {\n      var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n      var state = {\n        tokenize: haxeTokenBase,\n        reAllowed: true,\n        kwAllowed: true,\n        cc: [],\n        lexical: new HaxeLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        importedtypes: defaulttypes,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n      }\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n      state.kwAllowed = type != '.';\n      return parseHaxe(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != haxeTokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n      if (type == \"vardef\") return lexical.indented + 4;\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"stat\" || type == \"form\") return lexical.indented + indentUnit;\n      else if (lexical.info == \"switch\" && !closing)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricChars: \"{}\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    lineComment: \"//\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-haxe\", \"haxe\");\n\nCodeMirror.defineMode(\"hxml\", function () {\n\n  return {\n    startState: function () {\n      return {\n        define: false,\n        inString: false\n      };\n    },\n    token: function (stream, state) {\n      var ch = stream.peek();\n      var sol = stream.sol();\n\n      ///* comments */\n      if (ch == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      if (sol && ch == \"-\") {\n        var style = \"variable-2\";\n\n        stream.eat(/-/);\n\n        if (stream.peek() == \"-\") {\n          stream.eat(/-/);\n          style = \"keyword a\";\n        }\n\n        if (stream.peek() == \"D\") {\n          stream.eat(/[D]/);\n          style = \"keyword c\";\n          state.define = true;\n        }\n\n        stream.eatWhile(/[A-Z]/i);\n        return style;\n      }\n\n      var ch = stream.peek();\n\n      if (state.inString == false && ch == \"'\") {\n        state.inString = true;\n        stream.next();\n      }\n\n      if (state.inString == true) {\n        if (stream.skipTo(\"'\")) {\n\n        } else {\n          stream.skipToEnd();\n        }\n\n        if (stream.peek() == \"'\") {\n          stream.next();\n          state.inString = false;\n        }\n\n        return \"string\";\n      }\n\n      stream.next();\n      return null;\n    },\n    lineComment: \"#\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-hxml\", \"hxml\");\n\n});\n"]}