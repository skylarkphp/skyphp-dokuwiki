{"version":3,"sources":["mode/jsx/jsx.js"],"names":["define","CodeMirror","Context","state","mode","depth","prev","this","defineMode","config","modeConfig","xmlMode","getMode","name","allowMissing","multilineTagIndentPastTag","allowMissingTagName","jsMode","base","flatXMLIndent","tagName","result","indent","token","stream","context","cx","match","skipToEnd","peek","skipAttribute","xmlContext","startOfLine","indentUnit","lexical","indented","startState","stop","style","cur","current","test","indexOf","backUp","length","xmlToken","expressionAllowed","skipExpression","jsToken","copyState","copyContext","textAfter","fullLine","innerMode","defineMIME","typescript"],"mappings":"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","file":"../../../mode/jsx/jsx.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\ndefine([\"../../CodeMirror\", \"../xml/xml\", \"../javascript/javascript\"], function(CodeMirror) {\n  \"use strict\"\n\n  // Depth means the amount of open braces in JS context, in XML\n  // context 0 means not in tag, 1 means in tag, and 2 means in tag\n  // and js block comment.\n  function Context(state, mode, depth, prev) {\n    this.state = state; this.mode = mode; this.depth = depth; this.prev = prev\n  }\n\n  function copyContext(context) {\n    return new Context(CodeMirror.copyState(context.mode, context.state),\n                       context.mode,\n                       context.depth,\n                       context.prev && copyContext(context.prev))\n  }\n\n  CodeMirror.defineMode(\"jsx\", function(config, modeConfig) {\n    var xmlMode = CodeMirror.getMode(config, {name: \"xml\", allowMissing: true, multilineTagIndentPastTag: false, allowMissingTagName: true})\n    var jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || \"javascript\")\n\n    function flatXMLIndent(state) {\n      var tagName = state.tagName\n      state.tagName = null\n      var result = xmlMode.indent(state, \"\", \"\")\n      state.tagName = tagName\n      return result\n    }\n\n    function token(stream, state) {\n      if (state.context.mode == xmlMode)\n        return xmlToken(stream, state, state.context)\n      else\n        return jsToken(stream, state, state.context)\n    }\n\n    function xmlToken(stream, state, cx) {\n      if (cx.depth == 2) { // Inside a JS /* */ comment\n        if (stream.match(/^.*?\\*\\//)) cx.depth = 1\n        else stream.skipToEnd()\n        return \"comment\"\n      }\n\n      if (stream.peek() == \"{\") {\n        xmlMode.skipAttribute(cx.state)\n\n        var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context\n        // If JS starts on same line as tag\n        if (xmlContext && stream.match(/^[^>]*>\\s*$/, false)) {\n          while (xmlContext.prev && !xmlContext.startOfLine)\n            xmlContext = xmlContext.prev\n          // If tag starts the line, use XML indentation level\n          if (xmlContext.startOfLine) indent -= config.indentUnit\n          // Else use JS indentation level\n          else if (cx.prev.state.lexical) indent = cx.prev.state.lexical.indented\n        // Else if inside of tag\n        } else if (cx.depth == 1) {\n          indent += config.indentUnit\n        }\n\n        state.context = new Context(CodeMirror.startState(jsMode, indent),\n                                    jsMode, 0, state.context)\n        return null\n      }\n\n      if (cx.depth == 1) { // Inside of tag\n        if (stream.peek() == \"<\") { // Tag inside of tag\n          xmlMode.skipAttribute(cx.state)\n          state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)),\n                                      xmlMode, 0, state.context)\n          return null\n        } else if (stream.match(\"//\")) {\n          stream.skipToEnd()\n          return \"comment\"\n        } else if (stream.match(\"/*\")) {\n          cx.depth = 2\n          return token(stream, state)\n        }\n      }\n\n      var style = xmlMode.token(stream, cx.state), cur = stream.current(), stop\n      if (/\\btag\\b/.test(style)) {\n        if (/>$/.test(cur)) {\n          if (cx.state.context) cx.depth = 0\n          else state.context = state.context.prev\n        } else if (/^</.test(cur)) {\n          cx.depth = 1\n        }\n      } else if (!style && (stop = cur.indexOf(\"{\")) > -1) {\n        stream.backUp(cur.length - stop)\n      }\n      return style\n    }\n\n    function jsToken(stream, state, cx) {\n      if (stream.peek() == \"<\" && jsMode.expressionAllowed(stream, cx.state)) {\n        jsMode.skipExpression(cx.state)\n        state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, \"\", \"\")),\n                                    xmlMode, 0, state.context)\n        return null\n      }\n\n      var style = jsMode.token(stream, cx.state)\n      if (!style && cx.depth != null) {\n        var cur = stream.current()\n        if (cur == \"{\") {\n          cx.depth++\n        } else if (cur == \"}\") {\n          if (--cx.depth == 0) state.context = state.context.prev\n        }\n      }\n      return style\n    }\n\n    return {\n      startState: function() {\n        return {context: new Context(CodeMirror.startState(jsMode), jsMode)}\n      },\n\n      copyState: function(state) {\n        return {context: copyContext(state.context)}\n      },\n\n      token: token,\n\n      indent: function(state, textAfter, fullLine) {\n        return state.context.mode.indent(state.context.state, textAfter, fullLine)\n      },\n\n      innerMode: function(state) {\n        return state.context\n      }\n    }\n  }, \"xml\", \"javascript\")\n\n  CodeMirror.defineMIME(\"text/jsx\", \"jsx\")\n  CodeMirror.defineMIME(\"text/typescript-jsx\", {name: \"jsx\", base: {name: \"javascript\", typescript: true}})\n});\n"]}