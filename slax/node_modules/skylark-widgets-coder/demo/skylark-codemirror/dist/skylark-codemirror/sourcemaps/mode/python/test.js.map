{"version":3,"sources":["mode/python/test.js"],"names":["mode","CodeMirror","getMode","indentUnit","name","version","singleLineStringErrors","MT","test","Array","prototype","slice","call","arguments","before_equal_sign","i","length","c"],"mappings":";;;;;;;CAGA,WACE,IAAIA,EAAOC,WAAWC,SAASC,WAAY,IAC9BC,KAAM,SACNC,QAAS,EACTC,wBAAwB,IACrC,SAASC,EAAGH,GAAQI,KAAKR,KAAKI,EAAMJ,EAAMS,MAAMC,UAAUC,MAAMC,KAAKC,UAAW,IAIhFN,EAAG,uBACA,cACA,kCACA,sBAEHA,EAAG,oBACA,6BACA,kBACA,sCACA,0BAEHA,EAAG,mBAAoB,0CACvBA,EAAG,sBAAuB,wCAC1BA,EAAG,qBAAsB,yCAEzB,IADA,IAAIO,GAAqB,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KACnDC,EAAI,EAAGA,EAAID,EAAkBE,SAAUD,EAAG,CACjD,IAAIE,EAAIH,EAAkBC,GAC1BR,EAAG,qBAAuBU,EAAG,0BAA4BA,EAAI,mBAG/DV,EAAG,qBAAsB,8DACzBA,EAAG,4BAA6B,8EAChCA,EAAG,kBAAmB,4BACtBA,EAAG,iBAAkB,4GACrBA,EAAG,qBAAsB,yCAEzBA,EAAG,eAAgB,6EAEnBA,EAAG,kBAAmB,wDAEtBA,EAAG,gBAAiB,8EAvCtB","file":"../../../mode/python/test.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function() {\n  var mode = CodeMirror.getMode({indentUnit: 4},\n              {name: \"python\",\n               version: 3,\n               singleLineStringErrors: false});\n  function MT(name) { test.mode(name, mode, Array.prototype.slice.call(arguments, 1)); }\n\n  // Error, because \"foobarhello\" is neither a known type or property, but\n  // property was expected (after \"and\"), and it should be in parentheses.\n  MT(\"decoratorStartOfLine\",\n     \"[meta @dec]\",\n     \"[keyword def] [def function]():\",\n     \"    [keyword pass]\");\n\n  MT(\"decoratorIndented\",\n     \"[keyword class] [def Foo]:\",\n     \"    [meta @dec]\",\n     \"    [keyword def] [def function]():\",\n     \"        [keyword pass]\");\n\n  MT(\"matmulWithSpace:\", \"[variable a] [operator @] [variable b]\");\n  MT(\"matmulWithoutSpace:\", \"[variable a][operator @][variable b]\");\n  MT(\"matmulSpaceBefore:\", \"[variable a] [operator @][variable b]\");\n  var before_equal_sign = [\"+\", \"-\", \"*\", \"/\", \"=\", \"!\", \">\", \"<\"];\n  for (var i = 0; i < before_equal_sign.length; ++i) {\n    var c = before_equal_sign[i]\n    MT(\"before_equal_sign_\" + c, \"[variable a] [operator \" + c + \"=] [variable b]\");\n  }\n\n  MT(\"fValidStringPrefix\", \"[string f'this is a]{[variable formatted]}[string string']\");\n  MT(\"fValidExpressioninFString\", \"[string f'expression ]{[number 100][operator *][number 5]}[string string']\");\n  MT(\"fInvalidFString\", \"[error f'this is wrong}]\");\n  MT(\"fNestedFString\", \"[string f'expression ]{[number 100] [operator +] [string f'inner]{[number 5]}[string ']}[string string']\");\n  MT(\"uValidStringPrefix\", \"[string u'this is an unicode string']\");\n\n  MT(\"nestedString\", \"[string f']{[variable b][[ [string \\\"c\\\"] ]]}[string f'] [comment # oops]\")\n\n  MT(\"bracesInFString\", \"[string f']{[variable x] [operator +] {}}[string !']\")\n\n  MT(\"nestedFString\", \"[string f']{[variable b][[ [string f\\\"c\\\"] ]]}[string f'] [comment # oops]\")\n})();\n"]}