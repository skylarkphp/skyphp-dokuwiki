{"version":3,"sources":["mode/slim/slim.js"],"names":["define","CodeMirror","defineMode","config","htmlMode","getMode","name","rubyMode","modes","html","ruby","embedded","javascript","css","sass","scss","less","styl","coffee","asciidoc","markdown","textile","creole","wiki","mediawiki","rdoc","builder","nokogiri","erb","embeddedRegexp","map","arr","key","push","RegExp","join","styleMap","commentLine","slimSwitch","slimTag","slimId","slimClass","slimAttribute","slimSubmode","closeAttributeTag","slimDoctype","lineContinuation","closing","{","[","(","nameStartChar","nameChar","nameRegexp","attributeNameRegexp","wrappedAttributeNameRegexp","classNameRegexp","classIdRegexp","continueLine","state","column","stack","parent","style","indented","tokenize","line","finishContinue","rubyInQuote","endQuote","stream","peek","rubyState","length","next","startRubySplat","runSplat","context","prev","backUp","eatSpace","startState","token","match","pat","offset","cur","current","idx","search","pos","restore","backup","maybeBackup","htmlState","startHtmlLine","lastTokenize","htmlLine","eol","startHtmlMode","comment","skipToEnd","attributeWrapper","eat","attributeWrapperAssign","attributeWrapperValue","ch","readQuoted","sub","subStream","StringStream","string","slice","tabSize","start","lastColumnPos","lastColumnValue","subMode","subState","firstSub","mode","hasOwnProperty","query","spec","mimeModes","factory","createMode","doctypeLine","_state","startLine","commentMode","lineContinuable","m","startSubMode","slim","startOfLine","slimTagExtras","startAttributeWrapperMode","$1","slimAttributeAssign","slimContent","slimAttributeValue","slimAttributeSymbols","quote","embed","unescaped","nextTokenize","fresh","escaped","last","copyState","sol","indentation","blankLine","innerMode","defineMIME"],"mappings":"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","file":"../../../mode/slim/slim.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Slim Highlighting for CodeMirror copyright (c) HicknHack Software Gmbh\n\ndefine([\"../../CodeMirror\", \"../htmlmixed/htmlmixed\", \"../ruby/ruby\"], function(CodeMirror) {\n\"use strict\";\n\n  CodeMirror.defineMode(\"slim\", function(config) {\n    var htmlMode = CodeMirror.getMode(config, {name: \"htmlmixed\"});\n    var rubyMode = CodeMirror.getMode(config, \"ruby\");\n    var modes = { html: htmlMode, ruby: rubyMode };\n    var embedded = {\n      ruby: \"ruby\",\n      javascript: \"javascript\",\n      css: \"text/css\",\n      sass: \"text/x-sass\",\n      scss: \"text/x-scss\",\n      less: \"text/x-less\",\n      styl: \"text/x-styl\", // no highlighting so far\n      coffee: \"coffeescript\",\n      asciidoc: \"text/x-asciidoc\",\n      markdown: \"text/x-markdown\",\n      textile: \"text/x-textile\", // no highlighting so far\n      creole: \"text/x-creole\", // no highlighting so far\n      wiki: \"text/x-wiki\", // no highlighting so far\n      mediawiki: \"text/x-mediawiki\", // no highlighting so far\n      rdoc: \"text/x-rdoc\", // no highlighting so far\n      builder: \"text/x-builder\", // no highlighting so far\n      nokogiri: \"text/x-nokogiri\", // no highlighting so far\n      erb: \"application/x-erb\"\n    };\n    var embeddedRegexp = function(map){\n      var arr = [];\n      for(var key in map) arr.push(key);\n      return new RegExp(\"^(\"+arr.join('|')+\"):\");\n    }(embedded);\n\n    var styleMap = {\n      \"commentLine\": \"comment\",\n      \"slimSwitch\": \"operator special\",\n      \"slimTag\": \"tag\",\n      \"slimId\": \"attribute def\",\n      \"slimClass\": \"attribute qualifier\",\n      \"slimAttribute\": \"attribute\",\n      \"slimSubmode\": \"keyword special\",\n      \"closeAttributeTag\": null,\n      \"slimDoctype\": null,\n      \"lineContinuation\": null\n    };\n    var closing = {\n      \"{\": \"}\",\n      \"[\": \"]\",\n      \"(\": \")\"\n    };\n\n    var nameStartChar = \"_a-zA-Z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\";\n    var nameChar = nameStartChar + \"\\\\-0-9\\xB7\\u0300-\\u036F\\u203F-\\u2040\";\n    var nameRegexp = new RegExp(\"^[:\"+nameStartChar+\"](?::[\"+nameChar+\"]|[\"+nameChar+\"]*)\");\n    var attributeNameRegexp = new RegExp(\"^[:\"+nameStartChar+\"][:\\\\.\"+nameChar+\"]*(?=\\\\s*=)\");\n    var wrappedAttributeNameRegexp = new RegExp(\"^[:\"+nameStartChar+\"][:\\\\.\"+nameChar+\"]*\");\n    var classNameRegexp = /^\\.-?[_a-zA-Z]+[\\w\\-]*/;\n    var classIdRegexp = /^#[_a-zA-Z]+[\\w\\-]*/;\n\n    function backup(pos, tokenize, style) {\n      var restore = function(stream, state) {\n        state.tokenize = tokenize;\n        if (stream.pos < pos) {\n          stream.pos = pos;\n          return style;\n        }\n        return state.tokenize(stream, state);\n      };\n      return function(stream, state) {\n        state.tokenize = restore;\n        return tokenize(stream, state);\n      };\n    }\n\n    function maybeBackup(stream, state, pat, offset, style) {\n      var cur = stream.current();\n      var idx = cur.search(pat);\n      if (idx > -1) {\n        state.tokenize = backup(stream.pos, state.tokenize, style);\n        stream.backUp(cur.length - idx - offset);\n      }\n      return style;\n    }\n\n    function continueLine(state, column) {\n      state.stack = {\n        parent: state.stack,\n        style: \"continuation\",\n        indented: column,\n        tokenize: state.line\n      };\n      state.line = state.tokenize;\n    }\n    function finishContinue(state) {\n      if (state.line == state.tokenize) {\n        state.line = state.stack.tokenize;\n        state.stack = state.stack.parent;\n      }\n    }\n\n    function lineContinuable(column, tokenize) {\n      return function(stream, state) {\n        finishContinue(state);\n        if (stream.match(/^\\\\$/)) {\n          continueLine(state, column);\n          return \"lineContinuation\";\n        }\n        var style = tokenize(stream, state);\n        if (stream.eol() && stream.current().match(/(?:^|[^\\\\])(?:\\\\\\\\)*\\\\$/)) {\n          stream.backUp(1);\n        }\n        return style;\n      };\n    }\n    function commaContinuable(column, tokenize) {\n      return function(stream, state) {\n        finishContinue(state);\n        var style = tokenize(stream, state);\n        if (stream.eol() && stream.current().match(/,$/)) {\n          continueLine(state, column);\n        }\n        return style;\n      };\n    }\n\n    function rubyInQuote(endQuote, tokenize) {\n      // TODO: add multi line support\n      return function(stream, state) {\n        var ch = stream.peek();\n        if (ch == endQuote && state.rubyState.tokenize.length == 1) {\n          // step out of ruby context as it seems to complete processing all the braces\n          stream.next();\n          state.tokenize = tokenize;\n          return \"closeAttributeTag\";\n        } else {\n          return ruby(stream, state);\n        }\n      };\n    }\n    function startRubySplat(tokenize) {\n      var rubyState;\n      var runSplat = function(stream, state) {\n        if (state.rubyState.tokenize.length == 1 && !state.rubyState.context.prev) {\n          stream.backUp(1);\n          if (stream.eatSpace()) {\n            state.rubyState = rubyState;\n            state.tokenize = tokenize;\n            return tokenize(stream, state);\n          }\n          stream.next();\n        }\n        return ruby(stream, state);\n      };\n      return function(stream, state) {\n        rubyState = state.rubyState;\n        state.rubyState = CodeMirror.startState(rubyMode);\n        state.tokenize = runSplat;\n        return ruby(stream, state);\n      };\n    }\n\n    function ruby(stream, state) {\n      return rubyMode.token(stream, state.rubyState);\n    }\n\n    function htmlLine(stream, state) {\n      if (stream.match(/^\\\\$/)) {\n        return \"lineContinuation\";\n      }\n      return html(stream, state);\n    }\n    function html(stream, state) {\n      if (stream.match(/^#\\{/)) {\n        state.tokenize = rubyInQuote(\"}\", state.tokenize);\n        return null;\n      }\n      return maybeBackup(stream, state, /[^\\\\]#\\{/, 1, htmlMode.token(stream, state.htmlState));\n    }\n\n    function startHtmlLine(lastTokenize) {\n      return function(stream, state) {\n        var style = htmlLine(stream, state);\n        if (stream.eol()) state.tokenize = lastTokenize;\n        return style;\n      };\n    }\n\n    function startHtmlMode(stream, state, offset) {\n      state.stack = {\n        parent: state.stack,\n        style: \"html\",\n        indented: stream.column() + offset, // pipe + space\n        tokenize: state.line\n      };\n      state.line = state.tokenize = html;\n      return null;\n    }\n\n    function comment(stream, state) {\n      stream.skipToEnd();\n      return state.stack.style;\n    }\n\n    function commentMode(stream, state) {\n      state.stack = {\n        parent: state.stack,\n        style: \"comment\",\n        indented: state.indented + 1,\n        tokenize: state.line\n      };\n      state.line = comment;\n      return comment(stream, state);\n    }\n\n    function attributeWrapper(stream, state) {\n      if (stream.eat(state.stack.endQuote)) {\n        state.line = state.stack.line;\n        state.tokenize = state.stack.tokenize;\n        state.stack = state.stack.parent;\n        return null;\n      }\n      if (stream.match(wrappedAttributeNameRegexp)) {\n        state.tokenize = attributeWrapperAssign;\n        return \"slimAttribute\";\n      }\n      stream.next();\n      return null;\n    }\n    function attributeWrapperAssign(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = attributeWrapperValue;\n        return null;\n      }\n      return attributeWrapper(stream, state);\n    }\n    function attributeWrapperValue(stream, state) {\n      var ch = stream.peek();\n      if (ch == '\"' || ch == \"\\'\") {\n        state.tokenize = readQuoted(ch, \"string\", true, false, attributeWrapper);\n        stream.next();\n        return state.tokenize(stream, state);\n      }\n      if (ch == '[') {\n        return startRubySplat(attributeWrapper)(stream, state);\n      }\n      if (stream.match(/^(true|false|nil)\\b/)) {\n        state.tokenize = attributeWrapper;\n        return \"keyword\";\n      }\n      return startRubySplat(attributeWrapper)(stream, state);\n    }\n\n    function startAttributeWrapperMode(state, endQuote, tokenize) {\n      state.stack = {\n        parent: state.stack,\n        style: \"wrapper\",\n        indented: state.indented + 1,\n        tokenize: tokenize,\n        line: state.line,\n        endQuote: endQuote\n      };\n      state.line = state.tokenize = attributeWrapper;\n      return null;\n    }\n\n    function sub(stream, state) {\n      if (stream.match(/^#\\{/)) {\n        state.tokenize = rubyInQuote(\"}\", state.tokenize);\n        return null;\n      }\n      var subStream = new CodeMirror.StringStream(stream.string.slice(state.stack.indented), stream.tabSize);\n      subStream.pos = stream.pos - state.stack.indented;\n      subStream.start = stream.start - state.stack.indented;\n      subStream.lastColumnPos = stream.lastColumnPos - state.stack.indented;\n      subStream.lastColumnValue = stream.lastColumnValue - state.stack.indented;\n      var style = state.subMode.token(subStream, state.subState);\n      stream.pos = subStream.pos + state.stack.indented;\n      return style;\n    }\n    function firstSub(stream, state) {\n      state.stack.indented = stream.column();\n      state.line = state.tokenize = sub;\n      return state.tokenize(stream, state);\n    }\n\n    function createMode(mode) {\n      var query = embedded[mode];\n      var spec = CodeMirror.mimeModes[query];\n      if (spec) {\n        return CodeMirror.getMode(config, spec);\n      }\n      var factory = CodeMirror.modes[query];\n      if (factory) {\n        return factory(config, {name: query});\n      }\n      return CodeMirror.getMode(config, \"null\");\n    }\n\n    function getMode(mode) {\n      if (!modes.hasOwnProperty(mode)) {\n        return modes[mode] = createMode(mode);\n      }\n      return modes[mode];\n    }\n\n    function startSubMode(mode, state) {\n      var subMode = getMode(mode);\n      var subState = CodeMirror.startState(subMode);\n\n      state.subMode = subMode;\n      state.subState = subState;\n\n      state.stack = {\n        parent: state.stack,\n        style: \"sub\",\n        indented: state.indented + 1,\n        tokenize: state.line\n      };\n      state.line = state.tokenize = firstSub;\n      return \"slimSubmode\";\n    }\n\n    function doctypeLine(stream, _state) {\n      stream.skipToEnd();\n      return \"slimDoctype\";\n    }\n\n    function startLine(stream, state) {\n      var ch = stream.peek();\n      if (ch == '<') {\n        return (state.tokenize = startHtmlLine(state.tokenize))(stream, state);\n      }\n      if (stream.match(/^[|']/)) {\n        return startHtmlMode(stream, state, 1);\n      }\n      if (stream.match(/^\\/(!|\\[\\w+])?/)) {\n        return commentMode(stream, state);\n      }\n      if (stream.match(/^(-|==?[<>]?)/)) {\n        state.tokenize = lineContinuable(stream.column(), commaContinuable(stream.column(), ruby));\n        return \"slimSwitch\";\n      }\n      if (stream.match(/^doctype\\b/)) {\n        state.tokenize = doctypeLine;\n        return \"keyword\";\n      }\n\n      var m = stream.match(embeddedRegexp);\n      if (m) {\n        return startSubMode(m[1], state);\n      }\n\n      return slimTag(stream, state);\n    }\n\n    function slim(stream, state) {\n      if (state.startOfLine) {\n        return startLine(stream, state);\n      }\n      return slimTag(stream, state);\n    }\n\n    function slimTag(stream, state) {\n      if (stream.eat('*')) {\n        state.tokenize = startRubySplat(slimTagExtras);\n        return null;\n      }\n      if (stream.match(nameRegexp)) {\n        state.tokenize = slimTagExtras;\n        return \"slimTag\";\n      }\n      return slimClass(stream, state);\n    }\n    function slimTagExtras(stream, state) {\n      if (stream.match(/^(<>?|><?)/)) {\n        state.tokenize = slimClass;\n        return null;\n      }\n      return slimClass(stream, state);\n    }\n    function slimClass(stream, state) {\n      if (stream.match(classIdRegexp)) {\n        state.tokenize = slimClass;\n        return \"slimId\";\n      }\n      if (stream.match(classNameRegexp)) {\n        state.tokenize = slimClass;\n        return \"slimClass\";\n      }\n      return slimAttribute(stream, state);\n    }\n    function slimAttribute(stream, state) {\n      if (stream.match(/^([\\[\\{\\(])/)) {\n        return startAttributeWrapperMode(state, closing[RegExp.$1], slimAttribute);\n      }\n      if (stream.match(attributeNameRegexp)) {\n        state.tokenize = slimAttributeAssign;\n        return \"slimAttribute\";\n      }\n      if (stream.peek() == '*') {\n        stream.next();\n        state.tokenize = startRubySplat(slimContent);\n        return null;\n      }\n      return slimContent(stream, state);\n    }\n    function slimAttributeAssign(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = slimAttributeValue;\n        return null;\n      }\n      // should never happen, because of forward lookup\n      return slimAttribute(stream, state);\n    }\n\n    function slimAttributeValue(stream, state) {\n      var ch = stream.peek();\n      if (ch == '\"' || ch == \"\\'\") {\n        state.tokenize = readQuoted(ch, \"string\", true, false, slimAttribute);\n        stream.next();\n        return state.tokenize(stream, state);\n      }\n      if (ch == '[') {\n        return startRubySplat(slimAttribute)(stream, state);\n      }\n      if (ch == ':') {\n        return startRubySplat(slimAttributeSymbols)(stream, state);\n      }\n      if (stream.match(/^(true|false|nil)\\b/)) {\n        state.tokenize = slimAttribute;\n        return \"keyword\";\n      }\n      return startRubySplat(slimAttribute)(stream, state);\n    }\n    function slimAttributeSymbols(stream, state) {\n      stream.backUp(1);\n      if (stream.match(/^[^\\s],(?=:)/)) {\n        state.tokenize = startRubySplat(slimAttributeSymbols);\n        return null;\n      }\n      stream.next();\n      return slimAttribute(stream, state);\n    }\n    function readQuoted(quote, style, embed, unescaped, nextTokenize) {\n      return function(stream, state) {\n        finishContinue(state);\n        var fresh = stream.current().length == 0;\n        if (stream.match(/^\\\\$/, fresh)) {\n          if (!fresh) return style;\n          continueLine(state, state.indented);\n          return \"lineContinuation\";\n        }\n        if (stream.match(/^#\\{/, fresh)) {\n          if (!fresh) return style;\n          state.tokenize = rubyInQuote(\"}\", state.tokenize);\n          return null;\n        }\n        var escaped = false, ch;\n        while ((ch = stream.next()) != null) {\n          if (ch == quote && (unescaped || !escaped)) {\n            state.tokenize = nextTokenize;\n            break;\n          }\n          if (embed && ch == \"#\" && !escaped) {\n            if (stream.eat(\"{\")) {\n              stream.backUp(2);\n              break;\n            }\n          }\n          escaped = !escaped && ch == \"\\\\\";\n        }\n        if (stream.eol() && escaped) {\n          stream.backUp(1);\n        }\n        return style;\n      };\n    }\n    function slimContent(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = ruby;\n        return \"slimSwitch\";\n      }\n      if (stream.match(/^\\/$/)) { // tag close hint\n        state.tokenize = slim;\n        return null;\n      }\n      if (stream.match(/^:/)) { // inline tag\n        state.tokenize = slimTag;\n        return \"slimSwitch\";\n      }\n      startHtmlMode(stream, state, 0);\n      return state.tokenize(stream, state);\n    }\n\n    var mode = {\n      // default to html mode\n      startState: function() {\n        var htmlState = CodeMirror.startState(htmlMode);\n        var rubyState = CodeMirror.startState(rubyMode);\n        return {\n          htmlState: htmlState,\n          rubyState: rubyState,\n          stack: null,\n          last: null,\n          tokenize: slim,\n          line: slim,\n          indented: 0\n        };\n      },\n\n      copyState: function(state) {\n        return {\n          htmlState : CodeMirror.copyState(htmlMode, state.htmlState),\n          rubyState: CodeMirror.copyState(rubyMode, state.rubyState),\n          subMode: state.subMode,\n          subState: state.subMode && CodeMirror.copyState(state.subMode, state.subState),\n          stack: state.stack,\n          last: state.last,\n          tokenize: state.tokenize,\n          line: state.line\n        };\n      },\n\n      token: function(stream, state) {\n        if (stream.sol()) {\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n          state.tokenize = state.line;\n          while (state.stack && state.stack.indented > state.indented && state.last != \"slimSubmode\") {\n            state.line = state.tokenize = state.stack.tokenize;\n            state.stack = state.stack.parent;\n            state.subMode = null;\n            state.subState = null;\n          }\n        }\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        state.startOfLine = false;\n        if (style) state.last = style;\n        return styleMap.hasOwnProperty(style) ? styleMap[style] : style;\n      },\n\n      blankLine: function(state) {\n        if (state.subMode && state.subMode.blankLine) {\n          return state.subMode.blankLine(state.subState);\n        }\n      },\n\n      innerMode: function(state) {\n        if (state.subMode) return {state: state.subState, mode: state.subMode};\n        return {state: state, mode: mode};\n      }\n\n      //indent: function(state) {\n      //  return state.indented;\n      //}\n    };\n    return mode;\n  }, \"htmlmixed\", \"ruby\");\n\n  CodeMirror.defineMIME(\"text/x-slim\", \"slim\");\n  CodeMirror.defineMIME(\"application/x-slim\", \"slim\");\n});\n"]}