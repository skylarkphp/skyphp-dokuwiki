{"version":3,"sources":["primitives/edit/methods.js"],"names":["define","m_deleteNearSelection","m_commands","m_document_data","dom","events","highlight","indent","m_input","key_events","mouse_events","keymap","movement","operations","line_pos","position_measurement","selection","selection_updates","scrolling","line_spans","update_display","misc","operation_group","utils_line","view_tracking","m_highlight_worker","m_line_numbers","m_scrollbars","findPosH","doc","pos","dir","unit","visually","oldPos","origDir","lineObj","getLine","line","moveOnce","boundToLine","next","moveVisually","cm","moveLogically","l","first","size","Pos","ch","sticky","findNextLine","endOfLine","sawType","group","helper","getHelper","cur","text","charAt","type","isWordChar","test","result","skipAtomic","equalCursorPos","hitSide","findPosV","y","target","x","left","pageSize","Math","min","display","wrapper","clientHeight","window","innerHeight","document","documentElement","moveAmount","max","textHeight","bottom","top","coordsChar","outside","height","CodeMirror","optionHandlers","helpers","prototype","constructor","focus","this","input","setOption","option","value","options","old","hasOwnProperty","operation","signal","getOption","getDoc","addKeyMap","map","state","keyMaps","getKeyMap","removeKeyMap","maps","i","length","name","splice","addOverlay","methodOp","spec","mode","token","getMode","startState","Error","insertSorted","overlays","modeSpec","opaque","priority","overlay","modeGen","regChange","removeOverlay","indentLine","n","aggressive","smartIndent","isLine","indentSelection","how","ranges","sel","end","range","empty","head","primIndex","ensureCursorVisible","from","to","start","lastLine","j","newRanges","replaceOneSelection","Range","sel_dontScroll","getTokenAt","precise","takeToken","getLineTokens","getTokenTypeAt","clipPos","styles","getLineStyles","before","after","mid","cut","indexOf","slice","getModeAt","innerMode","getHelpers","found","help","push","val","helperType","_global","pred","getStateAfter","clipLine","getContextBefore","cursorCoords","primary","charCoords","coords","fromCoordSystem","lineAtHeight","viewOffset","heightAtLine","includeWidgets","last","intoCoordSystem","defaultTextHeight","defaultCharWidth","charWidth","getViewport","viewFrom","viewTo","addWidget","node","scroll","vert","horiz","style","position","setAttribute","setUneditable","sizer","appendChild","vspace","hspace","clientWidth","lineSpace","offsetHeight","offsetWidth","right","scrollIntoView","triggerOnKeyDown","onKeyDown","triggerOnKeyPress","onKeyPress","triggerOnKeyUp","onKeyUp","triggerOnMouseDown","onMouseDown","execCommand","cmd","commands","call","triggerElectric","amount","moveH","extendSelectionsBy","shift","extend","rtlMoveVisually","sel_move","deleteH","somethingSelected","replaceSelection","deleteNearSelection","other","goalColumn","moveV","goals","collapse","headPos","addToScrollTop","findWordAt","startChar","check","toggleOverwrite","overwrite","addClass","cursorDiv","rmClass","hasFocus","getField","activeElt","isReadOnly","readOnly","cantEdit","scrollTo","scrollToCoords","getScrollInfo","scroller","scrollLeft","scrollTop","scrollHeight","scrollGap","barHeight","width","scrollWidth","barWidth","displayHeight","displayWidth","margin","cursorScrollMargin","scrollToRange","scrollToCoordsRange","setSize","interpret","String","lineWrapping","clearLineMeasurementCache","lineNo","iter","widgets","noHScroll","regLineChange","curOp","forceUpdate","f","runInOp","startOperation","endOperation","refresh","oldHeight","cachedTextHeight","clearCaches","updateGutterSpace","abs","estimateLineHeights","swapDoc","attachDoc","reset","forceScroll","signalLater","phrase","phraseText","phrases","Object","getInputField","getWrapperElement","getScrollerElement","getGutterElement","gutters","startWorker","time","maybeUpdateLineNumberWidth","measureForScrollbars","updateScrollbars","measure","eventMixin","registerHelper","registerGlobalHelper","predicate"],"mappings":"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","file":"../../../primitives/edit/methods.js","sourcesContent":["define([\n    './deleteNearSelection',\n    './commands',\n    '../model/document_data',\n    '../util/dom',\n    '../util/event',\n    '../line/highlight',\n    '../input/indent',\n    '../input/input',\n    './key_events',\n    './mouse_events',\n    '../input/keymap',\n    '../input/movement',\n    '../display/operations',\n    '../line/pos',\n    '../measurement/position_measurement',\n    '../model/selection',\n    '../model/selection_updates',\n    '../display/scrolling',\n    '../line/spans',\n    '../display/update_display',\n    '../util/misc',\n    '../util/operation_group',\n    '../line/utils_line',\n    '../display/view_tracking',\n    '../display/highlight_worker',\n    '../display/line_numbers',\n    '../display/scrollbars'\n], function (\n    m_deleteNearSelection, \n    m_commands, \n    m_document_data, \n    dom, \n    events, \n    highlight, \n    indent, \n    m_input, \n    key_events, \n    mouse_events, \n    keymap, \n    movement, \n    operations, \n    line_pos, \n    position_measurement, \n    selection, \n    selection_updates, \n    scrolling, \n    line_spans, \n    update_display, \n    misc, \n    operation_group, \n    utils_line, \n    view_tracking,\n    m_highlight_worker,\n    m_line_numbers,\n    m_scrollbars\n) {\n    'use strict';\n\n    function findPosH(doc, pos, dir, unit, visually) {\n        let oldPos = pos;\n        let origDir = dir;\n        let lineObj = utils_line.getLine(doc, pos.line);\n        function findNextLine() {\n            let l = pos.line + dir;\n            if (l < doc.first || l >= doc.first + doc.size)\n                return false;\n            pos = new line_pos.Pos(l, pos.ch, pos.sticky);\n            return lineObj = utils_line.getLine(doc, l);\n        }\n        function moveOnce(boundToLine) {\n            let next;\n            if (visually) {\n                next = movement.moveVisually(doc.cm, lineObj, pos, dir);\n            } else {\n                next = movement.moveLogically(lineObj, pos, dir);\n            }\n            if (next == null) {\n                if (!boundToLine && findNextLine())\n                    pos = movement.endOfLine(visually, doc.cm, lineObj, pos.line, dir);\n                else\n                    return false;\n            } else {\n                pos = next;\n            }\n            return true;\n        }\n        if (unit == 'char') {\n            moveOnce();\n        } else if (unit == 'column') {\n            moveOnce(true);\n        } else if (unit == 'word' || unit == 'group') {\n            let sawType = null, group = unit == 'group';\n            let helper = doc.cm && doc.cm.getHelper(pos, 'wordChars');\n            for (let first = true;; first = false) {\n                if (dir < 0 && !moveOnce(!first))\n                    break;\n                let cur = lineObj.text.charAt(pos.ch) || '\\n';\n                let type = misc.isWordChar(cur, helper) ? 'w' : group && cur == '\\n' ? 'n' : !group || /\\s/.test(cur) ? null : 'p';\n                if (group && !first && !type)\n                    type = 's';\n                if (sawType && sawType != type) {\n                    if (dir < 0) {\n                        dir = 1;\n                        moveOnce();\n                        pos.sticky = 'after';\n                    }\n                    break;\n                }\n                if (type)\n                    sawType = type;\n                if (dir > 0 && !moveOnce(!first))\n                    break;\n            }\n        }\n        let result = selection_updates.skipAtomic(doc, pos, oldPos, origDir, true);\n        if (line_pos.equalCursorPos(oldPos, result))\n            result.hitSide = true;\n        return result;\n    }\n    function findPosV(cm, pos, dir, unit) {\n        let doc = cm.doc, x = pos.left, y;\n        if (unit == 'page') {\n            let pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n            let moveAmount = Math.max(pageSize - 0.5 * position_measurement.textHeight(cm.display), 3);\n            y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n        } else if (unit == 'line') {\n            y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n        }\n        let target;\n        for (;;) {\n            target = position_measurement.coordsChar(cm, x, y);\n            if (!target.outside)\n                break;\n            if (dir < 0 ? y <= 0 : y >= doc.height) {\n                target.hitSide = true;\n                break;\n            }\n            y += dir * 5;\n        }\n        return target;\n    }\n        \n    return function (CodeMirror) {\n        let optionHandlers = CodeMirror.optionHandlers;\n        let helpers = CodeMirror.helpers = {};\n        CodeMirror.prototype = {\n            constructor: CodeMirror,\n            focus: function () {\n                window.focus();\n                this.display.input.focus();\n            },\n            setOption: function (option, value) {\n                let options = this.options, old = options[option];\n                if (options[option] == value && option != 'mode')\n                    return;\n                options[option] = value;\n                if (optionHandlers.hasOwnProperty(option))\n                    operations.operation(this, optionHandlers[option])(this, value, old);\n                events.signal(this, 'optionChange', this, option);\n            },\n            getOption: function (option) {\n                return this.options[option];\n            },\n            getDoc: function () {\n                return this.doc;\n            },\n            addKeyMap: function (map, bottom) {\n                this.state.keyMaps[bottom ? 'push' : 'unshift'](keymap.getKeyMap(map));\n            },\n            removeKeyMap: function (map) {\n                let maps = this.state.keyMaps;\n                for (let i = 0; i < maps.length; ++i)\n                    if (maps[i] == map || maps[i].name == map) {\n                        maps.splice(i, 1);\n                        return true;\n                    }\n            },\n            addOverlay: operations.methodOp(function (spec, options) {\n                let mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n                if (mode.startState)\n                    throw new Error('Overlays may not be stateful.');\n                misc.insertSorted(this.state.overlays, {\n                    mode: mode,\n                    modeSpec: spec,\n                    opaque: options && options.opaque,\n                    priority: options && options.priority || 0\n                }, overlay => overlay.priority);\n                this.state.modeGen++;\n                view_tracking.regChange(this);\n            }),\n            removeOverlay: operations.methodOp(function (spec) {\n                let overlays = this.state.overlays;\n                for (let i = 0; i < overlays.length; ++i) {\n                    let cur = overlays[i].modeSpec;\n                    if (cur == spec || typeof spec == 'string' && cur.name == spec) {\n                        overlays.splice(i, 1);\n                        this.state.modeGen++;\n                        view_tracking.regChange(this);\n                        return;\n                    }\n                }\n            }),\n            indentLine: operations.methodOp(function (n, dir, aggressive) {\n                if (typeof dir != 'string' && typeof dir != 'number') {\n                    if (dir == null)\n                        dir = this.options.smartIndent ? 'smart' : 'prev';\n                    else\n                        dir = dir ? 'add' : 'subtract';\n                }\n                if (utils_line.isLine(this.doc, n))\n                    indent.indentLine(this, n, dir, aggressive);\n            }),\n            indentSelection: operations.methodOp(function (how) {\n                let ranges = this.doc.sel.ranges, end = -1;\n                for (let i = 0; i < ranges.length; i++) {\n                    let range = ranges[i];\n                    if (!range.empty()) {\n                        let from = range.from(), to = range.to();\n                        let start = Math.max(end, from.line);\n                        end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n                        for (let j = start; j < end; ++j)\n                            indent.indentLine(this, j, how);\n                        let newRanges = this.doc.sel.ranges;\n                        if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n                            selection_updates.replaceOneSelection(this.doc, i, new selection.Range(from, newRanges[i].to()), misc.sel_dontScroll);\n                    } else if (range.head.line > end) {\n                        indent.indentLine(this, range.head.line, how, true);\n                        end = range.head.line;\n                        if (i == this.doc.sel.primIndex)\n                            scrolling.ensureCursorVisible(this);\n                    }\n                }\n            }),\n            getTokenAt: function (pos, precise) {\n                return highlight.takeToken(this, pos, precise);\n            },\n            getLineTokens: function (line, precise) {\n                return highlight.takeToken(this, line_pos.Pos(line), precise, true);\n            },\n            getTokenTypeAt: function (pos) {\n                pos = line_pos.clipPos(this.doc, pos);\n                let styles = highlight.getLineStyles(this, utils_line.getLine(this.doc, pos.line));\n                let before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n                let type;\n                if (ch == 0)\n                    type = styles[2];\n                else\n                    for (;;) {\n                        let mid = before + after >> 1;\n                        if ((mid ? styles[mid * 2 - 1] : 0) >= ch)\n                            after = mid;\n                        else if (styles[mid * 2 + 1] < ch)\n                            before = mid + 1;\n                        else {\n                            type = styles[mid * 2 + 2];\n                            break;\n                        }\n                    }\n                let cut = type ? type.indexOf('overlay ') : -1;\n                return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n            },\n            getModeAt: function (pos) {\n                let mode = this.doc.mode;\n                if (!mode.innerMode)\n                    return mode;\n                return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n            },\n            getHelper: function (pos, type) {\n                return this.getHelpers(pos, type)[0];\n            },\n            getHelpers: function (pos, type) {\n                let found = [];\n                if (!helpers.hasOwnProperty(type))\n                    return found;\n                let help = helpers[type], mode = this.getModeAt(pos);\n                if (typeof mode[type] == 'string') {\n                    if (help[mode[type]])\n                        found.push(help[mode[type]]);\n                } else if (mode[type]) {\n                    for (let i = 0; i < mode[type].length; i++) {\n                        let val = help[mode[type][i]];\n                        if (val)\n                            found.push(val);\n                    }\n                } else if (mode.helperType && help[mode.helperType]) {\n                    found.push(help[mode.helperType]);\n                } else if (help[mode.name]) {\n                    found.push(help[mode.name]);\n                }\n                for (let i = 0; i < help._global.length; i++) {\n                    let cur = help._global[i];\n                    if (cur.pred(mode, this) && misc.indexOf(found, cur.val) == -1)\n                        found.push(cur.val);\n                }\n                return found;\n            },\n            getStateAfter: function (line, precise) {\n                let doc = this.doc;\n                line = line_pos.clipLine(doc, line == null ? doc.first + doc.size - 1 : line);\n                return highlight.getContextBefore(this, line + 1, precise).state;\n            },\n            cursorCoords: function (start, mode) {\n                let pos, range = this.doc.sel.primary();\n                if (start == null)\n                    pos = range.head;\n                else if (typeof start == 'object')\n                    pos = line_pos.clipPos(this.doc, start);\n                else\n                    pos = start ? range.from() : range.to();\n                return position_measurement.cursorCoords(this, pos, mode || 'page');\n            },\n            charCoords: function (pos, mode) {\n                return position_measurement.charCoords(this, line_pos.clipPos(this.doc, pos), mode || 'page');\n            },\n            coordsChar: function (coords, mode) {\n                coords = position_measurement.fromCoordSystem(this, coords, mode || 'page');\n                return position_measurement.coordsChar(this, coords.left, coords.top);\n            },\n            lineAtHeight: function (height, mode) {\n                height = position_measurement.fromCoordSystem(this, {\n                    top: height,\n                    left: 0\n                }, mode || 'page').top;\n                return utils_line.lineAtHeight(this.doc, height + this.display.viewOffset);\n            },\n            heightAtLine: function (line, mode, includeWidgets) {\n                let end = false, lineObj;\n                if (typeof line == 'number') {\n                    let last = this.doc.first + this.doc.size - 1;\n                    if (line < this.doc.first)\n                        line = this.doc.first;\n                    else if (line > last) {\n                        line = last;\n                        end = true;\n                    }\n                    lineObj = utils_line.getLine(this.doc, line);\n                } else {\n                    lineObj = line;\n                }\n                return position_measurement.intoCoordSystem(this, lineObj, {\n                    top: 0,\n                    left: 0\n                }, mode || 'page', includeWidgets || end).top + (end ? this.doc.height - line_spans.heightAtLine(lineObj) : 0);\n            },\n            defaultTextHeight: function () {\n                return position_measurement.textHeight(this.display);\n            },\n            defaultCharWidth: function () {\n                return position_measurement.charWidth(this.display);\n            },\n            getViewport: function () {\n                return {\n                    from: this.display.viewFrom,\n                    to: this.display.viewTo\n                };\n            },\n            addWidget: function (pos, node, scroll, vert, horiz) {\n                let display = this.display;\n                pos = position_measurement.cursorCoords(this, line_pos.clipPos(this.doc, pos));\n                let top = pos.bottom, left = pos.left;\n                node.style.position = 'absolute';\n                node.setAttribute('cm-ignore-events', 'true');\n                this.display.input.setUneditable(node);\n                display.sizer.appendChild(node);\n                if (vert == 'over') {\n                    top = pos.top;\n                } else if (vert == 'above' || vert == 'near') {\n                    let vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n                    if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n                        top = pos.top - node.offsetHeight;\n                    else if (pos.bottom + node.offsetHeight <= vspace)\n                        top = pos.bottom;\n                    if (left + node.offsetWidth > hspace)\n                        left = hspace - node.offsetWidth;\n                }\n                node.style.top = top + 'px';\n                node.style.left = node.style.right = '';\n                if (horiz == 'right') {\n                    left = display.sizer.clientWidth - node.offsetWidth;\n                    node.style.right = '0px';\n                } else {\n                    if (horiz == 'left')\n                        left = 0;\n                    else if (horiz == 'middle')\n                        left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n                    node.style.left = left + 'px';\n                }\n                if (scroll)\n                    scrolling.scrollIntoView(this, {\n                        left,\n                        top,\n                        right: left + node.offsetWidth,\n                        bottom: top + node.offsetHeight\n                    });\n            },\n            triggerOnKeyDown: operations.methodOp(key_events.onKeyDown),\n            triggerOnKeyPress: operations.methodOp(key_events.onKeyPress),\n            triggerOnKeyUp: key_events.onKeyUp,\n            triggerOnMouseDown: operations.methodOp(mouse_events.onMouseDown),\n            execCommand: function (cmd) {\n                if (m_commands.commands.hasOwnProperty(cmd))\n                    return m_commands.commands[cmd].call(null, this);\n            },\n            triggerElectric: operations.methodOp(function (text) {\n                m_input.triggerElectric(this, text);\n            }),\n            findPosH: function (from, amount, unit, visually) {\n                let dir = 1;\n                if (amount < 0) {\n                    dir = -1;\n                    amount = -amount;\n                }\n                let cur = line_pos.clipPos(this.doc, from);\n                for (let i = 0; i < amount; ++i) {\n                    cur = findPosH(this.doc, cur, dir, unit, visually);\n                    if (cur.hitSide)\n                        break;\n                }\n                return cur;\n            },\n            moveH: operations.methodOp(function (dir, unit) {\n                this.extendSelectionsBy(range => {\n                    if (this.display.shift || this.doc.extend || range.empty())\n                        return findPosH(this.doc, range.head, dir, unit, this.options.rtlMoveVisually);\n                    else\n                        return dir < 0 ? range.from() : range.to();\n                }, misc.sel_move);\n            }),\n            deleteH: operations.methodOp(function (dir, unit) {\n                let sel = this.doc.sel, doc = this.doc;\n                if (sel.somethingSelected())\n                    doc.replaceSelection('', null, '+delete');\n                else\n                    m_deleteNearSelection.deleteNearSelection(this, range => {\n                        let other = findPosH(doc, range.head, dir, unit, false);\n                        return dir < 0 ? {\n                            from: other,\n                            to: range.head\n                        } : {\n                            from: range.head,\n                            to: other\n                        };\n                    });\n            }),\n            findPosV: function (from, amount, unit, goalColumn) {\n                let dir = 1, x = goalColumn;\n                if (amount < 0) {\n                    dir = -1;\n                    amount = -amount;\n                }\n                let cur = line_pos.clipPos(this.doc, from);\n                for (let i = 0; i < amount; ++i) {\n                    let coords = position_measurement.cursorCoords(this, cur, 'div');\n                    if (x == null)\n                        x = coords.left;\n                    else\n                        coords.left = x;\n                    cur = findPosV(this, coords, dir, unit);\n                    if (cur.hitSide)\n                        break;\n                }\n                return cur;\n            },\n            moveV: operations.methodOp(function (dir, unit) {\n                let doc = this.doc, goals = [];\n                let collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n                doc.extendSelectionsBy(range => {\n                    if (collapse)\n                        return dir < 0 ? range.from() : range.to();\n                    let headPos = position_measurement.cursorCoords(this, range.head, 'div');\n                    if (range.goalColumn != null)\n                        headPos.left = range.goalColumn;\n                    goals.push(headPos.left);\n                    let pos = findPosV(this, headPos, dir, unit);\n                    if (unit == 'page' && range == doc.sel.primary())\n                        scrolling.addToScrollTop(this, position_measurement.charCoords(this, pos, 'div').top - headPos.top);\n                    return pos;\n                }, misc.sel_move);\n                if (goals.length)\n                    for (let i = 0; i < doc.sel.ranges.length; i++)\n                        doc.sel.ranges[i].goalColumn = goals[i];\n            }),\n            findWordAt: function (pos) {\n                let doc = this.doc, line = utils_line.getLine(doc, pos.line).text;\n                let start = pos.ch, end = pos.ch;\n                if (line) {\n                    let helper = this.getHelper(pos, 'wordChars');\n                    if ((pos.sticky == 'before' || end == line.length) && start)\n                        --start;\n                    else\n                        ++end;\n                    let startChar = line.charAt(start);\n                    let check = misc.isWordChar(startChar, helper) ? ch => misc.isWordChar(ch, helper) : /\\s/.test(startChar) ? ch => /\\s/.test(ch) : ch => !/\\s/.test(ch) && !misc.isWordChar(ch);\n                    while (start > 0 && check(line.charAt(start - 1)))\n                        --start;\n                    while (end < line.length && check(line.charAt(end)))\n                        ++end;\n                }\n                return new selection.Range(line_pos.Pos(pos.line, start), line_pos.Pos(pos.line, end));\n            },\n            toggleOverwrite: function (value) {\n                if (value != null && value == this.state.overwrite)\n                    return;\n                if (this.state.overwrite = !this.state.overwrite)\n                    dom.addClass(this.display.cursorDiv, 'CodeMirror-overwrite');\n                else\n                    dom.rmClass(this.display.cursorDiv, 'CodeMirror-overwrite');\n                events.signal(this, 'overwriteToggle', this, this.state.overwrite);\n            },\n            hasFocus: function () {\n                return this.display.input.getField() == dom.activeElt();\n            },\n            isReadOnly: function () {\n                return !!(this.options.readOnly || this.doc.cantEdit);\n            },\n            scrollTo: operations.methodOp(function (x, y) {\n                scrolling.scrollToCoords(this, x, y);\n            }),\n            getScrollInfo: function () {\n                let scroller = this.display.scroller;\n                return {\n                    left: scroller.scrollLeft,\n                    top: scroller.scrollTop,\n                    height: scroller.scrollHeight - position_measurement.scrollGap(this) - this.display.barHeight,\n                    width: scroller.scrollWidth - position_measurement.scrollGap(this) - this.display.barWidth,\n                    clientHeight: position_measurement.displayHeight(this),\n                    clientWidth: position_measurement.displayWidth(this)\n                };\n            },\n            scrollIntoView: operations.methodOp(function (range, margin) {\n                if (range == null) {\n                    range = {\n                        from: this.doc.sel.primary().head,\n                        to: null\n                    };\n                    if (margin == null)\n                        margin = this.options.cursorScrollMargin;\n                } else if (typeof range == 'number') {\n                    range = {\n                        from: line_pos.Pos(range, 0),\n                        to: null\n                    };\n                } else if (range.from == null) {\n                    range = {\n                        from: range,\n                        to: null\n                    };\n                }\n                if (!range.to)\n                    range.to = range.from;\n                range.margin = margin || 0;\n                if (range.from.line != null) {\n                    scrolling.scrollToRange(this, range);\n                } else {\n                    scrolling.scrollToCoordsRange(this, range.from, range.to, range.margin);\n                }\n            }),\n            setSize: operations.methodOp(function (width, height) {\n                let interpret = val => typeof val == 'number' || /^\\d+$/.test(String(val)) ? val + 'px' : val;\n                if (width != null)\n                    this.display.wrapper.style.width = interpret(width);\n                if (height != null)\n                    this.display.wrapper.style.height = interpret(height);\n                if (this.options.lineWrapping)\n                    position_measurement.clearLineMeasurementCache(this);\n                let lineNo = this.display.viewFrom;\n                this.doc.iter(lineNo, this.display.viewTo, line => {\n                    if (line.widgets)\n                        for (let i = 0; i < line.widgets.length; i++)\n                            if (line.widgets[i].noHScroll) {\n                                view_tracking.regLineChange(this, lineNo, 'widget');\n                                break;\n                            }\n                    ++lineNo;\n                });\n                this.curOp.forceUpdate = true;\n                events.signal(this, 'refresh', this);\n            }),\n            operation: function (f) {\n                return operations.runInOp(this, f);\n            },\n            startOperation: function () {\n                return operations.startOperation(this);\n            },\n            endOperation: function () {\n                return operations.endOperation(this);\n            },\n            refresh: operations.methodOp(function () {\n                let oldHeight = this.display.cachedTextHeight;\n                view_tracking.regChange(this);\n                this.curOp.forceUpdate = true;\n                position_measurement.clearCaches(this);\n                scrolling.scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n                update_display.updateGutterSpace(this);\n                if (oldHeight == null || Math.abs(oldHeight - position_measurement.textHeight(this.display)) > 0.5)\n                    position_measurement.estimateLineHeights(this);\n                events.signal(this, 'refresh', this);\n            }),\n            swapDoc: operations.methodOp(function (doc) {\n                let old = this.doc;\n                old.cm = null;\n                m_document_data.attachDoc(this, doc);\n                position_measurement.clearCaches(this);\n                this.display.input.reset();\n                scrolling.scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n                this.curOp.forceScroll = true;\n                operation_group.signalLater(this, 'swapDoc', this, old);\n                return old;\n            }),\n            phrase: function (phraseText) {\n                let phrases = this.options.phrases;\n                return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;\n            },\n            getInputField: function () {\n                return this.display.input.getField();\n            },\n            getWrapperElement: function () {\n                return this.display.wrapper;\n            },\n            getScrollerElement: function () {\n                return this.display.scroller;\n            },\n            getGutterElement: function () {\n                return this.display.gutters;\n            },\n\n            startWorker : function(time) {\n                return m_highlight_worker.startWorker(this,time);\n            },\n\n            maybeUpdateLineNumberWidth : function() {\n                return m_line_numbers.maybeUpdateLineNumberWidth(this);\n            },\n\n            measureForScrollbars : function() {\n                return m_scrollbars.measureForScrollbars(this);\n            },\n\n            updateScrollbars : function(measure) {\n                return m_scrollbars.updateScrollbars(this,measure);\n            }\n        };\n        events.eventMixin(CodeMirror);\n        CodeMirror.registerHelper = function (type, name, value) {\n            if (!helpers.hasOwnProperty(type))\n                helpers[type] = CodeMirror[type] = { _global: [] };\n            helpers[type][name] = value;\n        };\n        CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {\n            CodeMirror.registerHelper(type, name, value);\n            helpers[type]._global.push({\n                pred: predicate,\n                val: value\n            });\n        };\n    };\n\n});"]}