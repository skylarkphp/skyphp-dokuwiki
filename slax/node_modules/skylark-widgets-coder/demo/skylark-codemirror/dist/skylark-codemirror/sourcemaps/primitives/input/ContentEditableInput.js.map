{"version":3,"sources":["primitives/input/ContentEditableInput.js"],"names":["define","operations","display_selection","view_tracking","inputs","line_pos","utils_line","position_measurement","changes","selection","selection_updates","bidi","browser","dom","events","misc","ContentEditableInput","[object Object]","cm","this","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","polling","Delayed","composing","gracePeriod","readDOMTimeout","display","input","div","lineDiv","onCopyCut","e","signalDOMEvent","somethingSelected","setLastCopied","lineWise","text","getSelections","type","replaceSelection","options","lineWiseCopyCut","ranges","copyableRanges","operation","setSelections","sel_dontScroll","clipboardData","clearData","content","lastCopied","join","setData","getData","preventDefault","kludge","hiddenTextarea","te","firstChild","lineSpace","insertBefore","value","hadFocus","document","activeElement","selectInput","setTimeout","removeChild","focus","showPrimarySelection","disableBrowserMagic","spellcheck","autocorrect","autocapitalize","on","handlePaste","ie_version","updateFromDOM","data","done","readFromDOMSoon","forceCompositionEnd","result","prepareSelection","state","focused","info","takeFocus","view","length","showMultipleSelections","wrapper","ownerDocument","getSelection","sel","prim","doc","primary","from","to","viewTo","viewFrom","line","removeAllRanges","curAnchor","domToPos","anchorNode","anchorOffset","curFocus","focusNode","focusOffset","bad","cmp","minPos","maxPos","start","posToDOM","node","measure","map","offset","end","maps","rng","old","rangeCount","getRangeAt","range","gecko","collapse","collapsed","addRange","startGracePeriod","rememberSelection","clearTimeout","selectionChanged","curOp","removeChildrenAndAdd","cursorDiv","cursors","selectionDiv","commonAncestorContainer","contains","readOnly","selectionInEditor","showSelection","blur","pollSelection","runInOp","set","pollInterval","poll","android","chrome","gutters","scan","parentNode","test","className","isInGutter","triggerOnKeyDown","keyCode","Math","abs","anchor","head","setSelection","simpleSelection","fromIndex","fromLine","fromNode","ch","firstLine","Pos","getLine","lastLine","findViewIndex","lineNo","nextSibling","toLine","toNode","toIndex","lastChild","previousSibling","newText","splitLines","closing","lineSep","lineSeparator","extraLinebreak","close","addText","str","walk","nodeType","cmText","getAttribute","markerID","found","findMarks","id","marker","find","getBetween","isBlock","nodeName","textContent","i","childNodes","nodeValue","replace","domTextBetween","oldText","lst","pop","shift","cutFront","cutEnd","newTop","oldTop","maxCutFront","min","charCodeAt","newBot","oldBot","maxCutEnd","slice","chFrom","chTo","replaceRange","isReadOnly","pollContent","regChange","contentEditable","charCode","applyTextInput","String","fromCharCode","val","pos","findViewForLine","hidden","mapFromLineView","order","getOrder","direction","side","getBidiPartAt","nodeAndOffsetInLineMap","badPos","lineNode","clipPos","lineView","locateNodeInLineView","rest","textNode","topNode","j","curNode","after","dist","before","prototype","needsContentAttribute"],"mappings":"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","file":"../../../primitives/input/ContentEditableInput.js","sourcesContent":["define([\n    '../display/operations',\n    '../display/selection',\n    '../display/view_tracking',\n    './input',\n    '../line/pos',\n    '../line/utils_line',\n    '../measurement/position_measurement',\n    '../model/changes',\n    '../model/selection',\n    '../model/selection_updates',\n    '../util/bidi',\n    '../util/browser',\n    '../util/dom',\n    '../util/event',\n    '../util/misc'\n], function (operations, display_selection, view_tracking, inputs, line_pos, utils_line, position_measurement, changes, selection, selection_updates, bidi, browser, dom, events, misc) {\n    'use strict';\n    class ContentEditableInput {\n        constructor(cm) {\n            this.cm = cm;\n            this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n            this.polling = new misc.Delayed();\n            this.composing = null;\n            this.gracePeriod = false;\n            this.readDOMTimeout = null;\n        }\n        init(display) {\n            let input = this, cm = input.cm;\n            let div = input.div = display.lineDiv;\n            inputs.disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n            events.on(div, 'paste', e => {\n                if (events.signalDOMEvent(cm, e) || inputs.handlePaste(e, cm))\n                    return;\n                if (browser.ie_version <= 11)\n                    setTimeout(operations.operation(cm, () => this.updateFromDOM()), 20);\n            });\n            events.on(div, 'compositionstart', e => {\n                this.composing = {\n                    data: e.data,\n                    done: false\n                };\n            });\n            events.on(div, 'compositionupdate', e => {\n                if (!this.composing)\n                    this.composing = {\n                        data: e.data,\n                        done: false\n                    };\n            });\n            events.on(div, 'compositionend', e => {\n                if (this.composing) {\n                    if (e.data != this.composing.data)\n                        this.readFromDOMSoon();\n                    this.composing.done = true;\n                }\n            });\n            events.on(div, 'touchstart', () => input.forceCompositionEnd());\n            events.on(div, 'input', () => {\n                if (!this.composing)\n                    this.readFromDOMSoon();\n            });\n            function onCopyCut(e) {\n                if (events.signalDOMEvent(cm, e))\n                    return;\n                if (cm.somethingSelected()) {\n                    inputs.setLastCopied({\n                        lineWise: false,\n                        text: cm.getSelections()\n                    });\n                    if (e.type == 'cut')\n                        cm.replaceSelection('', null, 'cut');\n                } else if (!cm.options.lineWiseCopyCut) {\n                    return;\n                } else {\n                    let ranges = inputs.copyableRanges(cm);\n                    inputs.setLastCopied({\n                        lineWise: true,\n                        text: ranges.text\n                    });\n                    if (e.type == 'cut') {\n                        cm.operation(() => {\n                            cm.setSelections(ranges.ranges, 0, misc.sel_dontScroll);\n                            cm.replaceSelection('', null, 'cut');\n                        });\n                    }\n                }\n                if (e.clipboardData) {\n                    e.clipboardData.clearData();\n                    let content = inputs.lastCopied.text.join('\\n');\n                    e.clipboardData.setData('Text', content);\n                    if (e.clipboardData.getData('Text') == content) {\n                        e.preventDefault();\n                        return;\n                    }\n                }\n                let kludge = inputs.hiddenTextarea(), te = kludge.firstChild;\n                cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n                te.value = inputs.lastCopied.text.join('\\n');\n                let hadFocus = document.activeElement;\n                dom.selectInput(te);\n                setTimeout(() => {\n                    cm.display.lineSpace.removeChild(kludge);\n                    hadFocus.focus();\n                    if (hadFocus == div)\n                        input.showPrimarySelection();\n                }, 50);\n            }\n            events.on(div, 'copy', onCopyCut);\n            events.on(div, 'cut', onCopyCut);\n        }\n        prepareSelection() {\n            let result = display_selection.prepareSelection(this.cm, false);\n            result.focus = this.cm.state.focused;\n            return result;\n        }\n        showSelection(info, takeFocus) {\n            if (!info || !this.cm.display.view.length)\n                return;\n            if (info.focus || takeFocus)\n                this.showPrimarySelection();\n            this.showMultipleSelections(info);\n        }\n        getSelection() {\n            return this.cm.display.wrapper.ownerDocument.getSelection();\n        }\n        showPrimarySelection() {\n            let sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n            let from = prim.from(), to = prim.to();\n            if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n                sel.removeAllRanges();\n                return;\n            }\n            let curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n            let curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n            if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && line_pos.cmp(line_pos.minPos(curAnchor, curFocus), from) == 0 && line_pos.cmp(line_pos.maxPos(curAnchor, curFocus), to) == 0)\n                return;\n            let view = cm.display.view;\n            let start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {\n                node: view[0].measure.map[2],\n                offset: 0\n            };\n            let end = to.line < cm.display.viewTo && posToDOM(cm, to);\n            if (!end) {\n                let measure = view[view.length - 1].measure;\n                let map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n                end = {\n                    node: map[map.length - 1],\n                    offset: map[map.length - 2] - map[map.length - 3]\n                };\n            }\n            if (!start || !end) {\n                sel.removeAllRanges();\n                return;\n            }\n            let old = sel.rangeCount && sel.getRangeAt(0), rng;\n            try {\n                rng = dom.range(start.node, start.offset, end.offset, end.node);\n            } catch (e) {\n            }\n            if (rng) {\n                if (!browser.gecko && cm.state.focused) {\n                    sel.collapse(start.node, start.offset);\n                    if (!rng.collapsed) {\n                        sel.removeAllRanges();\n                        sel.addRange(rng);\n                    }\n                } else {\n                    sel.removeAllRanges();\n                    sel.addRange(rng);\n                }\n                if (old && sel.anchorNode == null)\n                    sel.addRange(old);\n                else if (browser.gecko)\n                    this.startGracePeriod();\n            }\n            this.rememberSelection();\n        }\n        startGracePeriod() {\n            clearTimeout(this.gracePeriod);\n            this.gracePeriod = setTimeout(() => {\n                this.gracePeriod = false;\n                if (this.selectionChanged())\n                    this.cm.operation(() => this.cm.curOp.selectionChanged = true);\n            }, 20);\n        }\n        showMultipleSelections(info) {\n            dom.removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n            dom.removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n        }\n        rememberSelection() {\n            let sel = this.getSelection();\n            this.lastAnchorNode = sel.anchorNode;\n            this.lastAnchorOffset = sel.anchorOffset;\n            this.lastFocusNode = sel.focusNode;\n            this.lastFocusOffset = sel.focusOffset;\n        }\n        selectionInEditor() {\n            let sel = this.getSelection();\n            if (!sel.rangeCount)\n                return false;\n            let node = sel.getRangeAt(0).commonAncestorContainer;\n            return dom.contains(this.div, node);\n        }\n        focus() {\n            if (this.cm.options.readOnly != 'nocursor') {\n                if (!this.selectionInEditor())\n                    this.showSelection(this.prepareSelection(), true);\n                this.div.focus();\n            }\n        }\n        blur() {\n            this.div.blur();\n        }\n        getField() {\n            return this.div;\n        }\n        supportsTouch() {\n            return true;\n        }\n        receivedFocus() {\n            let input = this;\n            if (this.selectionInEditor())\n                this.pollSelection();\n            else\n                operations.runInOp(this.cm, () => input.cm.curOp.selectionChanged = true);\n            function poll() {\n                if (input.cm.state.focused) {\n                    input.pollSelection();\n                    input.polling.set(input.cm.options.pollInterval, poll);\n                }\n            }\n            this.polling.set(this.cm.options.pollInterval, poll);\n        }\n        selectionChanged() {\n            let sel = this.getSelection();\n            return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n        }\n        pollSelection() {\n            if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged())\n                return;\n            let sel = this.getSelection(), cm = this.cm;\n            if (browser.android && browser.chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\n                this.cm.triggerOnKeyDown({\n                    type: 'keydown',\n                    keyCode: 8,\n                    preventDefault: Math.abs\n                });\n                this.blur();\n                this.focus();\n                return;\n            }\n            if (this.composing)\n                return;\n            this.rememberSelection();\n            let anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n            let head = domToPos(cm, sel.focusNode, sel.focusOffset);\n            if (anchor && head)\n                operations.runInOp(cm, () => {\n                    selection_updates.setSelection(cm.doc, selection.simpleSelection(anchor, head), misc.sel_dontScroll);\n                    if (anchor.bad || head.bad)\n                        cm.curOp.selectionChanged = true;\n                });\n        }\n        pollContent() {\n            if (this.readDOMTimeout != null) {\n                clearTimeout(this.readDOMTimeout);\n                this.readDOMTimeout = null;\n            }\n            let cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n            let from = sel.from(), to = sel.to();\n            if (from.ch == 0 && from.line > cm.firstLine())\n                from = line_pos.Pos(from.line - 1, utils_line.getLine(cm.doc, from.line - 1).length);\n            if (to.ch == utils_line.getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n                to = line_pos.Pos(to.line + 1, 0);\n            if (from.line < display.viewFrom || to.line > display.viewTo - 1)\n                return false;\n            let fromIndex, fromLine, fromNode;\n            if (from.line == display.viewFrom || (fromIndex = position_measurement.findViewIndex(cm, from.line)) == 0) {\n                fromLine = utils_line.lineNo(display.view[0].line);\n                fromNode = display.view[0].node;\n            } else {\n                fromLine = utils_line.lineNo(display.view[fromIndex].line);\n                fromNode = display.view[fromIndex - 1].node.nextSibling;\n            }\n            let toIndex = position_measurement.findViewIndex(cm, to.line);\n            let toLine, toNode;\n            if (toIndex == display.view.length - 1) {\n                toLine = display.viewTo - 1;\n                toNode = display.lineDiv.lastChild;\n            } else {\n                toLine = utils_line.lineNo(display.view[toIndex + 1].line) - 1;\n                toNode = display.view[toIndex + 1].node.previousSibling;\n            }\n            if (!fromNode)\n                return false;\n            let newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n            let oldText = utils_line.getBetween(cm.doc, line_pos.Pos(fromLine, 0), line_pos.Pos(toLine, utils_line.getLine(cm.doc, toLine).text.length));\n            while (newText.length > 1 && oldText.length > 1) {\n                if (misc.lst(newText) == misc.lst(oldText)) {\n                    newText.pop();\n                    oldText.pop();\n                    toLine--;\n                } else if (newText[0] == oldText[0]) {\n                    newText.shift();\n                    oldText.shift();\n                    fromLine++;\n                } else\n                    break;\n            }\n            let cutFront = 0, cutEnd = 0;\n            let newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n            while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n                ++cutFront;\n            let newBot = misc.lst(newText), oldBot = misc.lst(oldText);\n            let maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));\n            while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n                ++cutEnd;\n            if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n                while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n                    cutFront--;\n                    cutEnd++;\n                }\n            }\n            newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, '');\n            newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, '');\n            let chFrom = line_pos.Pos(fromLine, cutFront);\n            let chTo = line_pos.Pos(toLine, oldText.length ? misc.lst(oldText).length - cutEnd : 0);\n            if (newText.length > 1 || newText[0] || line_pos.cmp(chFrom, chTo)) {\n                changes.replaceRange(cm.doc, newText, chFrom, chTo, '+input');\n                return true;\n            }\n        }\n        ensurePolled() {\n            this.forceCompositionEnd();\n        }\n        reset() {\n            this.forceCompositionEnd();\n        }\n        forceCompositionEnd() {\n            if (!this.composing)\n                return;\n            clearTimeout(this.readDOMTimeout);\n            this.composing = null;\n            this.updateFromDOM();\n            this.div.blur();\n            this.div.focus();\n        }\n        readFromDOMSoon() {\n            if (this.readDOMTimeout != null)\n                return;\n            this.readDOMTimeout = setTimeout(() => {\n                this.readDOMTimeout = null;\n                if (this.composing) {\n                    if (this.composing.done)\n                        this.composing = null;\n                    else\n                        return;\n                }\n                this.updateFromDOM();\n            }, 80);\n        }\n        updateFromDOM() {\n            if (this.cm.isReadOnly() || !this.pollContent())\n                operations.runInOp(this.cm, () => view_tracking.regChange(this.cm));\n        }\n        setUneditable(node) {\n            node.contentEditable = 'false';\n        }\n        onKeyPress(e) {\n            if (e.charCode == 0 || this.composing)\n                return;\n            e.preventDefault();\n            if (!this.cm.isReadOnly())\n                operations.operation(this.cm, inputs.applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n        }\n        readOnlyChanged(val) {\n            this.div.contentEditable = String(val != 'nocursor');\n        }\n        onContextMenu() {\n        }\n        resetPosition() {\n        }\n    };\n    ContentEditableInput.prototype.needsContentAttribute = true;\n    function posToDOM(cm, pos) {\n        let view = position_measurement.findViewForLine(cm, pos.line);\n        if (!view || view.hidden)\n            return null;\n        let line = utils_line.getLine(cm.doc, pos.line);\n        let info = position_measurement.mapFromLineView(view, line, pos.line);\n        let order = bidi.getOrder(line, cm.doc.direction), side = 'left';\n        if (order) {\n            let partPos = bidi.getBidiPartAt(order, pos.ch);\n            side = partPos % 2 ? 'right' : 'left';\n        }\n        let result = position_measurement.nodeAndOffsetInLineMap(info.map, pos.ch, side);\n        result.offset = result.collapse == 'right' ? result.end : result.start;\n        return result;\n    }\n    function isInGutter(node) {\n        for (let scan = node; scan; scan = scan.parentNode)\n            if (/CodeMirror-gutter-wrapper/.test(scan.className))\n                return true;\n        return false;\n    }\n    function badPos(pos, bad) {\n        if (bad)\n            pos.bad = true;\n        return pos;\n    }\n    function domTextBetween(cm, from, to, fromLine, toLine) {\n        let text = '', closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n        function recognizeMarker(id) {\n            return marker => marker.id == id;\n        }\n        function close() {\n            if (closing) {\n                text += lineSep;\n                if (extraLinebreak)\n                    text += lineSep;\n                closing = extraLinebreak = false;\n            }\n        }\n        function addText(str) {\n            if (str) {\n                close();\n                text += str;\n            }\n        }\n        function walk(node) {\n            if (node.nodeType == 1) {\n                let cmText = node.getAttribute('cm-text');\n                if (cmText) {\n                    addText(cmText);\n                    return;\n                }\n                let markerID = node.getAttribute('cm-marker'), range;\n                if (markerID) {\n                    let found = cm.findMarks(line_pos.Pos(fromLine, 0), line_pos.Pos(toLine + 1, 0), recognizeMarker(+markerID));\n                    if (found.length && (range = found[0].find(0)))\n                        addText(utils_line.getBetween(cm.doc, range.from, range.to).join(lineSep));\n                    return;\n                }\n                if (node.getAttribute('contenteditable') == 'false')\n                    return;\n                let isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n                if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0)\n                    return;\n                if (isBlock)\n                    close();\n                for (let i = 0; i < node.childNodes.length; i++)\n                    walk(node.childNodes[i]);\n                if (/^(pre|p)$/i.test(node.nodeName))\n                    extraLinebreak = true;\n                if (isBlock)\n                    closing = true;\n            } else if (node.nodeType == 3) {\n                addText(node.nodeValue.replace(/\\u200b/g, '').replace(/\\u00a0/g, ' '));\n            }\n        }\n        for (;;) {\n            walk(from);\n            if (from == to)\n                break;\n            from = from.nextSibling;\n            extraLinebreak = false;\n        }\n        return text;\n    }\n    function domToPos(cm, node, offset) {\n        let lineNode;\n        if (node == cm.display.lineDiv) {\n            lineNode = cm.display.lineDiv.childNodes[offset];\n            if (!lineNode)\n                return badPos(cm.clipPos(line_pos.Pos(cm.display.viewTo - 1)), true);\n            node = null;\n            offset = 0;\n        } else {\n            for (lineNode = node;; lineNode = lineNode.parentNode) {\n                if (!lineNode || lineNode == cm.display.lineDiv)\n                    return null;\n                if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv)\n                    break;\n            }\n        }\n        for (let i = 0; i < cm.display.view.length; i++) {\n            let lineView = cm.display.view[i];\n            if (lineView.node == lineNode)\n                return locateNodeInLineView(lineView, node, offset);\n        }\n    }\n    function locateNodeInLineView(lineView, node, offset) {\n        let wrapper = lineView.text.firstChild, bad = false;\n        if (!node || !dom.contains(wrapper, node))\n            return badPos(line_pos.Pos(utils_line.lineNo(lineView.line), 0), true);\n        if (node == wrapper) {\n            bad = true;\n            node = wrapper.childNodes[offset];\n            offset = 0;\n            if (!node) {\n                let line = lineView.rest ? misc.lst(lineView.rest) : lineView.line;\n                return badPos(line_pos.Pos(utils_line.lineNo(line), line.text.length), bad);\n            }\n        }\n        let textNode = node.nodeType == 3 ? node : null, topNode = node;\n        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n            textNode = node.firstChild;\n            if (offset)\n                offset = textNode.nodeValue.length;\n        }\n        while (topNode.parentNode != wrapper)\n            topNode = topNode.parentNode;\n        let measure = lineView.measure, maps = measure.maps;\n        function find(textNode, topNode, offset) {\n            for (let i = -1; i < (maps ? maps.length : 0); i++) {\n                let map = i < 0 ? measure.map : maps[i];\n                for (let j = 0; j < map.length; j += 3) {\n                    let curNode = map[j + 2];\n                    if (curNode == textNode || curNode == topNode) {\n                        let line = utils_line.lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n                        let ch = map[j] + offset;\n                        if (offset < 0 || curNode != textNode)\n                            ch = map[j + (offset ? 1 : 0)];\n                        return line_pos.Pos(line, ch);\n                    }\n                }\n            }\n        }\n        let found = find(textNode, topNode, offset);\n        if (found)\n            return badPos(found, bad);\n        for (let after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n            found = find(after, after.firstChild, 0);\n            if (found)\n                return badPos(line_pos.Pos(found.line, found.ch - dist), bad);\n            else\n                dist += after.textContent.length;\n        }\n        for (let before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\n            found = find(before, before.firstChild, -1);\n            if (found)\n                return badPos(line_pos.Pos(found.line, found.ch + dist), bad);\n            else\n                dist += before.textContent.length;\n        }\n    }\n\n    return ContentEditableInput;\n});"]}