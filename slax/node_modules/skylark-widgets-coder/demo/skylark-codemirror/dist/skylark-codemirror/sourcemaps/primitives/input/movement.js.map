{"version":3,"sources":["primitives/input/movement.js"],"names":["define","line_pos","position_measurement","bidi","misc","moveCharLogically","line","ch","dir","target","skipExtendingChars","text","length","moveLogically","start","Pos","endOfLine","visually","cm","lineObj","lineNo","order","getOrder","doc","direction","part","lst","sticky","level","prep","prepareMeasureForLine","targetTop","measureCharPrepared","top","findFirst","from","to","moveVisually","partPos","getBidiPartAt","mv","pos","getWrappedLineExtent","options","lineWrapping","wrappedLineExtentChar","begin","end","wrappedLineExtent","moveInStorageOrder","searchInVisualLine","getRes","res","nextCh"],"mappings":"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","file":"../../../primitives/input/movement.js","sourcesContent":["define([\n    '../line/pos',\n    '../measurement/position_measurement',\n    '../util/bidi',\n    '../util/misc'\n], function (line_pos, position_measurement, bidi, misc) {\n    'use strict';\n    function moveCharLogically(line, ch, dir) {\n        let target = misc.skipExtendingChars(line.text, ch + dir, dir);\n        return target < 0 || target > line.text.length ? null : target;\n    }\n    function moveLogically(line, start, dir) {\n        let ch = moveCharLogically(line, start.ch, dir);\n        return ch == null ? null : new line_pos.Pos(start.line, ch, dir < 0 ? 'after' : 'before');\n    }\n    function endOfLine(visually, cm, lineObj, lineNo, dir) {\n        if (visually) {\n            let order = bidi.getOrder(lineObj, cm.doc.direction);\n            if (order) {\n                let part = dir < 0 ? misc.lst(order) : order[0];\n                let moveInStorageOrder = dir < 0 == (part.level == 1);\n                let sticky = moveInStorageOrder ? 'after' : 'before';\n                let ch;\n                if (part.level > 0 || cm.doc.direction == 'rtl') {\n                    let prep = position_measurement.prepareMeasureForLine(cm, lineObj);\n                    ch = dir < 0 ? lineObj.text.length - 1 : 0;\n                    let targetTop = position_measurement.measureCharPrepared(cm, prep, ch).top;\n                    ch = misc.findFirst(ch => position_measurement.measureCharPrepared(cm, prep, ch).top == targetTop, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);\n                    if (sticky == 'before')\n                        ch = moveCharLogically(lineObj, ch, 1);\n                } else\n                    ch = dir < 0 ? part.to : part.from;\n                return new line_pos.Pos(lineNo, ch, sticky);\n            }\n        }\n        return new line_pos.Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? 'before' : 'after');\n    }\n    function moveVisually(cm, line, start, dir) {\n        let bidi = bidi.getOrder(line, cm.doc.direction);\n        if (!bidi)\n            return moveLogically(line, start, dir);\n        if (start.ch >= line.text.length) {\n            start.ch = line.text.length;\n            start.sticky = 'before';\n        } else if (start.ch <= 0) {\n            start.ch = 0;\n            start.sticky = 'after';\n        }\n        let partPos = bidi.getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n        if (cm.doc.direction == 'ltr' && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n            return moveLogically(line, start, dir);\n        }\n        let mv = (pos, dir) => moveCharLogically(line, pos instanceof line_pos.Pos ? pos.ch : pos, dir);\n        let prep;\n        let getWrappedLineExtent = ch => {\n            if (!cm.options.lineWrapping)\n                return {\n                    begin: 0,\n                    end: line.text.length\n                };\n            prep = prep || position_measurement.prepareMeasureForLine(cm, line);\n            return position_measurement.wrappedLineExtentChar(cm, line, prep, ch);\n        };\n        let wrappedLineExtent = getWrappedLineExtent(start.sticky == 'before' ? mv(start, -1) : start.ch);\n        if (cm.doc.direction == 'rtl' || part.level == 1) {\n            let moveInStorageOrder = part.level == 1 == dir < 0;\n            let ch = mv(start, moveInStorageOrder ? 1 : -1);\n            if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n                let sticky = moveInStorageOrder ? 'before' : 'after';\n                return new line_pos.Pos(start.line, ch, sticky);\n            }\n        }\n        let searchInVisualLine = (partPos, dir, wrappedLineExtent) => {\n            let getRes = (ch, moveInStorageOrder) => moveInStorageOrder ? new line_pos.Pos(start.line, mv(ch, 1), 'before') : new line_pos.Pos(start.line, ch, 'after');\n            for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n                let part = bidi[partPos];\n                let moveInStorageOrder = dir > 0 == (part.level != 1);\n                let ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n                if (part.from <= ch && ch < part.to)\n                    return getRes(ch, moveInStorageOrder);\n                ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n                if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end)\n                    return getRes(ch, moveInStorageOrder);\n            }\n        };\n        let res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n        if (res)\n            return res;\n        let nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n        if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n            res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n            if (res)\n                return res;\n        }\n        return null;\n    }\n    return {\n        moveLogically: moveLogically,\n        endOfLine: endOfLine,\n        moveVisually: moveVisually\n    };\n});"]}