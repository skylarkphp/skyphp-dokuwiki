{"version":3,"sources":["primitives/line/highlight.js"],"names":["define","misc","modes","StringStream","utils_line","line_pos","SavedContext","[object Object]","state","lookAhead","this","Context","doc","line","maxLookAhead","baseTokens","baseTokenPos","n","getLine","type","replace","size","saved","copyState","mode","copy","highlightLine","cm","context","forceToEnd","st","modeGen","lineClasses","runMode","text","end","style","push","o","overlays","length","overlay","i","at","start","i_end","splice","Math","min","opaque","cur","styles","classes","bgClass","textClass","getContextBefore","precise","display","startState","minindent","minline","lim","innerMode","search","first","after","stateAfter","modeFrontier","indented","countColumn","options","tabSize","findStartLine","fromSaved","iter","processLine","pos","viewFrom","viewTo","save","nextLine","startAt","stream","callBlankLine","eol","readToken","blankLine","inner","token","Error","name","Token","string","current","extractLineClasses","output","lineClass","match","slice","index","prop","RegExp","test","f","flattenSpans","curStart","curStyle","addModeClass","maxHighlightLength","mName","getLineStyles","updateFrontier","lineNo","resetState","result","styleClasses","highlightFrontier","max","takeToken","asArray","clipPos","tokens","ch","retreatFrontier"],"mappings":"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","file":"../../../primitives/line/highlight.js","sourcesContent":["define([\n    '../util/misc',\n    '../modes',\n    '../util/StringStream',\n    './utils_line',\n    './pos'\n], function (misc, modes, StringStream, utils_line, line_pos) {\n    'use strict';\n    class SavedContext {\n        constructor(state, lookAhead) {\n            this.state = state;\n            this.lookAhead = lookAhead;\n        }\n    }\n    class Context {\n        constructor(doc, state, line, lookAhead) {\n            this.state = state;\n            this.doc = doc;\n            this.line = line;\n            this.maxLookAhead = lookAhead || 0;\n            this.baseTokens = null;\n            this.baseTokenPos = 1;\n        }\n        lookAhead(n) {\n            let line = this.doc.getLine(this.line + n);\n            if (line != null && n > this.maxLookAhead)\n                this.maxLookAhead = n;\n            return line;\n        }\n        baseToken(n) {\n            if (!this.baseTokens)\n                return null;\n            while (this.baseTokens[this.baseTokenPos] <= n)\n                this.baseTokenPos += 2;\n            let type = this.baseTokens[this.baseTokenPos + 1];\n            return {\n                type: type && type.replace(/( |^)overlay .*/, ''),\n                size: this.baseTokens[this.baseTokenPos] - n\n            };\n        }\n        nextLine() {\n            this.line++;\n            if (this.maxLookAhead > 0)\n                this.maxLookAhead--;\n        }\n        static fromSaved(doc, saved, line) {\n            if (saved instanceof SavedContext)\n                return new Context(doc, modes.copyState(doc.mode, saved.state), line, saved.lookAhead);\n            else\n                return new Context(doc, modes.copyState(doc.mode, saved), line);\n        }\n        save(copy) {\n            let state = copy !== false ? modes.copyState(this.doc.mode, this.state) : this.state;\n            return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;\n        }\n    }\n    function highlightLine(cm, line, context, forceToEnd) {\n        let st = [cm.state.modeGen], lineClasses = {};\n        runMode(cm, line.text, cm.doc.mode, context, (end, style) => st.push(end, style), lineClasses, forceToEnd);\n        let state = context.state;\n        for (let o = 0; o < cm.state.overlays.length; ++o) {\n            context.baseTokens = st;\n            let overlay = cm.state.overlays[o], i = 1, at = 0;\n            context.state = true;\n            runMode(cm, line.text, overlay.mode, context, (end, style) => {\n                let start = i;\n                while (at < end) {\n                    let i_end = st[i];\n                    if (i_end > end)\n                        st.splice(i, 1, end, st[i + 1], i_end);\n                    i += 2;\n                    at = Math.min(end, i_end);\n                }\n                if (!style)\n                    return;\n                if (overlay.opaque) {\n                    st.splice(start, i - start, end, 'overlay ' + style);\n                    i = start + 2;\n                } else {\n                    for (; start < i; start += 2) {\n                        let cur = st[start + 1];\n                        st[start + 1] = (cur ? cur + ' ' : '') + 'overlay ' + style;\n                    }\n                }\n            }, lineClasses);\n            context.state = state;\n            context.baseTokens = null;\n            context.baseTokenPos = 1;\n        }\n        return {\n            styles: st,\n            classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null\n        };\n    }\n    function getLineStyles(cm, line, updateFrontier) {\n        if (!line.styles || line.styles[0] != cm.state.modeGen) {\n            let context = getContextBefore(cm, utils_line.lineNo(line));\n            let resetState = line.text.length > cm.options.maxHighlightLength && modes.copyState(cm.doc.mode, context.state);\n            let result = highlightLine(cm, line, context);\n            if (resetState)\n                context.state = resetState;\n            line.stateAfter = context.save(!resetState);\n            line.styles = result.styles;\n            if (result.classes)\n                line.styleClasses = result.classes;\n            else if (line.styleClasses)\n                line.styleClasses = null;\n            if (updateFrontier === cm.doc.highlightFrontier)\n                cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);\n        }\n        return line.styles;\n    }\n    function getContextBefore(cm, n, precise) {\n        let doc = cm.doc, display = cm.display;\n        if (!doc.mode.startState)\n            return new Context(doc, true, n);\n        let start = findStartLine(cm, n, precise);\n        let saved = start > doc.first && utils_line.getLine(doc, start - 1).stateAfter;\n        let context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, modes.startState(doc.mode), start);\n        doc.iter(start, n, line => {\n            processLine(cm, line.text, context);\n            let pos = context.line;\n            line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n            context.nextLine();\n        });\n        if (precise)\n            doc.modeFrontier = context.line;\n        return context;\n    }\n    function processLine(cm, text, context, startAt) {\n        let mode = cm.doc.mode;\n        let stream = new StringStream(text, cm.options.tabSize, context);\n        stream.start = stream.pos = startAt || 0;\n        if (text == '')\n            callBlankLine(mode, context.state);\n        while (!stream.eol()) {\n            readToken(mode, stream, context.state);\n            stream.start = stream.pos;\n        }\n    }\n    function callBlankLine(mode, state) {\n        if (mode.blankLine)\n            return mode.blankLine(state);\n        if (!mode.innerMode)\n            return;\n        let inner = modes.innerMode(mode, state);\n        if (inner.mode.blankLine)\n            return inner.mode.blankLine(inner.state);\n    }\n    function readToken(mode, stream, state, inner) {\n        for (let i = 0; i < 10; i++) {\n            if (inner)\n                inner[0] = modes.innerMode(mode, state).mode;\n            let style = mode.token(stream, state);\n            if (stream.pos > stream.start)\n                return style;\n        }\n        throw new Error('Mode ' + mode.name + ' failed to advance stream.');\n    }\n    class Token {\n        constructor(stream, type, state) {\n            this.start = stream.start;\n            this.end = stream.pos;\n            this.string = stream.current();\n            this.type = type || null;\n            this.state = state;\n        }\n    }\n    function takeToken(cm, pos, precise, asArray) {\n        let doc = cm.doc, mode = doc.mode, style;\n        pos = line_pos.clipPos(doc, pos);\n        let line = utils_line.getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n        let stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n        if (asArray)\n            tokens = [];\n        while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n            stream.start = stream.pos;\n            style = readToken(mode, stream, context.state);\n            if (asArray)\n                tokens.push(new Token(stream, style, modes.copyState(doc.mode, context.state)));\n        }\n        return asArray ? tokens : new Token(stream, style, context.state);\n    }\n    function extractLineClasses(type, output) {\n        if (type)\n            for (;;) {\n                let lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n                if (!lineClass)\n                    break;\n                type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n                let prop = lineClass[1] ? 'bgClass' : 'textClass';\n                if (output[prop] == null)\n                    output[prop] = lineClass[2];\n                else if (!new RegExp('(?:^|s)' + lineClass[2] + '(?:$|s)').test(output[prop]))\n                    output[prop] += ' ' + lineClass[2];\n            }\n        return type;\n    }\n    function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n        let flattenSpans = mode.flattenSpans;\n        if (flattenSpans == null)\n            flattenSpans = cm.options.flattenSpans;\n        let curStart = 0, curStyle = null;\n        let stream = new StringStream(text, cm.options.tabSize, context), style;\n        let inner = cm.options.addModeClass && [null];\n        if (text == '')\n            extractLineClasses(callBlankLine(mode, context.state), lineClasses);\n        while (!stream.eol()) {\n            if (stream.pos > cm.options.maxHighlightLength) {\n                flattenSpans = false;\n                if (forceToEnd)\n                    processLine(cm, text, context, stream.pos);\n                stream.pos = text.length;\n                style = null;\n            } else {\n                style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n            }\n            if (inner) {\n                let mName = inner[0].name;\n                if (mName)\n                    style = 'm-' + (style ? mName + ' ' + style : mName);\n            }\n            if (!flattenSpans || curStyle != style) {\n                while (curStart < stream.start) {\n                    curStart = Math.min(stream.start, curStart + 5000);\n                    f(curStart, curStyle);\n                }\n                curStyle = style;\n            }\n            stream.start = stream.pos;\n        }\n        while (curStart < stream.pos) {\n            let pos = Math.min(stream.pos, curStart + 5000);\n            f(pos, curStyle);\n            curStart = pos;\n        }\n    }\n    function findStartLine(cm, n, precise) {\n        let minindent, minline, doc = cm.doc;\n        let lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n        for (let search = n; search > lim; --search) {\n            if (search <= doc.first)\n                return doc.first;\n            let line = utils_line.getLine(doc, search - 1), after = line.stateAfter;\n            if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n                return search;\n            let indented = misc.countColumn(line.text, null, cm.options.tabSize);\n            if (minline == null || minindent > indented) {\n                minline = search - 1;\n                minindent = indented;\n            }\n        }\n        return minline;\n    }\n    function retreatFrontier(doc, n) {\n        doc.modeFrontier = Math.min(doc.modeFrontier, n);\n        if (doc.highlightFrontier < n - 10)\n            return;\n        let start = doc.first;\n        for (let line = n - 1; line > start; line--) {\n            let saved = utils_line.getLine(doc, line).stateAfter;\n            if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n                start = line + 1;\n                break;\n            }\n        }\n        doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n    }\n    return {\n        highlightLine: highlightLine,\n        getLineStyles: getLineStyles,\n        getContextBefore: getContextBefore,\n        processLine: processLine,\n        takeToken: takeToken,\n        retreatFrontier: retreatFrontier\n    };\n});"]}