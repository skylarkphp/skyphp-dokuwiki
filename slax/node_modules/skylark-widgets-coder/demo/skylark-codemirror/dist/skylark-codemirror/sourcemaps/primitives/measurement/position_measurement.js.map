{"version":3,"sources":["primitives/measurement/position_measurement.js"],"names":["define","line_data","line_pos","spans","utils_line","bidi","browser","dom","events","feature_detection","misc","update_line","widgets","paddingTop","display","lineSpace","offsetTop","paddingH","cachedPaddingH","e","removeChildrenAndAdd","measure","elt","style","window","getComputedStyle","currentStyle","data","left","parseInt","paddingLeft","right","paddingRight","isNaN","scrollGap","cm","scrollerGap","nativeBarWidth","displayWidth","scroller","clientWidth","barWidth","mapFromLineView","lineView","line","lineN","map","cache","i","rest","length","maps","caches","lineNo","before","measureChar","ch","bias","measureCharPrepared","prepareMeasureForLine","findViewForLine","viewFrom","viewTo","view","findViewIndex","ext","externalMeasured","size","text","changes","updateLineForChanges","getDimensions","curOp","forceUpdate","visualLine","LineView","doc","built","buildLineContent","pre","lineMeasure","updateExternalMeasurement","info","rect","hasHeights","prepared","varHeight","found","key","hasOwnProperty","getBoundingClientRect","wrapping","options","lineWrapping","curWidth","heights","width","rects","firstChild","getClientRects","cur","next","Math","abs","bottom","push","top","ensureLineHeights","place","nodeAndOffsetInLineMap","node","start","end","collapse","nodeType","isExtendingChar","charAt","coverStart","coverEnd","ie","ie_version","parentNode","getUsefulRect","range","screen","logicalXDPI","deviceXDPI","hasBadZoomedRects","scaleX","scaleY","logicalYDPI","deviceYDPI","maybeUpdateRectForZooming","rSpan","charWidth","nullRect","rtop","rbot","mid","bot","result","bogus","singleCursorHeightPerLine","rbottom","measureCharInner","measureText","mStart","mEnd","insertLeft","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","removeChildren","pageScrollX","chrome","android","document","body","marginLeft","pageXOffset","documentElement","scrollLeft","pageScrollY","marginTop","pageYOffset","scrollTop","widgetTopHeight","lineObj","height","above","widgetHeight","intoCoordSystem","context","includeWidgets","yOff","heightAtLine","viewOffset","lOff","xOff","cursorCoords","pos","preparedMeasure","get","m","getLine","order","getOrder","direction","sticky","getBidi","partPos","invert","level","getBidiPartAt","other","bidiOther","val","PosWithInfo","outside","xRel","Pos","coordsChar","x","y","first","lineAtHeight","last","coordsCharInner","collapsed","collapsedSpanAround","rangeEnd","find","wrappedLineExtent","begin","findFirst","boxIsAfter","box","ltr","part","_lineNo","test","closestDist","p","from","to","endX","min","max","dist","index","baseX","chAround","boxAround","atLeft","atStart","coords","skipExtendingChars","textHeight","cachedTextHeight","appendChild","createTextNode","offsetHeight","cachedCharWidth","anchor","gutterLeft","gutters","clientLeft","n","nextSibling","offsetLeft","fixedPos","compensateForHScroll","gutterTotalWidth","offsetWidth","gutterWidth","wrapperWidth","wrapper","sizer","estimateHeight","th","perLine","lineIsHidden","widgetsHeight","ceil","paddingVert","mover","displayHeight","clientHeight","barHeight","clearCaches","maxLineChanged","lineNumChars","fromCoordSystem","localBox","lineSpaceBox","charCoords","estimateCoords","clipPos","wrappedLineExtentChar","target","estimateLineHeights","est","iter","estHeight","updateLineHeight","posFromMouse","liberal","forRect","e_target","getAttribute","space","clientX","clientY","colDiff","countColumn","tabSize","round"],"mappings":"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","file":"../../../primitives/measurement/position_measurement.js","sourcesContent":["define([\n    '../line/line_data',\n    '../line/pos',\n    '../line/spans',\n    '../line/utils_line',\n    '../util/bidi',\n    '../util/browser',\n    '../util/dom',\n    '../util/event',\n    '../util/feature_detection',\n    '../util/misc',\n    '../display/update_line',\n    './widgets'\n], function (line_data, line_pos, spans, utils_line, bidi, browser, dom, events, feature_detection, misc, update_line, widgets) {\n    'use strict';\n    function paddingTop(display) {\n        return display.lineSpace.offsetTop;\n    }\n    function paddingVert(display) {\n        return display.mover.offsetHeight - display.lineSpace.offsetHeight;\n    }\n    function paddingH(display) {\n        if (display.cachedPaddingH)\n            return display.cachedPaddingH;\n        let e = dom.removeChildrenAndAdd(display.measure, dom.elt('pre', 'x'));\n        let style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n        let data = {\n            left: parseInt(style.paddingLeft),\n            right: parseInt(style.paddingRight)\n        };\n        if (!isNaN(data.left) && !isNaN(data.right))\n            display.cachedPaddingH = data;\n        return data;\n    }\n    function scrollGap(cm) {\n        return misc.scrollerGap - cm.display.nativeBarWidth;\n    }\n    function displayWidth(cm) {\n        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n    }\n    function displayHeight(cm) {\n        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n    }\n    function ensureLineHeights(cm, lineView, rect) {\n        let wrapping = cm.options.lineWrapping;\n        let curWidth = wrapping && displayWidth(cm);\n        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n            let heights = lineView.measure.heights = [];\n            if (wrapping) {\n                lineView.measure.width = curWidth;\n                let rects = lineView.text.firstChild.getClientRects();\n                for (let i = 0; i < rects.length - 1; i++) {\n                    let cur = rects[i], next = rects[i + 1];\n                    if (Math.abs(cur.bottom - next.bottom) > 2)\n                        heights.push((cur.bottom + next.top) / 2 - rect.top);\n                }\n            }\n            heights.push(rect.bottom - rect.top);\n        }\n    }\n    function mapFromLineView(lineView, line, lineN) {\n        if (lineView.line == line)\n            return {\n                map: lineView.measure.map,\n                cache: lineView.measure.cache\n            };\n        for (let i = 0; i < lineView.rest.length; i++)\n            if (lineView.rest[i] == line)\n                return {\n                    map: lineView.measure.maps[i],\n                    cache: lineView.measure.caches[i]\n                };\n        for (let i = 0; i < lineView.rest.length; i++)\n            if (utils_line.lineNo(lineView.rest[i]) > lineN)\n                return {\n                    map: lineView.measure.maps[i],\n                    cache: lineView.measure.caches[i],\n                    before: true\n                };\n    }\n    function updateExternalMeasurement(cm, line) {\n        line = spans.visualLine(line);\n        let lineN = utils_line.lineNo(line);\n        let view = cm.display.externalMeasured = new line_data.LineView(cm.doc, line, lineN);\n        view.lineN = lineN;\n        let built = view.built = line_data.buildLineContent(cm, view);\n        view.text = built.pre;\n        dom.removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n        return view;\n    }\n    function measureChar(cm, line, ch, bias) {\n        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n    }\n    function findViewForLine(cm, lineN) {\n        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n            return cm.display.view[findViewIndex(cm, lineN)];\n        let ext = cm.display.externalMeasured;\n        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n            return ext;\n    }\n    function prepareMeasureForLine(cm, line) {\n        let lineN = utils_line.lineNo(line);\n        let view = findViewForLine(cm, lineN);\n        if (view && !view.text) {\n            view = null;\n        } else if (view && view.changes) {\n            update_line.updateLineForChanges(cm, view, lineN, getDimensions(cm));\n            cm.curOp.forceUpdate = true;\n        }\n        if (!view)\n            view = updateExternalMeasurement(cm, line);\n        let info = mapFromLineView(view, line, lineN);\n        return {\n            line: line,\n            view: view,\n            rect: null,\n            map: info.map,\n            cache: info.cache,\n            before: info.before,\n            hasHeights: false\n        };\n    }\n    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n        if (prepared.before)\n            ch = -1;\n        let key = ch + (bias || ''), found;\n        if (prepared.cache.hasOwnProperty(key)) {\n            found = prepared.cache[key];\n        } else {\n            if (!prepared.rect)\n                prepared.rect = prepared.view.text.getBoundingClientRect();\n            if (!prepared.hasHeights) {\n                ensureLineHeights(cm, prepared.view, prepared.rect);\n                prepared.hasHeights = true;\n            }\n            found = measureCharInner(cm, prepared, ch, bias);\n            if (!found.bogus)\n                prepared.cache[key] = found;\n        }\n        return {\n            left: found.left,\n            right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom\n        };\n    }\n    let nullRect = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n    };\n    function nodeAndOffsetInLineMap(map, ch, bias) {\n        let node, start, end, collapse, mStart, mEnd;\n        for (let i = 0; i < map.length; i += 3) {\n            mStart = map[i];\n            mEnd = map[i + 1];\n            if (ch < mStart) {\n                start = 0;\n                end = 1;\n                collapse = 'left';\n            } else if (ch < mEnd) {\n                start = ch - mStart;\n                end = start + 1;\n            } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n                end = mEnd - mStart;\n                start = end - 1;\n                if (ch >= mEnd)\n                    collapse = 'right';\n            }\n            if (start != null) {\n                node = map[i + 2];\n                if (mStart == mEnd && bias == (node.insertLeft ? 'left' : 'right'))\n                    collapse = bias;\n                if (bias == 'left' && start == 0)\n                    while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n                        node = map[(i -= 3) + 2];\n                        collapse = 'left';\n                    }\n                if (bias == 'right' && start == mEnd - mStart)\n                    while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n                        node = map[(i += 3) + 2];\n                        collapse = 'right';\n                    }\n                break;\n            }\n        }\n        return {\n            node: node,\n            start: start,\n            end: end,\n            collapse: collapse,\n            coverStart: mStart,\n            coverEnd: mEnd\n        };\n    }\n    function getUsefulRect(rects, bias) {\n        let rect = nullRect;\n        if (bias == 'left')\n            for (let i = 0; i < rects.length; i++) {\n                if ((rect = rects[i]).left != rect.right)\n                    break;\n            }\n        else\n            for (let i = rects.length - 1; i >= 0; i--) {\n                if ((rect = rects[i]).left != rect.right)\n                    break;\n            }\n        return rect;\n    }\n    function measureCharInner(cm, prepared, ch, bias) {\n        let place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n        let node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n        let rect;\n        if (node.nodeType == 3) {\n            for (let i = 0; i < 4; i++) {\n                while (start && misc.isExtendingChar(prepared.line.text.charAt(place.coverStart + start)))\n                    --start;\n                while (place.coverStart + end < place.coverEnd && misc.isExtendingChar(prepared.line.text.charAt(place.coverStart + end)))\n                    ++end;\n                if (browser.ie && browser.ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n                    rect = node.parentNode.getBoundingClientRect();\n                else\n                    rect = getUsefulRect(dom.range(node, start, end).getClientRects(), bias);\n                if (rect.left || rect.right || start == 0)\n                    break;\n                end = start;\n                start = start - 1;\n                collapse = 'right';\n            }\n            if (browser.ie && browser.ie_version < 11)\n                rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n        } else {\n            if (start > 0)\n                collapse = bias = 'right';\n            let rects;\n            if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n                rect = rects[bias == 'right' ? rects.length - 1 : 0];\n            else\n                rect = node.getBoundingClientRect();\n        }\n        if (browser.ie && browser.ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n            let rSpan = node.parentNode.getClientRects()[0];\n            if (rSpan)\n                rect = {\n                    left: rSpan.left,\n                    right: rSpan.left + charWidth(cm.display),\n                    top: rSpan.top,\n                    bottom: rSpan.bottom\n                };\n            else\n                rect = nullRect;\n        }\n        let rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n        let mid = (rtop + rbot) / 2;\n        let heights = prepared.view.measure.heights;\n        let i = 0;\n        for (; i < heights.length - 1; i++)\n            if (mid < heights[i])\n                break;\n        let top = i ? heights[i - 1] : 0, bot = heights[i];\n        let result = {\n            left: (collapse == 'right' ? rect.right : rect.left) - prepared.rect.left,\n            right: (collapse == 'left' ? rect.left : rect.right) - prepared.rect.left,\n            top: top,\n            bottom: bot\n        };\n        if (!rect.left && !rect.right)\n            result.bogus = true;\n        if (!cm.options.singleCursorHeightPerLine) {\n            result.rtop = rtop;\n            result.rbottom = rbot;\n        }\n        return result;\n    }\n    function maybeUpdateRectForZooming(measure, rect) {\n        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !feature_detection.hasBadZoomedRects(measure))\n            return rect;\n        let scaleX = screen.logicalXDPI / screen.deviceXDPI;\n        let scaleY = screen.logicalYDPI / screen.deviceYDPI;\n        return {\n            left: rect.left * scaleX,\n            right: rect.right * scaleX,\n            top: rect.top * scaleY,\n            bottom: rect.bottom * scaleY\n        };\n    }\n    function clearLineMeasurementCacheFor(lineView) {\n        if (lineView.measure) {\n            lineView.measure.cache = {};\n            lineView.measure.heights = null;\n            if (lineView.rest)\n                for (let i = 0; i < lineView.rest.length; i++)\n                    lineView.measure.caches[i] = {};\n        }\n    }\n    function clearLineMeasurementCache(cm) {\n        cm.display.externalMeasure = null;\n        dom.removeChildren(cm.display.lineMeasure);\n        for (let i = 0; i < cm.display.view.length; i++)\n            clearLineMeasurementCacheFor(cm.display.view[i]);\n    }\n    function clearCaches(cm) {\n        clearLineMeasurementCache(cm);\n        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n        if (!cm.options.lineWrapping)\n            cm.display.maxLineChanged = true;\n        cm.display.lineNumChars = null;\n    }\n    function pageScrollX() {\n        if (browser.chrome && browser.android)\n            return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));\n        return window.pageXOffset || (document.documentElement || document.body).scrollLeft;\n    }\n    function pageScrollY() {\n        if (browser.chrome && browser.android)\n            return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));\n        return window.pageYOffset || (document.documentElement || document.body).scrollTop;\n    }\n    function widgetTopHeight(lineObj) {\n        let height = 0;\n        if (lineObj.widgets)\n            for (let i = 0; i < lineObj.widgets.length; ++i)\n                if (lineObj.widgets[i].above)\n                    height += widgets.widgetHeight(lineObj.widgets[i]);\n        return height;\n    }\n    function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n        if (!includeWidgets) {\n            let height = widgetTopHeight(lineObj);\n            rect.top += height;\n            rect.bottom += height;\n        }\n        if (context == 'line')\n            return rect;\n        if (!context)\n            context = 'local';\n        let yOff = spans.heightAtLine(lineObj);\n        if (context == 'local')\n            yOff += paddingTop(cm.display);\n        else\n            yOff -= cm.display.viewOffset;\n        if (context == 'page' || context == 'window') {\n            let lOff = cm.display.lineSpace.getBoundingClientRect();\n            yOff += lOff.top + (context == 'window' ? 0 : pageScrollY());\n            let xOff = lOff.left + (context == 'window' ? 0 : pageScrollX());\n            rect.left += xOff;\n            rect.right += xOff;\n        }\n        rect.top += yOff;\n        rect.bottom += yOff;\n        return rect;\n    }\n    function fromCoordSystem(cm, coords, context) {\n        if (context == 'div')\n            return coords;\n        let left = coords.left, top = coords.top;\n        if (context == 'page') {\n            left -= pageScrollX();\n            top -= pageScrollY();\n        } else if (context == 'local' || !context) {\n            let localBox = cm.display.sizer.getBoundingClientRect();\n            left += localBox.left;\n            top += localBox.top;\n        }\n        let lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n        return {\n            left: left - lineSpaceBox.left,\n            top: top - lineSpaceBox.top\n        };\n    }\n    function charCoords(cm, pos, context, lineObj, bias) {\n        if (!lineObj)\n            lineObj = utils_line.getLine(cm.doc, pos.line);\n        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n    }\n    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n        lineObj = lineObj || utils_line.getLine(cm.doc, pos.line);\n        if (!preparedMeasure)\n            preparedMeasure = prepareMeasureForLine(cm, lineObj);\n        function get(ch, right) {\n            let m = measureCharPrepared(cm, preparedMeasure, ch, right ? 'right' : 'left', varHeight);\n            if (right)\n                m.left = m.right;\n            else\n                m.right = m.left;\n            return intoCoordSystem(cm, lineObj, m, context);\n        }\n        let order = bidi.getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n        if (ch >= lineObj.text.length) {\n            ch = lineObj.text.length;\n            sticky = 'before';\n        } else if (ch <= 0) {\n            ch = 0;\n            sticky = 'after';\n        }\n        if (!order)\n            return get(sticky == 'before' ? ch - 1 : ch, sticky == 'before');\n        function getBidi(ch, partPos, invert) {\n            let part = order[partPos], right = part.level == 1;\n            return get(invert ? ch - 1 : ch, right != invert);\n        }\n        let partPos = bidi.getBidiPartAt(order, ch, sticky);\n        let other = bidi.bidiOther;\n        let val = getBidi(ch, partPos, sticky == 'before');\n        if (other != null)\n            val.other = getBidi(ch, other, sticky != 'before');\n        return val;\n    }\n    function estimateCoords(cm, pos) {\n        let left = 0;\n        pos = line_pos.clipPos(cm.doc, pos);\n        if (!cm.options.lineWrapping)\n            left = charWidth(cm.display) * pos.ch;\n        let lineObj = utils_line.getLine(cm.doc, pos.line);\n        let top = spans.heightAtLine(lineObj) + paddingTop(cm.display);\n        return {\n            left: left,\n            right: left,\n            top: top,\n            bottom: top + lineObj.height\n        };\n    }\n    function PosWithInfo(line, ch, sticky, outside, xRel) {\n        let pos = line_pos.Pos(line, ch, sticky);\n        pos.xRel = xRel;\n        if (outside)\n            pos.outside = true;\n        return pos;\n    }\n    function coordsChar(cm, x, y) {\n        let doc = cm.doc;\n        y += cm.display.viewOffset;\n        if (y < 0)\n            return PosWithInfo(doc.first, 0, null, true, -1);\n        let lineN = utils_line.lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n        if (lineN > last)\n            return PosWithInfo(doc.first + doc.size - 1, utils_line.getLine(doc, last).text.length, null, true, 1);\n        if (x < 0)\n            x = 0;\n        let lineObj = utils_line.getLine(doc, lineN);\n        for (;;) {\n            let found = coordsCharInner(cm, lineObj, lineN, x, y);\n            let collapsed = spans.collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 ? 1 : 0));\n            if (!collapsed)\n                return found;\n            let rangeEnd = collapsed.find(1);\n            if (rangeEnd.line == lineN)\n                return rangeEnd;\n            lineObj = utils_line.getLine(doc, lineN = rangeEnd.line);\n        }\n    }\n    function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n        y -= widgetTopHeight(lineObj);\n        let end = lineObj.text.length;\n        let begin = misc.findFirst(ch => measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y, end, 0);\n        end = misc.findFirst(ch => measureCharPrepared(cm, preparedMeasure, ch).top > y, begin, end);\n        return {\n            begin,\n            end\n        };\n    }\n    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n        if (!preparedMeasure)\n            preparedMeasure = prepareMeasureForLine(cm, lineObj);\n        let targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), 'line').top;\n        return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);\n    }\n    function boxIsAfter(box, x, y, left) {\n        return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;\n    }\n    function coordsCharInner(cm, lineObj, lineNo, x, y) {\n        y -= spans.heightAtLine(lineObj);\n        let preparedMeasure = prepareMeasureForLine(cm, lineObj);\n        let widgetHeight = widgetTopHeight(lineObj);\n        let begin = 0, end = lineObj.text.length, ltr = true;\n        let order = bidi.getOrder(lineObj, cm.doc.direction);\n        if (order) {\n            let part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo, preparedMeasure, order, x, y);\n            ltr = part.level != 1;\n            begin = ltr ? part.from : part.to - 1;\n            end = ltr ? part.to : part.from - 1;\n        }\n        let chAround = null, boxAround = null;\n        let ch = misc.findFirst(ch => {\n            let box = measureCharPrepared(cm, preparedMeasure, ch);\n            box.top += widgetHeight;\n            box.bottom += widgetHeight;\n            if (!boxIsAfter(box, x, y, false))\n                return false;\n            if (box.top <= y && box.left <= x) {\n                chAround = ch;\n                boxAround = box;\n            }\n            return true;\n        }, begin, end);\n        let baseX, sticky, outside = false;\n        if (boxAround) {\n            let atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n            ch = chAround + (atStart ? 0 : 1);\n            sticky = atStart ? 'after' : 'before';\n            baseX = atLeft ? boxAround.left : boxAround.right;\n        } else {\n            if (!ltr && (ch == end || ch == begin))\n                ch++;\n            sticky = ch == 0 ? 'after' : ch == lineObj.text.length ? 'before' : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgets.widgetHeight <= y == ltr ? 'after' : 'before';\n            let coords = cursorCoords(cm, line_pos.Pos(lineNo, ch, sticky), 'line', lineObj, preparedMeasure);\n            baseX = coords.left;\n            outside = y < coords.top || y >= coords.bottom;\n        }\n        ch = misc.skipExtendingChars(lineObj.text, ch, 1);\n        return PosWithInfo(lineNo, ch, sticky, outside, x - baseX);\n    }\n    function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {\n        let index = misc.findFirst(i => {\n            let part = order[i], ltr = part.level != 1;\n            return boxIsAfter(cursorCoords(cm, line_pos.Pos(lineNo, ltr ? part.to : part.from, ltr ? 'before' : 'after'), 'line', lineObj, preparedMeasure), x, y, true);\n        }, 0, order.length - 1);\n        let part = order[index];\n        if (index > 0) {\n            let ltr = part.level != 1;\n            let start = cursorCoords(cm, line_pos.Pos(lineNo, ltr ? part.from : part.to, ltr ? 'after' : 'before'), 'line', lineObj, preparedMeasure);\n            if (boxIsAfter(start, x, y, true) && start.top > y)\n                part = order[index - 1];\n        }\n        return part;\n    }\n    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n        let {begin, end} = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n        if (/\\s/.test(lineObj.text.charAt(end - 1)))\n            end--;\n        let part = null, closestDist = null;\n        for (let i = 0; i < order.length; i++) {\n            let p = order[i];\n            if (p.from >= end || p.to <= begin)\n                continue;\n            let ltr = p.level != 1;\n            let endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n            let dist = endX < x ? x - endX + 1000000000 : endX - x;\n            if (!part || closestDist > dist) {\n                part = p;\n                closestDist = dist;\n            }\n        }\n        if (!part)\n            part = order[order.length - 1];\n        if (part.from < begin)\n            part = {\n                from: begin,\n                to: part.to,\n                level: part.level\n            };\n        if (part.to > end)\n            part = {\n                from: part.from,\n                to: end,\n                level: part.level\n            };\n        return part;\n    }\n    let measureText;\n    function textHeight(display) {\n        if (display.cachedTextHeight != null)\n            return display.cachedTextHeight;\n        if (measureText == null) {\n            measureText = dom.elt('pre');\n            for (let i = 0; i < 49; ++i) {\n                measureText.appendChild(document.createTextNode('x'));\n                measureText.appendChild(dom.elt('br'));\n            }\n            measureText.appendChild(document.createTextNode('x'));\n        }\n        dom.removeChildrenAndAdd(display.measure, measureText);\n        let height = measureText.offsetHeight / 50;\n        if (height > 3)\n            display.cachedTextHeight = height;\n        dom.removeChildren(display.measure);\n        return height || 1;\n    }\n    function charWidth(display) {\n        if (display.cachedCharWidth != null)\n            return display.cachedCharWidth;\n        let anchor = dom.elt('span', 'xxxxxxxxxx');\n        let pre = dom.elt('pre', [anchor]);\n        dom.removeChildrenAndAdd(display.measure, pre);\n        let rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n        if (width > 2)\n            display.cachedCharWidth = width;\n        return width || 10;\n    }\n    function getDimensions(cm) {\n        let utils_line = cm.display, left = {}, width = {};\n        let gutterLeft = utils_line.gutters.clientLeft;\n        for (let n = utils_line.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n            left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n            width[cm.options.gutters[i]] = n.clientWidth;\n        }\n        return {\n            fixedPos: compensateForHScroll(utils_line),\n            gutterTotalWidth: utils_line.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: utils_line.wrapper.clientWidth\n        };\n    }\n    function compensateForHScroll(display) {\n        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n    }\n    function estimateHeight(cm) {\n        let th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n        let perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n        return line => {\n            if (spans.lineIsHidden(cm.doc, line))\n                return 0;\n            let widgetsHeight = 0;\n            if (line.widgets)\n                for (let i = 0; i < line.widgets.length; i++) {\n                    if (line.widgets[i].height)\n                        widgetsHeight += line.widgets[i].height;\n                }\n            if (wrapping)\n                return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n            else\n                return widgetsHeight + th;\n        };\n    }\n    function estimateLineHeights(cm) {\n        let doc = cm.doc, est = estimateHeight(cm);\n        doc.iter(line => {\n            let estHeight = est(line);\n            if (estHeight != line.height)\n                utils_line.updateLineHeight(line, estHeight);\n        });\n    }\n    function posFromMouse(cm, e, liberal, forRect) {\n        let display = cm.display;\n        if (!liberal && events.e_target(e).getAttribute('cm-not-content') == 'true')\n            return null;\n        let x, y, space = display.lineSpace.getBoundingClientRect();\n        try {\n            x = e.clientX - space.left;\n            y = e.clientY - space.top;\n        } catch (e) {\n            return null;\n        }\n        let coords = coordsChar(cm, x, y), line;\n        if (forRect && coords.xRel == 1 && (line = utils_line.getLine(cm.doc, coords.line).text).length == coords.ch) {\n            let colDiff = misc.countColumn(line, line.length, cm.options.tabSize) - line.length;\n            coords = line_pos.Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n        }\n        return coords;\n    }\n    function findViewIndex(cm, n) {\n        if (n >= cm.display.viewTo)\n            return null;\n        n -= cm.display.viewFrom;\n        if (n < 0)\n            return null;\n        let view = cm.display.view;\n        for (let i = 0; i < view.length; i++) {\n            n -= view[i].size;\n            if (n < 0)\n                return i;\n        }\n    }\n    return {\n        paddingTop: paddingTop,\n        paddingVert: paddingVert,\n        paddingH: paddingH,\n        scrollGap: scrollGap,\n        displayWidth: displayWidth,\n        displayHeight: displayHeight,\n        mapFromLineView: mapFromLineView,\n        measureChar: measureChar,\n        findViewForLine: findViewForLine,\n        prepareMeasureForLine: prepareMeasureForLine,\n        measureCharPrepared: measureCharPrepared,\n        nodeAndOffsetInLineMap: nodeAndOffsetInLineMap,\n        clearLineMeasurementCacheFor: clearLineMeasurementCacheFor,\n        clearLineMeasurementCache: clearLineMeasurementCache,\n        clearCaches: clearCaches,\n        intoCoordSystem: intoCoordSystem,\n        fromCoordSystem: fromCoordSystem,\n        charCoords: charCoords,\n        cursorCoords: cursorCoords,\n        estimateCoords: estimateCoords,\n        coordsChar: coordsChar,\n        wrappedLineExtentChar: wrappedLineExtentChar,\n        textHeight: textHeight,\n        charWidth: charWidth,\n        getDimensions: getDimensions,\n        compensateForHScroll: compensateForHScroll,\n        estimateHeight: estimateHeight,\n        estimateLineHeights: estimateLineHeights,\n        posFromMouse: posFromMouse,\n        findViewIndex: findViewIndex\n    };\n});"]}