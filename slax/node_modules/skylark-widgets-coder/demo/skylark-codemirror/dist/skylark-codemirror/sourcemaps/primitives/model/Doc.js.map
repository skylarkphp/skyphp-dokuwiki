{"version":3,"sources":["primitives/model/Doc.js"],"names":["define","operations","line_data","m_pos","spans","utils_line","dom","feature_detection","misc","scrolling","changes","change_measurement","chunk","document_data","m_history","line_widget","mark_text","m_selection","selection_updates","nextDocId","Doc","text","mode","firstLine","lineSep","direction","this","BranchChunk","call","LeafChunk","Line","first","scrollTop","scrollLeft","cantEdit","cleanGeneration","modeFrontier","highlightFrontier","start","Pos","sel","simpleSelection","history","History","id","modeOption","extend","splitLines","updateDoc","from","to","setSelection","sel_dontScroll","prototype","createObj","constructor","iter","op","iterN","size","insert","at","lines","height","i","length","insertInner","remove","n","removeInner","getValue","getLines","join","lineSeparator","setValue","docMethodOp","code","top","last","makeChange","getLine","origin","full","cm","scrollToCoords","replaceRange","clipPos","getRange","getBetween","line","l","getLineHandle","isLine","getLineNumber","lineNo","getLineHandleVisualStart","visualLine","lineCount","lastLine","pos","getCursor","range","primary","head","anchor","listSelections","ranges","somethingSelected","setCursor","ch","options","setSimpleSelection","extendSelection","other","extendSelections","heads","clipPosArray","extendSelectionsBy","f","map","setSelections","out","Range","Math","min","primIndex","normalizeSelection","addSelection","slice","push","getSelection","concat","getSelections","parts","replaceSelection","collapse","dup","replaceSelections","newSel","computeReplacedSel","setSelectionReplaceHistory","ensureCursorVisible","undo","makeChangeFromHistory","redo","undoSelection","redoSelection","setExtending","val","getExtending","historySize","hist","done","undone","clearHistory","maxGeneration","markClean","changeGeneration","forceSplit","lastOp","lastSelOp","lastOrigin","generation","isClean","gen","getHistory","copyHistoryArray","setHistory","histData","setGutterMarker","gutterID","value","changeLine","markers","gutterMarkers","isEmpty","clearGutter","lineInfo","handle","textClass","bgClass","wrapClass","widgets","addLineClass","where","cls","prop","classTest","test","removeLineClass","cur","found","match","end","index","addLineWidget","node","removeLineWidget","widget","clear","markText","type","setBookmark","realOpts","replacedWith","nodeType","insertLeft","clearWhenEmpty","shared","handleMouseEvents","findMarksAt","markedSpans","span","marker","parent","findMarks","filter","getAllMarks","sps","posFromIndex","off","sepSize","sz","indexFromPos","coords","copy","copyHistory","doc","undoDepth","linkedDoc","sharedHist","linked","isParent","copySharedMarkers","findSharedMarkers","unlinkDoc","splice","detachSharedMarkers","splitIds","linkedDocs","iterLinkedDocs","getMode","getEditor","str","split","splitLinesAuto","setDirection","dir","order","directionChanged","eachLine"],"mappings":"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","file":"../../../primitives/model/Doc.js","sourcesContent":["define([\n    '../display/operations',\n    '../line/line_data',\n    '../line/pos',\n    '../line/spans',\n    '../line/utils_line',\n    '../util/dom',\n    '../util/feature_detection',\n    '../util/misc',\n    '../display/scrolling',\n    './changes',\n    './change_measurement',\n    './chunk',\n    './document_data',\n    './history',\n    './line_widget',\n    './mark_text',\n    './selection',\n    './selection_updates'\n], function (operations, line_data, m_pos, spans, utils_line, dom, feature_detection, misc, scrolling, changes, change_measurement, chunk, document_data, m_history, line_widget, mark_text, m_selection, selection_updates) {\n    'use strict';\n    let nextDocId = 0;\n    let Doc = function (text, mode, firstLine, lineSep, direction) {\n        if (!(this instanceof Doc))\n            return new Doc(text, mode, firstLine, lineSep, direction);\n        if (firstLine == null)\n            firstLine = 0;\n        chunk.BranchChunk.call(this, [new chunk.LeafChunk([new line_data.Line('', null)])]);\n        this.first = firstLine;\n        this.scrollTop = this.scrollLeft = 0;\n        this.cantEdit = false;\n        this.cleanGeneration = 1;\n        this.modeFrontier = this.highlightFrontier = firstLine;\n        let start = m_pos.Pos(firstLine, 0);\n        this.sel = m_selection.simpleSelection(start);\n        this.history = new m_history.History(null);\n        this.id = ++nextDocId;\n        this.modeOption = mode;\n        this.lineSep = lineSep;\n        this.direction = direction == 'rtl' ? 'rtl' : 'ltr';\n        this.extend = false;\n        if (typeof text == 'string')\n            text = this.splitLines(text);\n        document_data.updateDoc(this, {\n            from: start,\n            to: start,\n            text: text\n        });\n        selection_updates.setSelection(this, m_selection.simpleSelection(start), misc.sel_dontScroll);\n    };\n    Doc.prototype = misc.createObj(chunk.BranchChunk.prototype, {\n        constructor: Doc,\n        iter: function (from, to, op) {\n            if (op)\n                this.iterN(from - this.first, to - from, op);\n            else\n                this.iterN(this.first, this.first + this.size, from);\n        },\n        insert: function (at, lines) {\n            let height = 0;\n            for (let i = 0; i < lines.length; ++i)\n                height += lines[i].height;\n            this.insertInner(at - this.first, lines, height);\n        },\n        remove: function (at, n) {\n            this.removeInner(at - this.first, n);\n        },\n        getValue: function (lineSep) {\n            let lines = utils_line.getLines(this, this.first, this.first + this.size);\n            if (lineSep === false)\n                return lines;\n            return lines.join(lineSep || this.lineSeparator());\n        },\n        setValue: operations.docMethodOp(function (code) {\n            let top = m_pos.Pos(this.first, 0), last = this.first + this.size - 1;\n            changes.makeChange(this, {\n                from: top,\n                to: m_pos.Pos(last, utils_line.getLine(this, last).text.length),\n                text: this.splitLines(code),\n                origin: 'setValue',\n                full: true\n            }, true);\n            if (this.cm)\n                scrolling.scrollToCoords(this.cm, 0, 0);\n            selection_updates.setSelection(this, m_selection.simpleSelection(top), misc.sel_dontScroll);\n        }),\n        replaceRange: function (code, from, to, origin) {\n            from = m_pos.clipPos(this, from);\n            to = to ? m_pos.clipPos(this, to) : from;\n            changes.replaceRange(this, code, from, to, origin);\n        },\n        getRange: function (from, to, lineSep) {\n            let lines = utils_line.getBetween(this, m_pos.clipPos(this, from), m_pos.clipPos(this, to));\n            if (lineSep === false)\n                return lines;\n            return lines.join(lineSep || this.lineSeparator());\n        },\n        getLine: function (line) {\n            let l = this.getLineHandle(line);\n            return l && l.text;\n        },\n        getLineHandle: function (line) {\n            if (utils_line.isLine(this, line))\n                return utils_line.getLine(this, line);\n        },\n        getLineNumber: function (line) {\n            return utils_line.lineNo(line);\n        },\n        getLineHandleVisualStart: function (line) {\n            if (typeof line == 'number')\n                line = utils_line.getLine(this, line);\n            return spans.visualLine(line);\n        },\n        lineCount: function () {\n            return this.size;\n        },\n        firstLine: function () {\n            return this.first;\n        },\n        lastLine: function () {\n            return this.first + this.size - 1;\n        },\n        clipPos: function (pos) {\n            return m_pos.clipPos(this, pos);\n        },\n        getCursor: function (start) {\n            let range = this.sel.primary(), pos;\n            if (start == null || start == 'head')\n                pos = range.head;\n            else if (start == 'anchor')\n                pos = range.anchor;\n            else if (start == 'end' || start == 'to' || start === false)\n                pos = range.to();\n            else\n                pos = range.from();\n            return pos;\n        },\n        listSelections: function () {\n            return this.sel.ranges;\n        },\n        somethingSelected: function () {\n            return this.sel.somethingSelected();\n        },\n        setCursor: operations.docMethodOp(function (line, ch, options) {\n            selection_updates.setSimpleSelection(this, m_pos.clipPos(this, typeof line == 'number' ? m_pos.Pos(line, ch || 0) : line), null, options);\n        }),\n        setSelection: operations.docMethodOp(function (anchor, head, options) {\n            selection_updates.setSimpleSelection(this, m_pos.clipPos(this, anchor), m_pos.clipPos(this, head || anchor), options);\n        }),\n        extendSelection: operations.docMethodOp(function (head, other, options) {\n            selection_updates.extendSelection(this, m_pos.clipPos(this, head), other && m_pos.clipPos(this, other), options);\n        }),\n        extendSelections: operations.docMethodOp(function (heads, options) {\n            selection_updates.extendSelections(this, m_pos.clipPosArray(this, heads), options);\n        }),\n        extendSelectionsBy: operations.docMethodOp(function (f, options) {\n            let heads = misc.map(this.sel.ranges, f);\n            selection_updates.extendSelections(this, m_pos.clipPosArray(this, heads), options);\n        }),\n        setSelections: operations.docMethodOp(function (ranges, primary, options) {\n            if (!ranges.length)\n                return;\n            let out = [];\n            for (let i = 0; i < ranges.length; i++)\n                out[i] = new m_selection.Range(m_pos.clipPos(this, ranges[i].anchor), m_pos.clipPos(this, ranges[i].head));\n            if (primary == null)\n                primary = Math.min(ranges.length - 1, this.sel.primIndex);\n            selection_updates.setSelection(this, m_selection.normalizeSelection(this.cm, out, primary), options);\n        }),\n        addSelection: operations.docMethodOp(function (anchor, head, options) {\n            let ranges = this.sel.ranges.slice(0);\n            ranges.push(new m_selection.Range(m_pos.clipPos(this, anchor), m_pos.clipPos(this, head || anchor)));\n            selection_updates.setSelection(this, m_selection.normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n        }),\n        getSelection: function (lineSep) {\n            let ranges = this.sel.ranges, lines;\n            for (let i = 0; i < ranges.length; i++) {\n                let sel = utils_line.getBetween(this, ranges[i].from(), ranges[i].to());\n                lines = lines ? lines.concat(sel) : sel;\n            }\n            if (lineSep === false)\n                return lines;\n            else\n                return lines.join(lineSep || this.lineSeparator());\n        },\n        getSelections: function (lineSep) {\n            let parts = [], ranges = this.sel.ranges;\n            for (let i = 0; i < ranges.length; i++) {\n                let sel = utils_line.getBetween(this, ranges[i].from(), ranges[i].to());\n                if (lineSep !== false)\n                    sel = sel.join(lineSep || this.lineSeparator());\n                parts[i] = sel;\n            }\n            return parts;\n        },\n        replaceSelection: function (code, collapse, origin) {\n            let dup = [];\n            for (let i = 0; i < this.sel.ranges.length; i++)\n                dup[i] = code;\n            this.replaceSelections(dup, collapse, origin || '+input');\n        },\n        replaceSelections: operations.docMethodOp(function (code, collapse, origin) {\n            let changes = [], sel = this.sel;\n            for (let i = 0; i < sel.ranges.length; i++) {\n                let range = sel.ranges[i];\n                changes[i] = {\n                    from: range.from(),\n                    to: range.to(),\n                    text: this.splitLines(code[i]),\n                    origin: origin\n                };\n            }\n            let newSel = collapse && collapse != 'end' && change_measurement.computeReplacedSel(this, changes, collapse);\n            for (let i = changes.length - 1; i >= 0; i--)\n                changes.makeChange(this, changes[i]);\n            if (newSel)\n                selection_updates.setSelectionReplaceHistory(this, newSel);\n            else if (this.cm)\n                scrolling.ensureCursorVisible(this.cm);\n        }),\n        undo: operations.docMethodOp(function () {\n            changes.makeChangeFromHistory(this, 'undo');\n        }),\n        redo: operations.docMethodOp(function () {\n            changes.makeChangeFromHistory(this, 'redo');\n        }),\n        undoSelection: operations.docMethodOp(function () {\n            changes.makeChangeFromHistory(this, 'undo', true);\n        }),\n        redoSelection: operations.docMethodOp(function () {\n            changes.makeChangeFromHistory(this, 'redo', true);\n        }),\n        setExtending: function (val) {\n            this.extend = val;\n        },\n        getExtending: function () {\n            return this.extend;\n        },\n        historySize: function () {\n            let hist = this.history, done = 0, undone = 0;\n            for (let i = 0; i < hist.done.length; i++)\n                if (!hist.done[i].ranges)\n                    ++done;\n            for (let i = 0; i < hist.undone.length; i++)\n                if (!hist.undone[i].ranges)\n                    ++undone;\n            return {\n                undo: done,\n                redo: undone\n            };\n        },\n        clearHistory: function () {\n            this.history = new m_history.History(this.history.maxGeneration);\n        },\n        markClean: function () {\n            this.cleanGeneration = this.changeGeneration(true);\n        },\n        changeGeneration: function (forceSplit) {\n            if (forceSplit)\n                this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n            return this.history.generation;\n        },\n        isClean: function (gen) {\n            return this.history.generation == (gen || this.cleanGeneration);\n        },\n        getHistory: function () {\n            return {\n                done: m_history.copyHistoryArray(this.history.done),\n                undone: m_history.copyHistoryArray(this.history.undone)\n            };\n        },\n        setHistory: function (histData) {\n            let hist = this.history = new m_history.History(this.history.maxGeneration);\n            hist.done = m_history.copyHistoryArray(histData.done.slice(0), null, true);\n            hist.undone = m_history.copyHistoryArray(histData.undone.slice(0), null, true);\n        },\n        setGutterMarker: operations.docMethodOp(function (line, gutterID, value) {\n            return changes.changeLine(this, line, 'gutter', line => {\n                let markers = line.gutterMarkers || (line.gutterMarkers = {});\n                markers[gutterID] = value;\n                if (!value && misc.isEmpty(markers))\n                    line.gutterMarkers = null;\n                return true;\n            });\n        }),\n        clearGutter: operations.docMethodOp(function (gutterID) {\n            this.iter(line => {\n                if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n                    changes.changeLine(this, line, 'gutter', () => {\n                        line.gutterMarkers[gutterID] = null;\n                        if (misc.isEmpty(line.gutterMarkers))\n                            line.gutterMarkers = null;\n                        return true;\n                    });\n                }\n            });\n        }),\n        lineInfo: function (line) {\n            let n;\n            if (typeof line == 'number') {\n                if (!utils_line.isLine(this, line))\n                    return null;\n                n = line;\n                line = utils_line.getLine(this, line);\n                if (!line)\n                    return null;\n            } else {\n                n = utils_line.lineNo(line);\n                if (n == null)\n                    return null;\n            }\n            return {\n                line: n,\n                handle: line,\n                text: line.text,\n                gutterMarkers: line.gutterMarkers,\n                textClass: line.textClass,\n                bgClass: line.bgClass,\n                wrapClass: line.wrapClass,\n                widgets: line.widgets\n            };\n        },\n        addLineClass: operations.docMethodOp(function (handle, where, cls) {\n            return changes.changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', line => {\n                let prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';\n                if (!line[prop])\n                    line[prop] = cls;\n                else if (dom.classTest(cls).test(line[prop]))\n                    return false;\n                else\n                    line[prop] += ' ' + cls;\n                return true;\n            });\n        }),\n        removeLineClass: operations.docMethodOp(function (handle, where, cls) {\n            return changes.changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', line => {\n                let prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';\n                let cur = line[prop];\n                if (!cur)\n                    return false;\n                else if (cls == null)\n                    line[prop] = null;\n                else {\n                    let found = cur.match(dom.classTest(cls));\n                    if (!found)\n                        return false;\n                    let end = found.index + found[0].length;\n                    line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? '' : ' ') + cur.slice(end) || null;\n                }\n                return true;\n            });\n        }),\n        addLineWidget: operations.docMethodOp(function (handle, node, options) {\n            return line_widget.addLineWidget(this, handle, node, options);\n        }),\n        removeLineWidget: function (widget) {\n            widget.clear();\n        },\n        markText: function (from, to, options) {\n            return mark_text.markText(this, m_pos.clipPos(this, from), m_pos.clipPos(this, to), options, options && options.type || 'range');\n        },\n        setBookmark: function (pos, options) {\n            let realOpts = {\n                replacedWith: options && (options.nodeType == null ? options.widget : options),\n                insertLeft: options && options.insertLeft,\n                clearWhenEmpty: false,\n                shared: options && options.shared,\n                handleMouseEvents: options && options.handleMouseEvents\n            };\n            pos = m_pos.clipPos(this, pos);\n            return mark_text.markText(this, pos, pos, realOpts, 'bookmark');\n        },\n        findMarksAt: function (pos) {\n            pos = m_pos.clipPos(this, pos);\n            let markers = [], spans = utils_line.getLine(this, pos.line).markedSpans;\n            if (spans)\n                for (let i = 0; i < spans.length; ++i) {\n                    let span = spans[i];\n                    if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))\n                        markers.push(span.marker.parent || span.marker);\n                }\n            return markers;\n        },\n        findMarks: function (from, to, filter) {\n            from = m_pos.clipPos(this, from);\n            to = m_pos.clipPos(this, to);\n            let found = [], lineNo = from.line;\n            this.iter(from.line, to.line + 1, line => {\n                let spans = line.markedSpans;\n                if (spans)\n                    for (let i = 0; i < spans.length; i++) {\n                        let span = spans[i];\n                        if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker)))\n                            found.push(span.marker.parent || span.marker);\n                    }\n                ++lineNo;\n            });\n            return found;\n        },\n        getAllMarks: function () {\n            let markers = [];\n            this.iter(line => {\n                let sps = line.markedSpans;\n                if (sps)\n                    for (let i = 0; i < sps.length; ++i)\n                        if (sps[i].from != null)\n                            markers.push(sps[i].marker);\n            });\n            return markers;\n        },\n        posFromIndex: function (off) {\n            let ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n            this.iter(line => {\n                let sz = line.text.length + sepSize;\n                if (sz > off) {\n                    ch = off;\n                    return true;\n                }\n                off -= sz;\n                ++lineNo;\n            });\n            return m_pos.clipPos(this, m_pos.Pos(lineNo, ch));\n        },\n        indexFromPos: function (coords) {\n            coords = m_pos.clipPos(this, coords);\n            let index = coords.ch;\n            if (coords.line < this.first || coords.ch < 0)\n                return 0;\n            let sepSize = this.lineSeparator().length;\n            this.iter(this.first, coords.line, line => {\n                index += line.text.length + sepSize;\n            });\n            return index;\n        },\n        copy: function (copyHistory) {\n            let doc = new Doc(utils_line.getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);\n            doc.scrollTop = this.scrollTop;\n            doc.scrollLeft = this.scrollLeft;\n            doc.sel = this.sel;\n            doc.extend = false;\n            if (copyHistory) {\n                doc.history.undoDepth = this.history.undoDepth;\n                doc.setHistory(this.getHistory());\n            }\n            return doc;\n        },\n        linkedDoc: function (options) {\n            if (!options)\n                options = {};\n            let from = this.first, to = this.first + this.size;\n            if (options.from != null && options.from > from)\n                from = options.from;\n            if (options.to != null && options.to < to)\n                to = options.to;\n            let copy = new Doc(utils_line.getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n            if (options.sharedHist)\n                copy.history = this.history;\n            (this.linked || (this.linked = [])).push({\n                doc: copy,\n                sharedHist: options.sharedHist\n            });\n            copy.linked = [{\n                    doc: this,\n                    isParent: true,\n                    sharedHist: options.sharedHist\n                }];\n            line_widget.copySharedMarkers(copy, line_widget.findSharedMarkers(this));\n            return copy;\n        },\n        unlinkDoc: function (other) {\n            //if (other instanceof CodeMirror) // modified by lwf\n            if (other.doc)\n                other = other.doc;\n            if (this.linked)\n                for (let i = 0; i < this.linked.length; ++i) {\n                    let link = this.linked[i];\n                    if (link.doc != other)\n                        continue;\n                    this.linked.splice(i, 1);\n                    other.unlinkDoc(this);\n                    line_widget.detachSharedMarkers(line_widget.findSharedMarkers(this));\n                    break;\n                }\n            if (other.history == this.history) {\n                let splitIds = [other.id];\n                document_data.linkedDocs(other, doc => splitIds.push(doc.id), true);\n                other.history = new m_history.History(null);\n                other.history.done = m_history.copyHistoryArray(this.history.done, splitIds);\n                other.history.undone = m_history.copyHistoryArray(this.history.undone, splitIds);\n            }\n        },\n        iterLinkedDocs: function (f) {\n            document_data.linkedDocs(this, f);\n        },\n        getMode: function () {\n            return this.mode;\n        },\n        getEditor: function () {\n            return this.cm;\n        },\n        splitLines: function (str) {\n            if (this.lineSep)\n                return str.split(this.lineSep);\n            return feature_detection.splitLinesAuto(str);\n        },\n        lineSeparator: function () {\n            return this.lineSep || '\\n';\n        },\n        setDirection: operations.docMethodOp(function (dir) {\n            if (dir != 'rtl')\n                dir = 'ltr';\n            if (dir == this.direction)\n                return;\n            this.direction = dir;\n            this.iter(line => line.order = null);\n            if (this.cm)\n                document_data.directionChanged(this.cm);\n        })\n    });\n    Doc.prototype.eachLine = Doc.prototype.iter;\n    return Doc;\n});"]}