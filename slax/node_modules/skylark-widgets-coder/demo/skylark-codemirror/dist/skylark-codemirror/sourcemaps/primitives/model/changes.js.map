{"version":3,"sources":["primitives/model/changes.js"],"names":["define","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","filterChange","doc","change","update","obj","canceled","from","to","text","origin","cancel","clipPos","undefined","signal","cm","curOp","updateInput","makeChange","ignoreReadOnly","operation","state","suppressEdits","hasHandler","split","sawReadOnlySpans","removeReadOnlyRanges","length","makeChangeInner","cmp","selAfter","computeSelAfterChange","addChangeToHistory","id","NaN","makeChangeSingleDoc","stretchSpansOverChange","rebased","linkedDocs","sharedHist","indexOf","history","rebaseHist","push","shiftDoc","distance","first","sel","Selection","map","ranges","range","Range","Pos","anchor","line","ch","head","primIndex","regChange","display","viewFrom","viewTo","regLineChange","spans","lastLine","shift","lst","last","getLine","removed","getBetween","recomputeMaxLength","checkWidthStart","options","lineWrapping","lineNo","visualLine","iter","maxLine","contains","signalCursorActivity","updateDoc","estimateHeight","len","lineLength","maxLineLength","maxLineChanged","updateMaxLine","retreatFrontier","startWorker","lendiff","full","isWholeLineUpdate","changesHandler","changeHandler","signalLater","changeObjs","selForContextMenu","makeChangeSingleDocInEditor","setSelectionNoUndo","sel_dontScroll","rebaseHistSelSingle","pos","diff","rebaseHistArray","array","sub","ok","copied","deepCopy","changes","cur","splice","hist","done","undone","makeChangeFromHistory","type","allowSelectionOnly","suppress","event","source","dest","equals","lastOrigin","lastSelOrigin","pop","pushSelectionToHistory","setSelection","clearRedo","antiChanges","generation","maxGeneration","filter","historyChangeFromChange","after","mergeOldSpans","scrollIntoView","changeEnd","replaceRange","code","splitLines","changeLine","handle","changeType","op","no","clipLine"],"mappings":"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","file":"../../../primitives/model/changes.js","sourcesContent":["define([\n    '../line/highlight',\n    '../display/highlight_worker',\n    '../display/operations',\n    '../display/view_tracking',\n    '../line/pos',\n    '../line/saw_special_spans',\n    '../line/spans',\n    '../line/utils_line',\n    '../measurement/position_measurement',\n    '../util/event',\n    '../util/misc',\n    '../util/operation_group',\n    './change_measurement',\n    './document_data',\n    './history',\n    './selection',\n    './selection_updates'\n], function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {\n    'use strict';\n    function filterChange(doc, change, update) {\n        let obj = {\n            canceled: false,\n            from: change.from,\n            to: change.to,\n            text: change.text,\n            origin: change.origin,\n            cancel: () => obj.canceled = true\n        };\n        if (update)\n            obj.update = (from, to, text, origin) => {\n                if (from)\n                    obj.from = e.clipPos(doc, from);\n                if (to)\n                    obj.to = e.clipPos(doc, to);\n                if (text)\n                    obj.text = text;\n                if (origin !== undefined)\n                    obj.origin = origin;\n            };\n        j.signal(doc, 'beforeChange', doc, obj);\n        if (doc.cm)\n            j.signal(doc.cm, 'beforeChange', doc.cm, obj);\n        if (obj.canceled) {\n            if (doc.cm)\n                doc.cm.curOp.updateInput = 2;\n            return null;\n        }\n        return {\n            from: obj.from,\n            to: obj.to,\n            text: obj.text,\n            origin: obj.origin\n        };\n    }\n    function makeChange(doc, change, ignoreReadOnly) {\n        if (doc.cm) {\n            if (!doc.cm.curOp)\n                return c.operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n            if (doc.cm.state.suppressEdits)\n                return;\n        }\n        if (j.hasHandler(doc, 'beforeChange') || doc.cm && j.hasHandler(doc.cm, 'beforeChange')) {\n            change = filterChange(doc, change, true);\n            if (!change)\n                return;\n        }\n        let split = f.sawReadOnlySpans && !ignoreReadOnly && g.removeReadOnlyRanges(doc, change.from, change.to);\n        if (split) {\n            for (let i = split.length - 1; i >= 0; --i)\n                makeChangeInner(doc, {\n                    from: split[i].from,\n                    to: split[i].to,\n                    text: i ? [''] : change.text,\n                    origin: change.origin\n                });\n        } else {\n            makeChangeInner(doc, change);\n        }\n    }\n    function makeChangeInner(doc, change) {\n        if (change.text.length == 1 && change.text[0] == '' && e.cmp(change.from, change.to) == 0)\n            return;\n        let selAfter = m.computeSelAfterChange(doc, change);\n        o.addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n        makeChangeSingleDoc(doc, change, selAfter, g.stretchSpansOverChange(doc, change));\n        let rebased = [];\n        n.linkedDocs(doc, (doc, sharedHist) => {\n            if (!sharedHist && k.indexOf(rebased, doc.history) == -1) {\n                rebaseHist(doc.history, change);\n                rebased.push(doc.history);\n            }\n            makeChangeSingleDoc(doc, change, null, g.stretchSpansOverChange(doc, change));\n        });\n    }\n    function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n        let suppress = doc.cm && doc.cm.state.suppressEdits;\n        if (suppress && !allowSelectionOnly)\n            return;\n        let hist = doc.history, event, selAfter = doc.sel;\n        let source = type == 'undo' ? hist.done : hist.undone, dest = type == 'undo' ? hist.undone : hist.done;\n        let i = 0;\n        for (; i < source.length; i++) {\n            event = source[i];\n            if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n                break;\n        }\n        if (i == source.length)\n            return;\n        hist.lastOrigin = hist.lastSelOrigin = null;\n        for (;;) {\n            event = source.pop();\n            if (event.ranges) {\n                o.pushSelectionToHistory(event, dest);\n                if (allowSelectionOnly && !event.equals(doc.sel)) {\n                    q.setSelection(doc, event, { clearRedo: false });\n                    return;\n                }\n                selAfter = event;\n            } else if (suppress) {\n                source.push(event);\n                return;\n            } else\n                break;\n        }\n        let antiChanges = [];\n        o.pushSelectionToHistory(selAfter, dest);\n        dest.push({\n            changes: antiChanges,\n            generation: hist.generation\n        });\n        hist.generation = event.generation || ++hist.maxGeneration;\n        let filter = j.hasHandler(doc, 'beforeChange') || doc.cm && j.hasHandler(doc.cm, 'beforeChange');\n        for (let i = event.changes.length - 1; i >= 0; --i) {\n            let change = event.changes[i];\n            change.origin = type;\n            if (filter && !filterChange(doc, change, false)) {\n                source.length = 0;\n                return;\n            }\n            antiChanges.push(o.historyChangeFromChange(doc, change));\n            let after = i ? m.computeSelAfterChange(doc, change) : k.lst(source);\n            makeChangeSingleDoc(doc, change, after, o.mergeOldSpans(doc, change));\n            if (!i && doc.cm)\n                doc.cm.scrollIntoView({\n                    from: change.from,\n                    to: m.changeEnd(change)\n                });\n            let rebased = [];\n            n.linkedDocs(doc, (doc, sharedHist) => {\n                if (!sharedHist && k.indexOf(rebased, doc.history) == -1) {\n                    rebaseHist(doc.history, change);\n                    rebased.push(doc.history);\n                }\n                makeChangeSingleDoc(doc, change, null, o.mergeOldSpans(doc, change));\n            });\n        }\n    }\n    function shiftDoc(doc, distance) {\n        if (distance == 0)\n            return;\n        doc.first += distance;\n        doc.sel = new p.Selection(k.map(doc.sel.ranges, range => new p.Range(e.Pos(range.anchor.line + distance, range.anchor.ch), e.Pos(range.head.line + distance, range.head.ch))), doc.sel.primIndex);\n        if (doc.cm) {\n            d.regChange(doc.cm, doc.first, doc.first - distance, distance);\n            for (let d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n                d.regLineChange(doc.cm, l, 'gutter');\n        }\n    }\n    function makeChangeSingleDoc(doc, change, selAfter, spans) {\n        if (doc.cm && !doc.cm.curOp)\n            return c.operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n        if (change.to.line < doc.first) {\n            shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n            return;\n        }\n        if (change.from.line > doc.lastLine())\n            return;\n        if (change.from.line < doc.first) {\n            let shift = change.text.length - 1 - (doc.first - change.from.line);\n            shiftDoc(doc, shift);\n            change = {\n                from: e.Pos(doc.first, 0),\n                to: e.Pos(change.to.line + shift, change.to.ch),\n                text: [k.lst(change.text)],\n                origin: change.origin\n            };\n        }\n        let last = doc.lastLine();\n        if (change.to.line > last) {\n            change = {\n                from: change.from,\n                to: e.Pos(last, h.getLine(doc, last).text.length),\n                text: [change.text[0]],\n                origin: change.origin\n            };\n        }\n        change.removed = h.getBetween(doc, change.from, change.to);\n        if (!selAfter)\n            selAfter = m.computeSelAfterChange(doc, change);\n        if (doc.cm)\n            makeChangeSingleDocInEditor(doc.cm, change, spans);\n        else\n            n.updateDoc(doc, change, spans);\n        q.setSelectionNoUndo(doc, selAfter, k.sel_dontScroll);\n    }\n    function makeChangeSingleDocInEditor(cm, change, spans) {\n        let doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n        let recomputeMaxLength = false, checkWidthStart = from.line;\n        if (!cm.options.lineWrapping) {\n            checkWidthStart = h.lineNo(g.visualLine(h.getLine(doc, from.line)));\n            doc.iter(checkWidthStart, to.line + 1, line => {\n                if (line == display.maxLine) {\n                    recomputeMaxLength = true;\n                    return true;\n                }\n            });\n        }\n        if (doc.sel.contains(change.from, change.to) > -1)\n            j.signalCursorActivity(cm);\n        n.updateDoc(doc, change, spans, i.estimateHeight(cm));\n        if (!cm.options.lineWrapping) {\n            doc.iter(checkWidthStart, from.line + change.text.length, line => {\n                let len = g.lineLength(line);\n                if (len > display.maxLineLength) {\n                    display.maxLine = line;\n                    display.maxLineLength = len;\n                    display.maxLineChanged = true;\n                    recomputeMaxLength = false;\n                }\n            });\n            if (recomputeMaxLength)\n                cm.curOp.updateMaxLine = true;\n        }\n        a.retreatFrontier(doc, from.line);\n        b.startWorker(cm, 400);\n        let lendiff = change.text.length - (to.line - from.line) - 1;\n        if (change.full)\n            d.regChange(cm);\n        else if (from.line == to.line && change.text.length == 1 && !n.isWholeLineUpdate(cm.doc, change))\n            d.regLineChange(cm, from.line, 'text');\n        else\n            d.regChange(cm, from.line, to.line + 1, lendiff);\n        let changesHandler = j.hasHandler(cm, 'changes'), changeHandler = j.hasHandler(cm, 'change');\n        if (changeHandler || changesHandler) {\n            let obj = {\n                from: from,\n                to: to,\n                text: change.text,\n                removed: change.removed,\n                origin: change.origin\n            };\n            if (changeHandler)\n                l.signalLater(cm, 'change', cm, obj);\n            if (changesHandler)\n                (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n        }\n        cm.display.selForContextMenu = null;\n    }\n    function replaceRange(doc, code, from, to, origin) {\n        if (!to)\n            to = from;\n        if (e.cmp(to, from) < 0)\n            [from, to] = [\n                to,\n                from\n            ];\n        if (typeof code == 'string')\n            code = doc.splitLines(code);\n        makeChange(doc, {\n            from,\n            to,\n            text: code,\n            origin\n        });\n    }\n    function rebaseHistSelSingle(pos, from, to, diff) {\n        if (to < pos.line) {\n            pos.line += diff;\n        } else if (from < pos.line) {\n            pos.line = from;\n            pos.ch = 0;\n        }\n    }\n    function rebaseHistArray(array, from, to, diff) {\n        for (let i = 0; i < array.length; ++i) {\n            let sub = array[i], ok = true;\n            if (sub.ranges) {\n                if (!sub.copied) {\n                    sub = array[i] = sub.deepCopy();\n                    sub.copied = true;\n                }\n                for (let j = 0; j < sub.ranges.length; j++) {\n                    rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n                    rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n                }\n                continue;\n            }\n            for (let j = 0; j < sub.changes.length; ++j) {\n                let cur = sub.changes[j];\n                if (to < cur.from.line) {\n                    cur.from = e.Pos(cur.from.line + diff, cur.from.ch);\n                    cur.to = e.Pos(cur.to.line + diff, cur.to.ch);\n                } else if (from <= cur.to.line) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (!ok) {\n                array.splice(0, i + 1);\n                i = 0;\n            }\n        }\n    }\n    function rebaseHist(hist, change) {\n        let from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n        rebaseHistArray(hist.done, from, to, diff);\n        rebaseHistArray(hist.undone, from, to, diff);\n    }\n    function changeLine(doc, handle, changeType, op) {\n        let no = handle, line = handle;\n        if (typeof handle == 'number')\n            line = h.getLine(doc, e.clipLine(doc, handle));\n        else\n            no = h.lineNo(handle);\n        if (no == null)\n            return null;\n        if (op(line, no) && doc.cm)\n            d.regLineChange(doc.cm, no, changeType);\n        return line;\n    }\n    return {\n        makeChange: makeChange,\n        makeChangeFromHistory: makeChangeFromHistory,\n        replaceRange: replaceRange,\n        changeLine: changeLine\n    };\n});"]}