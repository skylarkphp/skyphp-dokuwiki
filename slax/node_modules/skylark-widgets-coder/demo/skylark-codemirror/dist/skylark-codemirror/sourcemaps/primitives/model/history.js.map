{"version":3,"sources":["primitives/model/history.js"],"names":["define","a","b","c","d","e","f","g","h","historyChangeFromChange","doc","change","histChange","from","copyPos","to","changeEnd","text","getBetween","attachLocalSpans","line","linkedDocs","clearSelectionEvents","array","length","lst","ranges","pop","pushSelectionToHistory","sel","dest","top","equals","push","existing","id","n","iter","Math","max","first","min","size","markedSpans","removeClearedSpans","spans","out","i","marker","explicitlyCleared","slice","History","startGen","this","done","undone","undoDepth","Infinity","lastModTime","lastSelTime","lastOp","lastSelOp","lastOrigin","lastSelOrigin","generation","maxGeneration","addChangeToHistory","selAfter","opId","hist","history","cur","last","time","Date","origin","charAt","cm","options","historyEventDelay","force","lastChangeEvent","changes","cmp","before","shift","signal","addSelectionToHistory","prev","ch","somethingSelected","selectionEventCanBeMerged","clearRedo","mergeOldSpans","old","found","nw","getOldSpans","stretched","stretchSpansOverChange","oldCur","stretchCur","j","span","k","copyHistoryArray","events","newGroup","instantiateSel","copy","event","Selection","prototype","deepCopy","call","newChanges","m","prop","match","indexOf","Number"],"mappings":"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","file":"../../../primitives/model/history.js","sourcesContent":["define([\n    '../line/pos',\n    '../line/spans',\n    '../line/utils_line',\n    '../util/event',\n    '../util/misc',\n    './change_measurement',\n    './document_data',\n    './selection'\n], function (a, b, c, d, e, f, g, h) {\n    'use strict';\n    function History(startGen) {\n        this.done = [];\n        this.undone = [];\n        this.undoDepth = Infinity;\n        this.lastModTime = this.lastSelTime = 0;\n        this.lastOp = this.lastSelOp = null;\n        this.lastOrigin = this.lastSelOrigin = null;\n        this.generation = this.maxGeneration = startGen || 1;\n    }\n    function historyChangeFromChange(doc, change) {\n        let histChange = {\n            from: a.copyPos(change.from),\n            to: f.changeEnd(change),\n            text: c.getBetween(doc, change.from, change.to)\n        };\n        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n        g.linkedDocs(doc, doc => attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1), true);\n        return histChange;\n    }\n    function clearSelectionEvents(array) {\n        while (array.length) {\n            let last = e.lst(array);\n            if (last.ranges)\n                array.pop();\n            else\n                break;\n        }\n    }\n    function lastChangeEvent(hist, force) {\n        if (force) {\n            clearSelectionEvents(hist.done);\n            return e.lst(hist.done);\n        } else if (hist.done.length && !e.lst(hist.done).ranges) {\n            return e.lst(hist.done);\n        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n            hist.done.pop();\n            return e.lst(hist.done);\n        }\n    }\n    function addChangeToHistory(doc, change, selAfter, opId) {\n        let hist = doc.history;\n        hist.undone.length = 0;\n        let time = +new Date(), cur;\n        let last;\n        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == '*')) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n            last = e.lst(cur.changes);\n            if (a.cmp(change.from, change.to) == 0 && a.cmp(change.from, last.to) == 0) {\n                last.to = f.changeEnd(change);\n            } else {\n                cur.changes.push(historyChangeFromChange(doc, change));\n            }\n        } else {\n            let before = e.lst(hist.done);\n            if (!before || !before.ranges)\n                pushSelectionToHistory(doc.sel, hist.done);\n            cur = {\n                changes: [historyChangeFromChange(doc, change)],\n                generation: hist.generation\n            };\n            hist.done.push(cur);\n            while (hist.done.length > hist.undoDepth) {\n                hist.done.shift();\n                if (!hist.done[0].ranges)\n                    hist.done.shift();\n            }\n        }\n        hist.done.push(selAfter);\n        hist.generation = ++hist.maxGeneration;\n        hist.lastModTime = hist.lastSelTime = time;\n        hist.lastOp = hist.lastSelOp = opId;\n        hist.lastOrigin = hist.lastSelOrigin = change.origin;\n        if (!last)\n            d.signal(doc, 'historyAdded');\n    }\n    function selectionEventCanBeMerged(doc, origin, prev, sel) {\n        let ch = origin.charAt(0);\n        return ch == '*' || ch == '+' && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n    }\n    function addSelectionToHistory(doc, sel, opId, options) {\n        let hist = doc.history, origin = options && options.origin;\n        if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, e.lst(hist.done), sel)))\n            hist.done[hist.done.length - 1] = sel;\n        else\n            pushSelectionToHistory(sel, hist.done);\n        hist.lastSelTime = +new Date();\n        hist.lastSelOrigin = origin;\n        hist.lastSelOp = opId;\n        if (options && options.clearRedo !== false)\n            clearSelectionEvents(hist.undone);\n    }\n    function pushSelectionToHistory(sel, dest) {\n        let top = e.lst(dest);\n        if (!(top && top.ranges && top.equals(sel)))\n            dest.push(sel);\n    }\n    function attachLocalSpans(doc, change, from, to) {\n        let existing = change['spans_' + doc.id], n = 0;\n        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), line => {\n            if (line.markedSpans)\n                (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;\n            ++n;\n        });\n    }\n    function removeClearedSpans(spans) {\n        if (!spans)\n            return null;\n        let out;\n        for (let i = 0; i < spans.length; ++i) {\n            if (spans[i].marker.explicitlyCleared) {\n                if (!out)\n                    out = spans.slice(0, i);\n            } else if (out)\n                out.push(spans[i]);\n        }\n        return !out ? spans : out.length ? out : null;\n    }\n    function getOldSpans(doc, change) {\n        let found = change['spans_' + doc.id];\n        if (!found)\n            return null;\n        let nw = [];\n        for (let i = 0; i < change.text.length; ++i)\n            nw.push(removeClearedSpans(found[i]));\n        return nw;\n    }\n    function mergeOldSpans(doc, change) {\n        let old = getOldSpans(doc, change);\n        let stretched = b.stretchSpansOverChange(doc, change);\n        if (!old)\n            return stretched;\n        if (!stretched)\n            return old;\n        for (let i = 0; i < old.length; ++i) {\n            let oldCur = old[i], stretchCur = stretched[i];\n            if (oldCur && stretchCur) {\n                spans:\n                    for (let j = 0; j < stretchCur.length; ++j) {\n                        let span = stretchCur[j];\n                        for (let k = 0; k < oldCur.length; ++k)\n                            if (oldCur[k].marker == span.marker)\n                                continue spans;\n                        oldCur.push(span);\n                    }\n            } else if (stretchCur) {\n                old[i] = stretchCur;\n            }\n        }\n        return old;\n    }\n    function copyHistoryArray(events, newGroup, instantiateSel) {\n        let copy = [];\n        for (let i = 0; i < events.length; ++i) {\n            let event = events[i];\n            if (event.ranges) {\n                copy.push(instantiateSel ? h.Selection.prototype.deepCopy.call(event) : event);\n                continue;\n            }\n            let changes = event.changes, newChanges = [];\n            copy.push({ changes: newChanges });\n            for (let j = 0; j < changes.length; ++j) {\n                let change = changes[j], m;\n                newChanges.push({\n                    from: change.from,\n                    to: change.to,\n                    text: change.text\n                });\n                if (newGroup)\n                    for (var prop in change)\n                        if (m = prop.match(/^spans_(\\d+)$/)) {\n                            if (e.indexOf(newGroup, Number(m[1])) > -1) {\n                                e.lst(newChanges)[prop] = change[prop];\n                                delete change[prop];\n                            }\n                        }\n            }\n        }\n        return copy;\n    }\n    return {\n        History: History,\n        historyChangeFromChange: historyChangeFromChange,\n        addChangeToHistory: addChangeToHistory,\n        addSelectionToHistory: addSelectionToHistory,\n        pushSelectionToHistory: pushSelectionToHistory,\n        mergeOldSpans: mergeOldSpans,\n        copyHistoryArray: copyHistoryArray\n    };\n});"]}