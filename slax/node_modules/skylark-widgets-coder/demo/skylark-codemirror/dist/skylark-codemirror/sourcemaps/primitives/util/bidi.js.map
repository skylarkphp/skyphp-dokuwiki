{"version":3,"sources":["primitives/util/bidi.js"],"names":["define","a","bidiOther","bidiOrdering","lowTypes","arabicTypes","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","BidiSpan","level","from","to","this","str","direction","outerType","length","test","len","types","i","push","code","charCodeAt","charAt","prev","type","cur","end","replace","j","before","m","order","start","pos","at","splice","nstart","match","unshift","lst","reverse","iterateBidiSections","f","found","part","Math","max","min","getBidiPartAt","ch","sticky","getOrder","line","text"],"mappings":"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","file":"../../../primitives/util/bidi.js","sourcesContent":["define(['./misc'], function (a) {\n    'use strict';\n    function iterateBidiSections(order, from, to, f) {\n        if (!order)\n            return f(from, to, 'ltr', 0);\n        let found = false;\n        for (let i = 0; i < order.length; ++i) {\n            let part = order[i];\n            if (part.from < to && part.to > from || from == to && part.to == from) {\n                f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? 'rtl' : 'ltr', i);\n                found = true;\n            }\n        }\n        if (!found)\n            f(from, to, 'ltr');\n    }\n    let bidiOther = null;\n    function getBidiPartAt(order, ch, sticky) {\n        let found;\n        bidiOther = null;\n        for (let i = 0; i < order.length; ++i) {\n            let cur = order[i];\n            if (cur.from < ch && cur.to > ch)\n                return i;\n            if (cur.to == ch) {\n                if (cur.from != cur.to && sticky == 'before')\n                    found = i;\n                else\n                    bidiOther = i;\n            }\n            if (cur.from == ch) {\n                if (cur.from != cur.to && sticky != 'before')\n                    found = i;\n                else\n                    bidiOther = i;\n            }\n        }\n        return found != null ? found : bidiOther;\n    }\n    let bidiOrdering = function () {\n        let lowTypes = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN';\n        let arabicTypes = 'nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111';\n        function charType(code) {\n            if (code <= 247)\n                return lowTypes.charAt(code);\n            else if (1424 <= code && code <= 1524)\n                return 'R';\n            else if (1536 <= code && code <= 1785)\n                return arabicTypes.charAt(code - 1536);\n            else if (1774 <= code && code <= 2220)\n                return 'r';\n            else if (8192 <= code && code <= 8203)\n                return 'w';\n            else if (code == 8204)\n                return 'b';\n            else\n                return 'L';\n        }\n        let bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n        let isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n        function BidiSpan(level, from, to) {\n            this.level = level;\n            this.from = from;\n            this.to = to;\n        }\n        return function (str, direction) {\n            let outerType = direction == 'ltr' ? 'L' : 'R';\n            if (str.length == 0 || direction == 'ltr' && !bidiRE.test(str))\n                return false;\n            let len = str.length, types = [];\n            for (let i = 0; i < len; ++i)\n                types.push(charType(str.charCodeAt(i)));\n            for (let i = 0, prev = outerType; i < len; ++i) {\n                let type = types[i];\n                if (type == 'm')\n                    types[i] = prev;\n                else\n                    prev = type;\n            }\n            for (let i = 0, cur = outerType; i < len; ++i) {\n                let type = types[i];\n                if (type == '1' && cur == 'r')\n                    types[i] = 'n';\n                else if (isStrong.test(type)) {\n                    cur = type;\n                    if (type == 'r')\n                        types[i] = 'R';\n                }\n            }\n            for (let i = 1, prev = types[0]; i < len - 1; ++i) {\n                let type = types[i];\n                if (type == '+' && prev == '1' && types[i + 1] == '1')\n                    types[i] = '1';\n                else if (type == ',' && prev == types[i + 1] && (prev == '1' || prev == 'n'))\n                    types[i] = prev;\n                prev = type;\n            }\n            for (let i = 0; i < len; ++i) {\n                let type = types[i];\n                if (type == ',')\n                    types[i] = 'N';\n                else if (type == '%') {\n                    let end;\n                    for (end = i + 1; end < len && types[end] == '%'; ++end) {\n                    }\n                    let replace = i && types[i - 1] == '!' || end < len && types[end] == '1' ? '1' : 'N';\n                    for (let j = i; j < end; ++j)\n                        types[j] = replace;\n                    i = end - 1;\n                }\n            }\n            for (let i = 0, cur = outerType; i < len; ++i) {\n                let type = types[i];\n                if (cur == 'L' && type == '1')\n                    types[i] = 'L';\n                else if (isStrong.test(type))\n                    cur = type;\n            }\n            for (let i = 0; i < len; ++i) {\n                if (isNeutral.test(types[i])) {\n                    let end;\n                    for (end = i + 1; end < len && isNeutral.test(types[end]); ++end) {\n                    }\n                    let before = (i ? types[i - 1] : outerType) == 'L';\n                    let after = (end < len ? types[end] : outerType) == 'L';\n                    let replace = before == after ? before ? 'L' : 'R' : outerType;\n                    for (let j = i; j < end; ++j)\n                        types[j] = replace;\n                    i = end - 1;\n                }\n            }\n            let order = [], m;\n            for (let i = 0; i < len;) {\n                if (countsAsLeft.test(types[i])) {\n                    let start = i;\n                    for (++i; i < len && countsAsLeft.test(types[i]); ++i) {\n                    }\n                    order.push(new BidiSpan(0, start, i));\n                } else {\n                    let pos = i, at = order.length;\n                    for (++i; i < len && types[i] != 'L'; ++i) {\n                    }\n                    for (let j = pos; j < i;) {\n                        if (countsAsNum.test(types[j])) {\n                            if (pos < j)\n                                order.splice(at, 0, new BidiSpan(1, pos, j));\n                            let nstart = j;\n                            for (++j; j < i && countsAsNum.test(types[j]); ++j) {\n                            }\n                            order.splice(at, 0, new BidiSpan(2, nstart, j));\n                            pos = j;\n                        } else\n                            ++j;\n                    }\n                    if (pos < i)\n                        order.splice(at, 0, new BidiSpan(1, pos, i));\n                }\n            }\n            if (direction == 'ltr') {\n                if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n                    order[0].from = m[0].length;\n                    order.unshift(new BidiSpan(0, 0, m[0].length));\n                }\n                if (a.lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n                    a.lst(order).to -= m[0].length;\n                    order.push(new BidiSpan(0, len - m[0].length, len));\n                }\n            }\n            return direction == 'rtl' ? order.reverse() : order;\n        };\n    }();\n    function getOrder(line, direction) {\n        let order = line.order;\n        if (order == null)\n            order = line.order = bidiOrdering(line.text, direction);\n        return order;\n    }\n    return {\n        iterateBidiSections: iterateBidiSections,\n        bidiOther: bidiOther,\n        getBidiPartAt: getBidiPartAt,\n        getOrder: getOrder\n    };\n});"]}